\section{Ds}
\subsection{HLD}
\createlinenumber{1}{617f}
\createlinenumber{2}{5c83}
\createlinenumber{3}{c62b}
\createlinenumber{4}{9079}
\createlinenumber{5}{aad0}
\createlinenumber{6}{427e}
\createlinenumber{7}{c4d2}
\createlinenumber{8}{752d}
\createlinenumber{9}{217c}
\createlinenumber{10}{95cf}
\createlinenumber{11}{d34f}
\createlinenumber{12}{b985}
\createlinenumber{13}{c4b0}
\createlinenumber{14}{2b9a}
\createlinenumber{15}{dd5a}
\createlinenumber{16}{43f8}
\createlinenumber{17}{f852}
\createlinenumber{18}{1307}
\createlinenumber{19}{1433}
\createlinenumber{20}{34e0}
\createlinenumber{21}{7871}
\createlinenumber{22}{a75b}
\createlinenumber{23}{95cf}
\createlinenumber{24}{f6f4}
\createlinenumber{25}{c71a}
\createlinenumber{26}{95cf}
\createlinenumber{27}{e294}
\createlinenumber{28}{200c}
\createlinenumber{29}{1a33}
\createlinenumber{30}{07ac}
\createlinenumber{31}{edd8}
\createlinenumber{32}{1c88}
\createlinenumber{33}{95cf}
\createlinenumber{34}{4d34}
\createlinenumber{35}{a4d2}
\createlinenumber{36}{888d}
\createlinenumber{37}{95cf}
\createlinenumber{38}{e380}
\createlinenumber{39}{18f6}
\createlinenumber{40}{7861}
\createlinenumber{41}{b333}
\createlinenumber{42}{19a5}
\createlinenumber{43}{bbda}
\createlinenumber{44}{221a}
\createlinenumber{45}{1b6f}
\createlinenumber{46}{0ee8}
\createlinenumber{47}{c326}
\createlinenumber{48}{95cf}
\createlinenumber{49}{95cf}
\createlinenumber{50}{60ec}
\createlinenumber{51}{643e}
\createlinenumber{52}{7743}
\createlinenumber{53}{6af6}
\createlinenumber{54}{fce5}
\createlinenumber{55}{4f2d}
\createlinenumber{56}{12f1}
\createlinenumber{57}{18f6}
\createlinenumber{58}{7593}
\createlinenumber{59}{b333}
\createlinenumber{60}{8064}
\createlinenumber{61}{95cf}
\createlinenumber{62}{80cd}
\createlinenumber{63}{95cf}
\createlinenumber{64}{0f0b}
\createlinenumber{65}{03a1}
\createlinenumber{66}{5c7d}
\createlinenumber{67}{23a2}
\createlinenumber{68}{8e2e}
\createlinenumber{69}{560a}
\createlinenumber{70}{95cf}
\createlinenumber{71}{95cf}
\createlinenumber{72}{d9e4}
\createlinenumber{73}{95cf}
\createlinenumber{74}{427e}
\createlinenumber{75}{f96b}
\createlinenumber{76}{9c27}
\createlinenumber{77}{95cf}
\createlinenumber{78}{427e}
\createlinenumber{79}{6f23}
\createlinenumber{80}{922a}
\createlinenumber{81}{fb5e}
\createlinenumber{82}{95cf}
\createlinenumber{83}{427e}
\createlinenumber{84}{28ba}
\createlinenumber{85}{427e}
\createlinenumber{86}{b603}
\createlinenumber{87}{23a2}
\createlinenumber{88}{95cf}
\createlinenumber{89}{427e}
\createlinenumber{90}{ed85}
\createlinenumber{91}{95cf}
\createlinenumber{92}{427e}
\createlinenumber{93}{c0f6}
\createlinenumber{94}{3682}
\createlinenumber{95}{95cf}
\createlinenumber{96}{427e}
\createlinenumber{97}{ea0e}
\createlinenumber{98}{4309}
\createlinenumber{99}{a237}
\createlinenumber{100}{81b0}
\createlinenumber{101}{95cf}
\createlinenumber{102}{427e}
\createlinenumber{103}{1c9f}
\createlinenumber{104}{74ae}
\createlinenumber{105}{95cf}
\createlinenumber{106}{427e}
\createlinenumber{107}{01f1}
\createlinenumber{108}{c861}
\createlinenumber{109}{b251}
\createlinenumber{110}{645e}
\createlinenumber{111}{9d2c}
\createlinenumber{112}{95cf}
\createlinenumber{113}{427e}
\createlinenumber{114}{ca0c}
\createlinenumber{115}{a237}
\createlinenumber{116}{c757}
\createlinenumber{117}{95cf}
\createlinenumber{118}{8b74}
\createlinenumber{119}{4715}
\createlinenumber{120}{95cf}
\createlinenumber{121}{427e}
\createlinenumber{122}{5858}
\createlinenumber{123}{95cf}
\createlinenumber{124}{427e}
\createlinenumber{125}{3305}
\createlinenumber{126}{b841}
\createlinenumber{127}{95cf}
\createlinenumber{128}{329b}
\begin{lstlisting}[language=C++]
struct HLD {
    int n;
    vector<int> siz, top, dep, parent, l, r, hson, seq;
    vector<vector<int>> adj;
    int idx;

    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n + 1);
        top.resize(n + 1);
        dep.resize(n + 1);
        parent.resize(n + 1);
        l.resize(n + 1);
        r.resize(n + 1);
        hson.resize(n + 1);
        seq.resize(n + 1);
        idx = 0;
        adj.assign(n + 1, {});
    }
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    void work(int root = 1) {
        top[root] = root;
        dep[root] = 1;
        parent[root] = -1;
        dfs1(root, -1);
        dfs2(root, root);
    }
    void dfs1(int u, int f) {  // 搞fa,dep,son
        if (parent[u] != -1) {
            adj[u].erase(find(alls(adj[u]), parent[u]));
        }
        siz[u] = 1;
        for (int v : adj[u]) {
            if (v == f)
                continue;
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[hson[u]] < siz[v])
                hson[u] = v;
        }
    }
    void dfs2(int u, int t) {  // 搞top
        top[u] = t;            // 记录链头
        l[u] = idx++;
        seq[l[u]] = u;
        if (!hson[u])
            return;        // 无重儿子
        dfs2(hson[u], t);  // 搜重儿子
        for (int v : adj[u]) {
            if (v == parent[u] || v == hson[u])
                continue;
            dfs2(v, v);  // 搜轻儿子
        }
        r[u] = idx;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }

    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }

    int jump(int u, int k) {
        if (dep[u] < k) {
            return -1;
        }

        int d = dep[u] - k;  // 目标节点的深度

        while (dep[top[u]] > d) {  // 不在当前链上
            u = parent[top[u]];    // 跳链头的父亲
        }
        // 同一条链上dfs序连续
        return seq[l[u] - dep[u] + d];
    }

    bool isAncester(int u, int v) {  // 判断u是不是v的祖先
        return l[u] <= l[v] && l[v] < r[u];
    }

    int rootedParent(int u, int v) {  // u为根的时候，v的父亲节点
        swap(u, v);
        if (u == v) {
            return u;
        }
        // v为根的时候，u的父亲节点
        if (!isAncester(u, v)) {  // u不是v的祖先
            return parent[u];
        }
        // u是v的祖先。现在v为根，u的父亲是(dfs序>=v)的那个节点
        auto it = upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {
            return l[x] < l[y];
        });
        it--;  // 找到第最后一个小于vd的dfs序节点
        return *it;
    }

    int rootedSize(int u, int v) {  // u为根的时候，v的子树大小
        if (u == v) {
            return n;
        }
        if (!isAncester(v, u)) {  // 如果v不是u的祖先
            return siz[v];
        }
        // v是u祖先。找到u为根的时候v的父亲。总数减去包含u的那部分
        return n - siz[rootedParent(u, v)];
    }

    int rootedLca(int a, int b, int c) {
        return lca(a, b) ^ lca(b, c) ^ lca(c, a);
    }
};
\end{lstlisting}
\subsection{LCA}
\createlinenumber{129}{49b3}
\createlinenumber{130}{bcf8}
\createlinenumber{131}{c70d}
\createlinenumber{132}{329b}
\createlinenumber{133}{5c83}
\createlinenumber{134}{0d66}
\createlinenumber{135}{88d1}
\createlinenumber{136}{d624}
\createlinenumber{137}{21e4}
\createlinenumber{138}{7c99}
\createlinenumber{139}{23d7}
\createlinenumber{140}{217c}
\createlinenumber{141}{95cf}
\createlinenumber{142}{6a1e}
\createlinenumber{143}{f06d}
\createlinenumber{144}{09ff}
\createlinenumber{145}{dd5a}
\createlinenumber{146}{eafc}
\createlinenumber{147}{f229}
\createlinenumber{148}{02fc}
\createlinenumber{149}{95cf}
\createlinenumber{150}{d9b3}
\createlinenumber{151}{0d3e}
\createlinenumber{152}{95cf}
\createlinenumber{153}{312b}
\createlinenumber{154}{9614}
\createlinenumber{155}{98f1}
\createlinenumber{156}{50c0}
\createlinenumber{157}{46dd}
\createlinenumber{158}{0f02}
\createlinenumber{159}{8e5f}
\createlinenumber{160}{c221}
\createlinenumber{161}{b333}
\createlinenumber{162}{2a0a}
\createlinenumber{163}{e2f7}
\createlinenumber{164}{8449}
\createlinenumber{165}{95cf}
\createlinenumber{166}{95cf}
\createlinenumber{167}{620b}
\createlinenumber{168}{c72f}
\createlinenumber{169}{47d4}
\createlinenumber{170}{c699}
\createlinenumber{171}{c185}
\createlinenumber{172}{765c}
\createlinenumber{173}{95cf}
\createlinenumber{174}{427e}
\createlinenumber{175}{0577}
\createlinenumber{176}{c218}
\createlinenumber{177}{427e}
\createlinenumber{178}{c699}
\createlinenumber{179}{4681}
\createlinenumber{180}{765c}
\createlinenumber{181}{fc86}
\createlinenumber{182}{95cf}
\createlinenumber{183}{95cf}
\createlinenumber{184}{427e}
\createlinenumber{185}{1eeb}
\createlinenumber{186}{95cf}
\createlinenumber{187}{56d3}
\createlinenumber{188}{9c27}
\createlinenumber{189}{95cf}
\createlinenumber{190}{cc36}
\createlinenumber{191}{7648}
\createlinenumber{192}{570e}
\createlinenumber{193}{765c}
\createlinenumber{194}{d074}
\createlinenumber{195}{95cf}
\createlinenumber{196}{329b}
\begin{lstlisting}[language=C++]
struct Blca {
    struct edge {
        int v = 0, w = 1;
    };
    int n;
    const static int len = __lg(N);
    vector<vector<edge>> e;
    vector<int> dep, dw, sz;
    vector<array<int, len + 1>> st;
    Blca() {};
    Blca(int n) {
        init(n);
    }
    void init(int n1) {
        n = n1;
        e.resize(n + 1);
        dep.resize(n + 1);
        dw.resize(n + 1);
        sz.resize(n + 1);
        st.resize(n + 1);
    }
    void add(int u, int v, int w = 1) {
        e[u].emplace_back(v, w);
    }
    void dfs(int u, int fa) {
        dep[u] = dep[fa] + 1;
        st[u][0] = fa;
        sz[u] = 1;
        for (int i = 1; i <= len; i++) st[u][i] = st[st[u][i - 1]][i - 1];
        for (auto [v, w] : e[u]) {
            deb(u, v);
            if (v == fa)
                continue;
            dw[u] = dw[v] + w;
            dfs(v, u);
            sz[u] += sz[v];
        }
    }
    int lca(int x, int y) {
        if (dep[x] < dep[y])
            swap(x, y);
        for (int i = len; i >= 0; i--) {
            if (dep[st[x][i]] >= dep[y])
                x = st[x][i];
        }
        // 跳到相同深度
        if (x == y)
            return y;
        // 提提前判本身就是祖先关系
        for (int i = len; i >= 0; i--) {
            if (st[x][i] != st[y][i]) {
                x = st[x][i];
                y = st[y][i];
            }
        }
        // 倍增一起向上跳，直到父亲就是答案
        return st[x][0];
    }
    int dis(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
    int jump(int x, int k) {  // k级祖先
        for (int i = len; i >= 0; i--)
            if ((k >> i) & 1)
                x = st[x][i];
        return x;
    }
};
\end{lstlisting}
\subsection{LCARMQ}
\createlinenumber{197}{c3a0}
\createlinenumber{198}{5c83}
\createlinenumber{199}{1dfb}
\createlinenumber{200}{7a04}
\createlinenumber{201}{5d10}
\createlinenumber{202}{0e53}
\createlinenumber{203}{ddc4}
\createlinenumber{204}{fb2a}
\createlinenumber{205}{42f5}
\createlinenumber{206}{dd5a}
\createlinenumber{207}{9bbf}
\createlinenumber{208}{b7ad}
\createlinenumber{209}{d94b}
\createlinenumber{210}{e715}
\createlinenumber{211}{aae5}
\createlinenumber{212}{3e52}
\createlinenumber{213}{bbcb}
\createlinenumber{214}{835e}
\createlinenumber{215}{b333}
\createlinenumber{216}{bb8b}
\createlinenumber{217}{e715}
\createlinenumber{218}{95cf}
\createlinenumber{219}{329b}
\createlinenumber{220}{91cd}
\createlinenumber{221}{b4c7}
\createlinenumber{222}{0a8a}
\createlinenumber{223}{8890}
\createlinenumber{224}{e30d}
\createlinenumber{225}{60fe}
\createlinenumber{226}{3af2}
\createlinenumber{227}{1cf3}
\createlinenumber{228}{dbba}
\createlinenumber{229}{0f5b}
\createlinenumber{230}{95cf}
\createlinenumber{231}{95cf}
\createlinenumber{232}{95cf}
\createlinenumber{233}{0f0b}
\createlinenumber{234}{aed6}
\createlinenumber{235}{0406}
\createlinenumber{236}{4309}
\createlinenumber{237}{e52a}
\createlinenumber{238}{f602}
\createlinenumber{239}{9670}
\createlinenumber{240}{2ae9}
\createlinenumber{241}{95cf}
\createlinenumber{242}{329b}
\begin{lstlisting}[language=C++]
struct LcaRmq {
    int n;
    vector<vector<int>> &adj;
    int root, tot;
    vector<int> dfn, ol, lg2, dep;
    vector<vector<int>> st;
    LcaRmq(int n_, auto &g_, auto r = 1) : n(n_), adj(g_), root(r) {
        ol.resize(n << 1);
        dfn.resize(n + 1);
        dep.resize(n + 1);
        lg2.resize(n << 1);
        tot = 0;
        auto dfs = [&](int x, int fa, auto dfs) -> void {
            ol[++tot] = x;
            dfn[x] = tot;
            dep[x] = dep[fa] + 1;
            for (auto y : adj[x]) {
                if (y == fa)
                    continue;
                dfs(y, x, dfs);
                ol[++tot] = x;
            }
        };
        dfs(root, 0, dfs);
        lg2[0] = -1;
        for (int i = 1; i <= tot; i++) lg2[i] = lg2[i >> 1] + 1;
        st.assign(lg2[tot] + 1, vector<int>(n * 2, 0));
        for (int i = 1; i <= tot; i++) st[0][i] = ol[i];
        for (int j = 1; j <= lg2[tot]; j++) {
            for (int i = 1; i + (1 << j) - 1 <= tot; i++) {
                st[j][i] = dep[st[j - 1][i]] < dep[st[j - 1][i + (1 << (j - 1))]]
                               ? st[j - 1][i]
                               : st[j - 1][i + (1 << (j - 1))];
            }
        }
    }
    int lca(int u, int v) {
        u = dfn[u], v = dfn[v];
        if (u > v)
            swap(u, v);
        int d = lg2[v - u + 1];
        return dep[st[d][u]] < dep[st[d][v - (1 << d) + 1]]
                   ? st[d][u]
                   : st[d][v - (1 << d) + 1];
    }
};
\end{lstlisting}
\subsection{LCA\_HLD}
\createlinenumber{243}{bcf8}
\createlinenumber{244}{7a26}
\createlinenumber{245}{329b}
\createlinenumber{246}{617f}
\createlinenumber{247}{5c83}
\createlinenumber{248}{782b}
\createlinenumber{249}{d454}
\createlinenumber{250}{aad0}
\createlinenumber{251}{c4d2}
\createlinenumber{252}{752d}
\createlinenumber{253}{217c}
\createlinenumber{254}{95cf}
\createlinenumber{255}{d34f}
\createlinenumber{256}{b985}
\createlinenumber{257}{fce3}
\createlinenumber{258}{43f8}
\createlinenumber{259}{0bc6}
\createlinenumber{260}{7871}
\createlinenumber{261}{a9db}
\createlinenumber{262}{427e}
\createlinenumber{263}{95cf}
\createlinenumber{264}{5953}
\createlinenumber{265}{77d1}
\createlinenumber{266}{95cf}
\createlinenumber{267}{e294}
\createlinenumber{268}{200c}
\createlinenumber{269}{07ac}
\createlinenumber{270}{1a33}
\createlinenumber{271}{edd8}
\createlinenumber{272}{1c88}
\createlinenumber{273}{95cf}
\createlinenumber{274}{4d34}
\createlinenumber{275}{e380}
\createlinenumber{276}{f95d}
\createlinenumber{277}{7861}
\createlinenumber{278}{b333}
\createlinenumber{279}{19a5}
\createlinenumber{280}{bbda}
\createlinenumber{281}{221a}
\createlinenumber{282}{1b6f}
\createlinenumber{283}{0ee8}
\createlinenumber{284}{c326}
\createlinenumber{285}{95cf}
\createlinenumber{286}{95cf}
\createlinenumber{287}{60ec}
\createlinenumber{288}{643e}
\createlinenumber{289}{a577}
\createlinenumber{290}{1a26}
\createlinenumber{291}{80cd}
\createlinenumber{292}{4f2d}
\createlinenumber{293}{95cf}
\createlinenumber{294}{12f1}
\createlinenumber{295}{f95d}
\createlinenumber{296}{7593}
\createlinenumber{297}{b333}
\createlinenumber{298}{8064}
\createlinenumber{299}{95cf}
\createlinenumber{300}{80cd}
\createlinenumber{301}{95cf}
\createlinenumber{302}{0f0b}
\createlinenumber{303}{03a1}
\createlinenumber{304}{5c7d}
\createlinenumber{305}{23a2}
\createlinenumber{306}{8e2e}
\createlinenumber{307}{560a}
\createlinenumber{308}{95cf}
\createlinenumber{309}{95cf}
\createlinenumber{310}{d9e4}
\createlinenumber{311}{95cf}
\createlinenumber{312}{c0f6}
\createlinenumber{313}{3505}
\createlinenumber{314}{95cf}
\createlinenumber{315}{329b}
\begin{lstlisting}[language=C++]
struct edge {
    int v, w;
};
struct HLD {
    int n;
    vector<int> siz, top, parent, l, r, hson, dep;
    vector<vector<edge>> adj;
    int idx;
    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n + 1), hson.resize(n + 1), top.resize(n + 1);
        parent.resize(n + 1);
        l.resize(n + 1), r.resize(n + 1);
        idx = 0;
        adj.resize(n + 1), dep.resize(n + 1);
        // 根据题目要求加数据结构
    }
    void addEdge(int u, int v, int w) {
        adj[u].push_back({v, w});
    }
    void work(int root = 1) {
        top[root] = root;
        parent[root] = -1;
        dep[root] = 1;
        dfs1(root, -1);
        dfs2(root, root);
    }
    void dfs1(int u, int f) {  // 搞fa,dep,son
        siz[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (v == f)
                continue;
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[hson[u]] < siz[v])
                hson[u] = v;
        }
    }
    void dfs2(int u, int t) {  // 搞top
        top[u] = t;            // 记录链头
        l[u] = ++idx;
        if (!hson[u]) {
            r[u] = idx;
            return;
        }  // 无重儿子
        dfs2(hson[u], t);  // 搜重儿子
        for (auto [v, w] : adj[u]) {
            if (v == parent[u] || v == hson[u])
                continue;
            dfs2(v, v);  // 搜轻儿子
        }
        r[u] = idx;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    bool isAncester(int u, int v) {  // 判断u是不是v的祖先
        return l[u] <= l[v] && r[v] <= r[u];
    }
};
\end{lstlisting}
\subsection{Miller\_Robin}
\createlinenumber{316}{3c92}
\createlinenumber{317}{ee66}
\createlinenumber{318}{a4b3}
\createlinenumber{319}{95cf}
\createlinenumber{320}{9a69}
\createlinenumber{321}{fa68}
\createlinenumber{322}{a386}
\createlinenumber{323}{6f75}
\createlinenumber{324}{e72c}
\createlinenumber{325}{244d}
\createlinenumber{326}{95cf}
\createlinenumber{327}{b6c3}
\createlinenumber{328}{a4d9}
\createlinenumber{329}{438e}
\createlinenumber{330}{043a}
\createlinenumber{331}{d77a}
\createlinenumber{332}{f9a3}
\createlinenumber{333}{acb2}
\createlinenumber{334}{32fb}
\createlinenumber{335}{3361}
\createlinenumber{336}{5415}
\createlinenumber{337}{d97e}
\createlinenumber{338}{b333}
\createlinenumber{339}{0996}
\createlinenumber{340}{22b4}
\createlinenumber{341}{9d44}
\createlinenumber{342}{d216}
\createlinenumber{343}{048a}
\createlinenumber{344}{6173}
\createlinenumber{345}{95cf}
\createlinenumber{346}{95cf}
\createlinenumber{347}{9449}
\createlinenumber{348}{438e}
\createlinenumber{349}{95cf}
\createlinenumber{350}{3361}
\createlinenumber{351}{95cf}
\begin{lstlisting}[language=C++]
using i64 = long long;
i64 mul(i64 a, i64 b, i64 m) {
    return static_cast<__int128>(a) * b % m;
}
i64 power(i64 a, i64 b, i64 m) {
    i64 res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m))
        if (b & 1)
            res = mul(res, a, m);
    return res;
}
bool isprime(i64 n) {//log^3(n)
    if (n < 2)
        return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    int s = __builtin_ctzll(n - 1);
    i64 d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n)
            return true;
        i64 x = power(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool ok = false;
        for (int i = 0; i < s - 1; ++i) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok)
            return false;
    }
    return true;
}
\end{lstlisting}
\subsection{divide\_CDQ}
\createlinenumber{352}{9627}
\createlinenumber{353}{35b8}
\createlinenumber{354}{9af0}
\createlinenumber{355}{2524}
\createlinenumber{356}{1859}
\createlinenumber{357}{2fc4}
\createlinenumber{358}{ef5b}
\createlinenumber{359}{e052}
\createlinenumber{360}{3c9e}
\createlinenumber{361}{3398}
\createlinenumber{362}{e86e}
\createlinenumber{363}{95cf}
\createlinenumber{364}{0a68}
\createlinenumber{365}{1d6d}
\createlinenumber{366}{6dbf}
\createlinenumber{367}{ae1b}
\createlinenumber{368}{acaf}
\createlinenumber{369}{70e4}
\createlinenumber{370}{95cf}
\createlinenumber{371}{95cf}
\createlinenumber{372}{84c3}
\createlinenumber{373}{fded}
\createlinenumber{374}{247a}
\createlinenumber{375}{329b}
\createlinenumber{376}{9c6d}
\createlinenumber{377}{cb4c}
\createlinenumber{378}{300a}
\createlinenumber{379}{7632}
\createlinenumber{380}{2241}
\createlinenumber{381}{65bd}
\createlinenumber{382}{4f2d}
\createlinenumber{383}{bfe3}
\createlinenumber{384}{84c4}
\createlinenumber{385}{85eb}
\createlinenumber{386}{1d25}
\createlinenumber{387}{338d}
\createlinenumber{388}{fa6b}
\createlinenumber{389}{870e}
\createlinenumber{390}{ba2d}
\createlinenumber{391}{8e2e}
\createlinenumber{392}{4008}
\createlinenumber{393}{3e91}
\createlinenumber{394}{95cf}
\createlinenumber{395}{95cf}
\createlinenumber{396}{12d5}
\createlinenumber{397}{870e}
\createlinenumber{398}{ba2d}
\createlinenumber{399}{95cf}
\createlinenumber{400}{e629}
\createlinenumber{401}{4008}
\createlinenumber{402}{3e91}
\createlinenumber{403}{95cf}
\createlinenumber{404}{b79e}
\createlinenumber{405}{51dc}
\createlinenumber{406}{329b}
\createlinenumber{407}{efad}
\createlinenumber{408}{4206}
\createlinenumber{409}{329b}
\createlinenumber{410}{7201}
\createlinenumber{411}{3b1c}
\createlinenumber{412}{329b}
\createlinenumber{413}{4889}
\createlinenumber{414}{0bf0}
\createlinenumber{415}{6dbf}
\createlinenumber{416}{8f8d}
\createlinenumber{417}{95cf}
\createlinenumber{418}{e95a}
\createlinenumber{419}{f5f8}
\createlinenumber{420}{6dbf}
\createlinenumber{421}{89cf}
\createlinenumber{422}{95cf}
\createlinenumber{423}{29e3}
\createlinenumber{424}{077e}
\createlinenumber{425}{d814}
\createlinenumber{426}{2a25}
\createlinenumber{427}{95cf}
\begin{lstlisting}[language=C++]
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);
    vector<int> pos(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i], pos[a[i]] = i;
    vector<int> t(n + 1);
    for (int i = 1; i <= m; i++) {
        int x;
        cin >> x;
        t[pos[x]] = i;  // x这个元素在pos[x]，我们研究下标，所以下标pos[x]在i时刻被删除
    }
    int cur = m;
    deb(a);
    for (int i = 1; i <= n; i++) {
        if (t[i] == 0) {
            cur++;
            t[i] = cur;
        }
    }
    deb(t);
    auto cmpx = [&](array<int, 4>& c, array<int, 4>& d) {
        return c[1] < d[1];
    };
    auto cal = [&](vector<array<int, 4>>& q) {
        vector<int> ans(n + 1);
        Fwk<int> c(n + 1);
        sort(q.begin() + 1, q.end());
        auto cdq = [&](auto self, int l, int r) {
            if (l == r)
                return;
            int mid = (l + r) >> 1;
            self(self, l, mid);
            self(self, mid + 1, r);
            int pl = l, pr = mid + 1;
            while (pl <= mid && pr <= r) {
                if (q[pl][1] < q[pr][1]) {
                    c.add(q[pl][2], 1);
                    pl++;
                } else {
                    ans[q[pr][3]] += c.sum(q[pr][2]);
                    pr++;
                }
            }
            while (pl <= mid) {
                c.add(q[pl][2], 1);
                pl++;
            }
            while (pr <= r) {
                ans[q[pr][3]] += c.sum(q[pr][2]);
                pr++;
            }
            for (int i = l; i <= mid; i++) c.add(q[i][2], -1);
            sort(q.begin() + l, q.begin() + r + 1, cmpx);
        };
        cdq(cdq, 1, n);
        return ans;
    };
    auto re = [&](int x) {
        return n + 1 - x;
    };
    vector<ll> res(n + 2);
    vector<array<int, 4>> q(n + 1);
    for (int i = 1; i <= n; i++) {
        q[i] = {re(t[i]), i, re(a[i]), i};
    }
    auto ans1 = cal(q);
    for (int i = 1; i <= n; i++) res[t[i]] += ans1[i];
    for (int i = 1; i <= n; i++) {
        q[i] = {re(t[i]), re(i), a[i], i};
    }
    auto ans2 = cal(q);
    for (int i = 1; i <= n; i++) res[t[i]] += ans2[i];
    for (int i = n; i >= 1; i--) res[i] += res[i + 1];
    for (int i = 1; i <= m; i++) cout << res[i] << endl;
}
\end{lstlisting}
\subsection{divide\_dot}
\createlinenumber{428}{bcf8}
\createlinenumber{429}{7a26}
\createlinenumber{430}{329b}
\createlinenumber{431}{9627}
\createlinenumber{432}{35b8}
\createlinenumber{433}{9af0}
\createlinenumber{434}{de3b}
\createlinenumber{435}{7300}
\createlinenumber{436}{3676}
\createlinenumber{437}{cd17}
\createlinenumber{438}{298c}
\createlinenumber{439}{2537}
\createlinenumber{440}{95cf}
\createlinenumber{441}{9704}
\createlinenumber{442}{54bd}
\createlinenumber{443}{427e}
\createlinenumber{444}{bedd}
\createlinenumber{445}{cd52}
\createlinenumber{446}{293d}
\createlinenumber{447}{583e}
\createlinenumber{448}{cb4c}
\createlinenumber{449}{91d5}
\createlinenumber{450}{427e}
\createlinenumber{451}{427e}
\createlinenumber{452}{657c}
\createlinenumber{453}{50c0}
\createlinenumber{454}{0086}
\createlinenumber{455}{0f02}
\createlinenumber{456}{abb0}
\createlinenumber{457}{b333}
\createlinenumber{458}{842b}
\createlinenumber{459}{8449}
\createlinenumber{460}{4947}
\createlinenumber{461}{95cf}
\createlinenumber{462}{7092}
\createlinenumber{463}{56a0}
\createlinenumber{464}{dc23}
\createlinenumber{465}{a28d}
\createlinenumber{466}{95cf}
\createlinenumber{467}{329b}
\createlinenumber{468}{d0a0}
\createlinenumber{469}{16de}
\createlinenumber{470}{0f02}
\createlinenumber{471}{abb0}
\createlinenumber{472}{b333}
\createlinenumber{473}{a6b8}
\createlinenumber{474}{6bdb}
\createlinenumber{475}{95cf}
\createlinenumber{476}{329b}
\createlinenumber{477}{d7a9}
\createlinenumber{478}{70b6}
\createlinenumber{479}{b999}
\createlinenumber{480}{0f02}
\createlinenumber{481}{e918}
\createlinenumber{482}{b333}
\createlinenumber{483}{3b81}
\createlinenumber{484}{54e7}
\createlinenumber{485}{e7a5}
\createlinenumber{486}{427e}
\createlinenumber{487}{4d2c}
\createlinenumber{488}{05f6}
\createlinenumber{489}{c6d4}
\createlinenumber{490}{dfe4}
\createlinenumber{491}{5e0d}
\createlinenumber{492}{95cf}
\createlinenumber{493}{95cf}
\createlinenumber{494}{95cf}
\createlinenumber{495}{95cf}
\createlinenumber{496}{427e}
\createlinenumber{497}{4d2c}
\createlinenumber{498}{b72a}
\createlinenumber{499}{aef5}
\createlinenumber{500}{2b20}
\createlinenumber{501}{95cf}
\createlinenumber{502}{95cf}
\createlinenumber{503}{95cf}
\createlinenumber{504}{427e}
\createlinenumber{505}{4214}
\createlinenumber{506}{329b}
\createlinenumber{507}{427e}
\createlinenumber{508}{20e1}
\createlinenumber{509}{7312}
\createlinenumber{510}{3f80}
\createlinenumber{511}{0f02}
\createlinenumber{512}{e918}
\createlinenumber{513}{b333}
\createlinenumber{514}{9d39}
\createlinenumber{515}{4b56}
\createlinenumber{516}{701f}
\createlinenumber{517}{95cf}
\createlinenumber{518}{329b}
\createlinenumber{519}{427e}
\createlinenumber{520}{1833}
\createlinenumber{521}{18c6}
\createlinenumber{522}{5af9}
\createlinenumber{523}{ee81}
\createlinenumber{524}{427e}
\createlinenumber{525}{e052}
\createlinenumber{526}{7a76}
\createlinenumber{527}{f4cb}
\createlinenumber{528}{649a}
\createlinenumber{529}{26ef}
\createlinenumber{530}{95cf}
\createlinenumber{531}{95cf}
\begin{lstlisting}[language=C++]
struct edge {
    int v, w;
};
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<edge>> e(n + 1);
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});
    }
    vector<int> q(m + 1);
    for (int i = 1; i <= m; i++) cin >> q[i];
    //----------------------相关数据
    int mxsz = inf, rt = 0;
    vector<int> sz(n + 1);
    vector<int> d(n + 1);    // 距离
    vector<int> del(n + 1);  // 标记
    vector<int> ans(n + 1);
    map<int, int> have;
    // 求重心函数，每次需要传参数：当前剩余点数sum
    // 每次使用getroot以前要初始化mxsz
    auto getroot = [&](auto self, int u, int fa, int sum) -> void {
        sz[u] = 1;
        int tmp = 0;
        for (auto [v, w] : e[u]) {
            if (v == fa || del[v])
                continue;
            self(self, v, u, sum);
            sz[u] += sz[v];
            tmp = max(tmp, sz[v]);
        }
        tmp = max(tmp, sum - sz[u]);
        if (tmp < mxsz) {
            mxsz = tmp;
            rt = u;
        }
    };
    auto upd = [&](auto self, int u, int fa, vector<int>& tmp) -> void {
        tmp.push_back(d[u]);
        for (auto [v, w] : e[u]) {
            if (v == fa || del[v])
                continue;
            d[v] = d[u] + w;
            self(self, v, u, tmp);
        }
    };
    auto cal = [&](int u) -> void {  // 计算经过u的答案
        have[0] = 1;
        vector<int> alltmp;
        for (auto [v, w] : e[u]) {
            if (del[v])
                continue;
            d[v] = w;
            vector<int> tmp;
            upd(upd, v, u, tmp);
            // 更新答案
            for (auto ndis : tmp) {
                for (int k = 1; k <= m; k++) {
                    if (q[k] >= ndis) {
                        if (have.count(q[k] - ndis)) {
                            ans[k] = 1;
                        }
                    }
                }
            }
            // 更新have
            for (auto ndis : tmp) {
                if (ndis <= inf) {  // 这里的距离带边权
                    alltmp.push_back(ndis);
                    have[ndis] = 1;
                }
            }
        }
        // 及时清空这一次的计算，未来还要用
        for (auto x : alltmp) have.erase(x);
    };
    // 分治
    auto divide = [&](auto self, int u) -> void {
        cal(u);
        del[u] = 1;
        for (auto [v, w] : e[u]) {
            if (del[v])
                continue;
            mxsz = sz[v];                  // 分治递归下去
            getroot(getroot, v, v, mxsz);  // 找到新的递归重心
            self(self, rt);
        }
    };
    //-------------------------具体调用
    mxsz = n;
    getroot(getroot, 1, 1, n);    // rt更新
    getroot(getroot, rt, rt, n);  // 重构sz[]
    divide(divide, rt);
    // 输出
    for (int i = 1; i <= m; i++) {
        if (ans[i])
            cout << "AYE" << endl;
        else
            cout << "NAY" << endl;
    }
}
\end{lstlisting}
\subsection{dsu}
\createlinenumber{532}{c592}
\createlinenumber{533}{30a4}
\createlinenumber{534}{427e}
\createlinenumber{535}{6e06}
\createlinenumber{536}{d900}
\createlinenumber{537}{217c}
\createlinenumber{538}{95cf}
\createlinenumber{539}{427e}
\createlinenumber{540}{d34f}
\createlinenumber{541}{96a9}
\createlinenumber{542}{a221}
\createlinenumber{543}{73f6}
\createlinenumber{544}{95cf}
\createlinenumber{545}{427e}
\createlinenumber{546}{cc64}
\createlinenumber{547}{afe9}
\createlinenumber{548}{c195}
\createlinenumber{549}{95cf}
\createlinenumber{550}{d074}
\createlinenumber{551}{95cf}
\createlinenumber{552}{d595}
\createlinenumber{553}{258c}
\createlinenumber{554}{95cf}
\createlinenumber{555}{427e}
\createlinenumber{556}{9b41}
\createlinenumber{557}{95f3}
\createlinenumber{558}{d1ac}
\createlinenumber{559}{d62a}
\createlinenumber{560}{438e}
\createlinenumber{561}{95cf}
\createlinenumber{562}{7e1f}
\createlinenumber{563}{4022}
\createlinenumber{564}{3361}
\createlinenumber{565}{95cf}
\createlinenumber{566}{427e}
\createlinenumber{567}{cb2f}
\createlinenumber{568}{65c2}
\createlinenumber{569}{95cf}
\createlinenumber{570}{329b}
\createlinenumber{571}{427e}
\begin{lstlisting}[language=C++]
struct DSU {
    vector<int> f, siz;

    DSU() {}
    DSU(int n) {
        init(n);
    }

    void init(int n) {
        f.resize(n + 1);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n + 1, 1);
    }

    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }

    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }

    int size(int x) {
        return siz[find(x)];
    }
};

\end{lstlisting}
\subsection{dsu\_del}
\createlinenumber{572}{c592}
\createlinenumber{573}{56bd}
\createlinenumber{574}{a4e4}
\createlinenumber{575}{1879}
\createlinenumber{576}{ac17}
\createlinenumber{577}{9495}
\createlinenumber{578}{95cf}
\createlinenumber{579}{cc64}
\createlinenumber{580}{a193}
\createlinenumber{581}{0cdd}
\createlinenumber{582}{95cf}
\createlinenumber{583}{d074}
\createlinenumber{584}{95cf}
\createlinenumber{585}{9b41}
\createlinenumber{586}{95f3}
\createlinenumber{587}{d1ac}
\createlinenumber{588}{d62a}
\createlinenumber{589}{438e}
\createlinenumber{590}{95cf}
\createlinenumber{591}{b718}
\createlinenumber{592}{47d4}
\createlinenumber{593}{95cf}
\createlinenumber{594}{cec3}
\createlinenumber{595}{7e1f}
\createlinenumber{596}{4022}
\createlinenumber{597}{3361}
\createlinenumber{598}{95cf}
\createlinenumber{599}{427e}
\createlinenumber{600}{533f}
\createlinenumber{601}{0cc3}
\createlinenumber{602}{95cf}
\createlinenumber{603}{427e}
\createlinenumber{604}{47ee}
\createlinenumber{605}{47b8}
\createlinenumber{606}{a61d}
\createlinenumber{607}{67de}
\createlinenumber{608}{c13d}
\createlinenumber{609}{7ed1}
\createlinenumber{610}{95cf}
\createlinenumber{611}{95cf}
\createlinenumber{612}{329b}
\createlinenumber{613}{9627}
\createlinenumber{614}{35b8}
\createlinenumber{615}{9af0}
\createlinenumber{616}{fef0}
\createlinenumber{617}{e052}
\createlinenumber{618}{2d77}
\createlinenumber{619}{4425}
\createlinenumber{620}{3658}
\createlinenumber{621}{0f8b}
\createlinenumber{622}{d480}
\createlinenumber{623}{59ed}
\createlinenumber{624}{8bc7}
\createlinenumber{625}{e9fe}
\createlinenumber{626}{037f}
\createlinenumber{627}{0f8b}
\createlinenumber{628}{d480}
\createlinenumber{629}{312b}
\createlinenumber{630}{0bc2}
\createlinenumber{631}{649a}
\createlinenumber{632}{72d4}
\createlinenumber{633}{95cf}
\createlinenumber{634}{95cf}
\createlinenumber{635}{95cf}
\createlinenumber{636}{427e}
\begin{lstlisting}[language=C++]
struct DSU {
    vector<int> siz;
    vector<int> f;
    vector<array<int, 2>> his;
    DSU(int n) : siz(n + 1, 1), f(n + 1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        while (f[x] != x) {
            x = f[x];
        }
        return x;
    }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if (siz[x] < siz[y]) {
            swap(x, y);
        }
        his.push_back({x, y});
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }

    int time() {
        return his.size();
    }

    void revert(int tm) {
        while (his.size() > tm) {
            auto [x, y] = his.back();
            his.pop_back();
            f[y] = y;
            siz[x] -= siz[y];
        }
    }
};
void solve() {
    int n, m;
    cin >> n >> m;
    DSU dsu(n + 1);
    for (int i = 1; i <= m; i++) {
        int op;
        cin >> op;
        if (op == 1) {//合并x,y
            int x, y;
            cin >> x >> y;
            dsu.merge(x, y);
        } else if (op == 2)//撤回上一次操作
            dsu.revert(dsu.his.size() - 1);
        else {
            int x, y;
            cin >> x >> y;//查询x,y连通性
            if (dsu.find(x) == dsu.find(y))
                cout << "YES" << endl;
            else
                cout << "NO" << endl;
        }
    }
}

\end{lstlisting}
\subsection{dsu\_per}
\createlinenumber{637}{c592}
\createlinenumber{638}{56bd}
\createlinenumber{639}{a4e4}
\createlinenumber{640}{1879}
\createlinenumber{641}{427e}
\createlinenumber{642}{ac17}
\createlinenumber{643}{9495}
\createlinenumber{644}{95cf}
\createlinenumber{645}{427e}
\createlinenumber{646}{cc64}
\createlinenumber{647}{a193}
\createlinenumber{648}{0cdd}
\createlinenumber{649}{95cf}
\createlinenumber{650}{d074}
\createlinenumber{651}{95cf}
\createlinenumber{652}{427e}
\createlinenumber{653}{9b41}
\createlinenumber{654}{95f3}
\createlinenumber{655}{d1ac}
\createlinenumber{656}{d62a}
\createlinenumber{657}{438e}
\createlinenumber{658}{95cf}
\createlinenumber{659}{b718}
\createlinenumber{660}{47d4}
\createlinenumber{661}{95cf}
\createlinenumber{662}{cec3}
\createlinenumber{663}{7e1f}
\createlinenumber{664}{4022}
\createlinenumber{665}{3361}
\createlinenumber{666}{95cf}
\createlinenumber{667}{427e}
\createlinenumber{668}{533f}
\createlinenumber{669}{0cc3}
\createlinenumber{670}{95cf}
\createlinenumber{671}{427e}
\createlinenumber{672}{47ee}
\createlinenumber{673}{1028}
\createlinenumber{674}{a61d}
\createlinenumber{675}{67de}
\createlinenumber{676}{c13d}
\createlinenumber{677}{7ed1}
\createlinenumber{678}{95cf}
\createlinenumber{679}{95cf}
\createlinenumber{680}{40c5}
\createlinenumber{681}{37e6}
\createlinenumber{682}{427e}
\createlinenumber{683}{427e}
\createlinenumber{684}{d6b9}
\createlinenumber{685}{95cf}
\createlinenumber{686}{329b}
\createlinenumber{687}{427e}
\createlinenumber{688}{9627}
\createlinenumber{689}{35b8}
\createlinenumber{690}{9af0}
\createlinenumber{691}{b65c}
\createlinenumber{692}{2654}
\createlinenumber{693}{2d3d}
\createlinenumber{694}{e052}
\createlinenumber{695}{a565}
\createlinenumber{696}{abb8}
\createlinenumber{697}{6038}
\createlinenumber{698}{9238}
\createlinenumber{699}{8e2e}
\createlinenumber{700}{28e7}
\createlinenumber{701}{bae7}
\createlinenumber{702}{584e}
\createlinenumber{703}{0f55}
\createlinenumber{704}{95cf}
\createlinenumber{705}{95cf}
\createlinenumber{706}{7e1b}
\createlinenumber{707}{8cb8}
\createlinenumber{708}{f75e}
\createlinenumber{709}{427e}
\createlinenumber{710}{2aa8}
\createlinenumber{711}{427e}
\createlinenumber{712}{b727}
\createlinenumber{713}{f25a}
\createlinenumber{714}{3f77}
\createlinenumber{715}{a47d}
\createlinenumber{716}{b41b}
\createlinenumber{717}{2e0d}
\createlinenumber{718}{5f3c}
\createlinenumber{719}{427e}
\createlinenumber{720}{3f58}
\createlinenumber{721}{5ac8}
\createlinenumber{722}{95cf}
\createlinenumber{723}{329b}
\createlinenumber{724}{04f4}
\createlinenumber{725}{e052}
\createlinenumber{726}{9015}
\createlinenumber{727}{4bf1}
\createlinenumber{728}{ccb3}
\createlinenumber{729}{95cf}
\createlinenumber{730}{95cf}
\createlinenumber{731}{95cf}
\begin{lstlisting}[language=C++]
struct DSU {
    vector<int> siz;
    vector<int> f;
    vector<array<int, 2>> his;

    DSU(int n) : siz(n + 1, 1), f(n + 1) {
        iota(f.begin(), f.end(), 0);
    }

    int find(int x) {
        while (f[x] != x) {
            x = f[x];
        }
        return x;
    }

    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if (siz[x] < siz[y]) {
            swap(x, y);
        }
        his.push_back({x, y});
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }

    int time() {
        return his.size();
    }

    void revert(int tm) {
        while ((int)his.size() > tm) {
            auto [x, y] = his.back();
            his.pop_back();
            f[y] = y;
            siz[x] -= siz[y];
        }
    }
    void backlast() {
        assert(his.size());
        // if (his.size() == 0)
        //     return;
        revert(his.size() - 1);
    }
};

void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> e(m + 1);
    DSU dsu(n);
    vector<array<int, 3>> type(m + 1);
    for (int i = 1; i <= m; i++) {
        cin >> type[i][0];
        if (type[i][0] == 1 || type[i][0] == 3) {
            e[i - 1].push_back(i);
            cin >> type[i][1] >> type[i][2];
        } else {
            int k;
            cin >> k;
            assert(k < i);
            e[k].push_back(i);
        }
    }
    vector<int> ans(m + 1);
    function<void(int)> dfs = [&](int u) {
        int tmp = dsu.time();

        for (auto v : e[u]) {
            // int tmp = dsu.time();
            auto [op, x, y] = type[v];
            bool flag = 0;
            if (op == 1)
                flag = dsu.merge(x, y);  // 必须合并成功才能在下面撤销
            else if (op == 3)
                ans[v] = (dsu.find(x) == dsu.find(y)) ? 1 : 0;
            dfs(v);
            // dsu.revert(tmp);
            if (op == 1 && flag)
                dsu.backlast();
        }
    };
    dfs(0);
    for (int i = 1; i <= m; i++) {
        if (type[i][0] == 3) {
            deb(i);
            cout << ans[i] << endl;
        }
    }
}
\end{lstlisting}
\subsection{factorize\_i64}
\createlinenumber{732}{3c92}
\createlinenumber{733}{0406}
\createlinenumber{734}{a052}
\createlinenumber{735}{3571}
\createlinenumber{736}{69aa}
\createlinenumber{737}{74e5}
\createlinenumber{738}{0a11}
\createlinenumber{739}{7efb}
\createlinenumber{740}{e1b7}
\createlinenumber{741}{d9b7}
\createlinenumber{742}{4f2d}
\createlinenumber{743}{95cf}
\createlinenumber{744}{1500}
\createlinenumber{745}{d9b7}
\createlinenumber{746}{4f2d}
\createlinenumber{747}{95cf}
\createlinenumber{748}{b578}
\createlinenumber{749}{32a9}
\createlinenumber{750}{329b}
\createlinenumber{751}{d877}
\createlinenumber{752}{1026}
\createlinenumber{753}{41d0}
\createlinenumber{754}{f621}
\createlinenumber{755}{be6c}
\createlinenumber{756}{e03e}
\createlinenumber{757}{887f}
\createlinenumber{758}{9e5b}
\createlinenumber{759}{a8ab}
\createlinenumber{760}{7b2e}
\createlinenumber{761}{9a49}
\createlinenumber{762}{1bf1}
\createlinenumber{763}{8509}
\createlinenumber{764}{8f6e}
\createlinenumber{765}{95cf}
\createlinenumber{766}{9153}
\createlinenumber{767}{0978}
\createlinenumber{768}{ea35}
\createlinenumber{769}{fea7}
\createlinenumber{770}{8509}
\createlinenumber{771}{8f6e}
\createlinenumber{772}{95cf}
\createlinenumber{773}{95cf}
\createlinenumber{774}{bf47}
\createlinenumber{775}{2653}
\createlinenumber{776}{86e7}
\createlinenumber{777}{4f2d}
\createlinenumber{778}{95cf}
\createlinenumber{779}{6825}
\createlinenumber{780}{95cf}
\createlinenumber{781}{329b}
\createlinenumber{782}{7a12}
\createlinenumber{783}{f875}
\createlinenumber{784}{e149}
\createlinenumber{785}{95cf}
\begin{lstlisting}[language=C++]
using i64 = long long;//数学
vector<i64> factorize(i64 n) {  // 期望O(n^(1/4))找到非平凡有因子
    vector<i64> p;
    function<void(i64)> f = [&](i64 n) {
        if (n <= 10000) {
            for (int i = 2; i * i <= n; ++i)
                for (; n % i == 0; n /= i)
                    p.push_back(i);
            if (n > 1)
                p.push_back(n);
            return;
        }
        if (isprime(n)) {
            p.push_back(n);
            return;
        }
        auto g = [&](i64 x) {
            return (mul(x, x, n) + 1) % n;
        };
        i64 x0 = 2;
        while (true) {
            i64 x = x0;
            i64 y = x0;
            i64 d = 1;
            i64 power = 1, lam = 0;
            i64 v = 1;
            while (d == 1) {
                y = g(y);
                ++lam;
                v = mul(v, abs(x - y), n);
                if (lam % 127 == 0) {
                    d = gcd(v, n);
                    v = 1;
                }
                if (power == lam) {
                    x = y;
                    power *= 2;
                    lam = 0;
                    d = gcd(v, n);
                    v = 1;
                }
            }
            if (d != n) {
                f(d);
                f(n / d);
                return;
            }
            ++x0;
        }
    };
    f(n);
    sort(p.begin(), p.end());
    return p;
}
\end{lstlisting}
\subsection{fenwick}
\createlinenumber{786}{b7ec}
\createlinenumber{787}{8f38}
\createlinenumber{788}{5c83}
\createlinenumber{789}{da49}
\createlinenumber{790}{427e}
\createlinenumber{791}{0b4d}
\createlinenumber{792}{9ad8}
\createlinenumber{793}{95cf}
\createlinenumber{794}{427e}
\createlinenumber{795}{ac08}
\createlinenumber{796}{e6a3}
\createlinenumber{797}{2d68}
\createlinenumber{798}{95cf}
\createlinenumber{799}{427e}
\createlinenumber{800}{915f}
\createlinenumber{801}{016c}
\createlinenumber{802}{6eb1}
\createlinenumber{803}{063f}
\createlinenumber{804}{95cf}
\createlinenumber{805}{95cf}
\createlinenumber{806}{427e}
\createlinenumber{807}{78d9}
\createlinenumber{808}{bfea}
\createlinenumber{809}{c22b}
\createlinenumber{810}{c137}
\createlinenumber{811}{3090}
\createlinenumber{812}{95cf}
\createlinenumber{813}{4206}
\createlinenumber{814}{95cf}
\createlinenumber{815}{427e}
\createlinenumber{816}{2560}
\createlinenumber{817}{3b14}
\createlinenumber{818}{95cf}
\createlinenumber{819}{427e}
\createlinenumber{820}{0609}
\createlinenumber{821}{1b7f}
\createlinenumber{822}{353b}
\createlinenumber{823}{83cd}
\createlinenumber{824}{14a8}
\createlinenumber{825}{dcee}
\createlinenumber{826}{4ad5}
\createlinenumber{827}{95cf}
\createlinenumber{828}{95cf}
\createlinenumber{829}{d074}
\createlinenumber{830}{95cf}
\createlinenumber{831}{329b}
\begin{lstlisting}[language=C++]
template <typename T>
struct Fwk {
    int n;
    std::vector<T> a;

    Fwk(int n_ = 0) {
        init(n_);
    }

    void init(int n_) {
        n = n_;
        a.assign(n + 1, T{});
    }

    void add(int x, const T &v) {
        assert(x > 0);
        for (int i = x; i <= n; i += i & -i) {
            a[i] = a[i] + v;
        }
    }

    T sum(int x) {
        T ans{};
        assert(x <= n);
        for (int i = x; i > 0; i -= i & -i) {
            ans = ans + a[i];
        }
        return ans;
    }

    T rangeSum(int l, int r) {  // 要传入l-1
        return sum(r) - sum(l);
    }

    int select(const T &k) {  // 寻找最后一个使得前缀和小于等于 k 的位置。
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {  // GCC
            if (x + i <= n && cur + a[x + i] <= k) {
                x += i;
                cur = cur + a[x];
            }
        }
        return x;
    }
};
\end{lstlisting}
\subsection{hashtree}
\createlinenumber{832}{afac}
\createlinenumber{833}{5c83}
\createlinenumber{834}{510f}
\createlinenumber{835}{e99c}
\createlinenumber{836}{56bd}
\createlinenumber{837}{9d4c}
\createlinenumber{838}{4991}
\createlinenumber{839}{a7d1}
\createlinenumber{840}{bd19}
\createlinenumber{841}{7524}
\createlinenumber{842}{95cf}
\createlinenumber{843}{427e}
\createlinenumber{844}{7282}
\createlinenumber{845}{02d5}
\createlinenumber{846}{2a75}
\createlinenumber{847}{95cf}
\createlinenumber{848}{3a4c}
\createlinenumber{849}{65ff}
\createlinenumber{850}{95cf}
\createlinenumber{851}{891b}
\createlinenumber{852}{49f7}
\createlinenumber{853}{e380}
\createlinenumber{854}{805a}
\createlinenumber{855}{2aa8}
\createlinenumber{856}{c221}
\createlinenumber{857}{b333}
\createlinenumber{858}{ecac}
\createlinenumber{859}{1b6f}
\createlinenumber{860}{f278}
\createlinenumber{861}{95cf}
\createlinenumber{862}{872b}
\createlinenumber{863}{427e}
\createlinenumber{864}{93e9}
\createlinenumber{865}{b9ec}
\createlinenumber{866}{adcc}
\createlinenumber{867}{f0a9}
\createlinenumber{868}{95cf}
\createlinenumber{869}{329b}
\createlinenumber{870}{cf19}
\createlinenumber{871}{87c7}
\createlinenumber{872}{2aa8}
\createlinenumber{873}{c221}
\createlinenumber{874}{b333}
\createlinenumber{875}{faed}
\createlinenumber{876}{f4ba}
\createlinenumber{877}{95cf}
\createlinenumber{878}{329b}
\createlinenumber{879}{007c}
\createlinenumber{880}{a459}
\createlinenumber{881}{58c4}
\createlinenumber{882}{738f}
\createlinenumber{883}{b730}
\createlinenumber{884}{e7bc}
\createlinenumber{885}{0b19}
\createlinenumber{886}{eca2}
\createlinenumber{887}{95cf}
\createlinenumber{888}{3076}
\createlinenumber{889}{95cf}
\createlinenumber{890}{329b}
\createlinenumber{891}{427e}
\createlinenumber{892}{9627}
\createlinenumber{893}{67b8}
\createlinenumber{894}{35b8}
\createlinenumber{895}{2eb3}
\createlinenumber{896}{8e5f}
\createlinenumber{897}{e1b6}
\createlinenumber{898}{a430}
\createlinenumber{899}{6dbf}
\createlinenumber{900}{3c9e}
\createlinenumber{901}{3398}
\createlinenumber{902}{4aff}
\createlinenumber{903}{e17d}
\createlinenumber{904}{649a}
\createlinenumber{905}{b359}
\createlinenumber{906}{95cf}
\createlinenumber{907}{919e}
\createlinenumber{908}{f3b0}
\createlinenumber{909}{a2de}
\createlinenumber{910}{b708}
\createlinenumber{911}{95cf}
\createlinenumber{912}{95cf}
\begin{lstlisting}[language=C++]
struct treehash {
    int n;
    int rt = 0;
    vector<ll> h1, h2;
    vector<int> siz;
    vector<vector<int>> e;
    treehash(int n_) : n(n_), h1(n_ + 1), h2(n_ + 1), siz(n_ + 1), e(n_ + 1) {}
    ll h(ll x) {
#pragma GCC diagnostic ignored "-Woverflow"
        return x * x * x * 1237123 + 19260817;
    }

    ll f(ll x) {
        ll cur = h(x & ((1 << 31) - 1)) + h(x >> 31);
        return cur;
    }
    void add(int u, int v) {
        e[u].push_back(v);
    }
    int pos = 0, pos2 = 0, ans = 1e9;
    void getroot(int u, int fa) {
        siz[u] = 1;
        int mx = 0;
        for (auto v : e[u]) {
            if (v == fa)
                continue;
            getroot(v, u);
            siz[u] += siz[v];
            mx = max(mx, siz[v]);
        }
        mx = max(mx, n - siz[u]);
        // 维护了重心是pos
        if (mx < ans) {
            ans = mx, pos = u, pos2 = 0;
        } else if (mx == ans) {
            pos2 = u;
        }
    };
    void dfs1(int u, int fa, auto &h) {
        h[u] = 1;
        for (auto v : e[u]) {
            if (v == fa)
                continue;
            dfs1(v, u, h);
            h[u] += f(h[v]);
        }
    };
    int work() {
        getroot(rt, 0);
        dfs1(pos, 0, h1);
        if (pos2)
            dfs1(pos2, 0, h2);
        ll val = h1[pos];
        if (pos2) {
            val = max(val, h2[pos2]);
        }
        return val;
    }
};
//m颗无根无标号，n个节点的树。两个哈希值取最大的那个作为key
void solve() {
    map<ll, int> mp;
    int n, m;
    cin >> m;
    for (int j = 1; j <= m; j++) {
        cin >> n;
        treehash th(n);
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            if (x == 0)
                th.rt = i;
            else
                th.add(i, x), th.add(x, i);
        }
        ll val = th.work();
        if (mp.count(val) == 0)
            mp[val] = j;
        cout << mp[val] << endl;
    }
}
\end{lstlisting}
\subsection{hashtree\_RT}
\createlinenumber{913}{302f}
\createlinenumber{914}{0dfa}
\createlinenumber{915}{3eb4}
\createlinenumber{916}{a8cb}
\createlinenumber{917}{41bd}
\createlinenumber{918}{1937}
\createlinenumber{919}{421c}
\createlinenumber{920}{c115}
\createlinenumber{921}{427e}
\createlinenumber{922}{1132}
\createlinenumber{923}{e6d9}
\createlinenumber{924}{81fe}
\createlinenumber{925}{f52b}
\createlinenumber{926}{63e5}
\createlinenumber{927}{da75}
\createlinenumber{928}{3d71}
\createlinenumber{929}{28ec}
\createlinenumber{930}{0ab4}
\createlinenumber{931}{8334}
\createlinenumber{932}{b23c}
\createlinenumber{933}{a7c7}
\createlinenumber{934}{f2e2}
\createlinenumber{935}{ab7b}
\createlinenumber{936}{fd78}
\createlinenumber{937}{afac}
\createlinenumber{938}{5c83}
\createlinenumber{939}{510f}
\createlinenumber{940}{e99c}
\createlinenumber{941}{56bd}
\createlinenumber{942}{9d4c}
\createlinenumber{943}{4991}
\createlinenumber{944}{a7d1}
\createlinenumber{945}{bd19}
\createlinenumber{946}{7524}
\createlinenumber{947}{95cf}
\createlinenumber{948}{427e}
\createlinenumber{949}{7282}
\createlinenumber{950}{02d5}
\createlinenumber{951}{2a75}
\createlinenumber{952}{95cf}
\createlinenumber{953}{3a4c}
\createlinenumber{954}{65ff}
\createlinenumber{955}{95cf}
\createlinenumber{956}{891b}
\createlinenumber{957}{49f7}
\createlinenumber{958}{e380}
\createlinenumber{959}{805a}
\createlinenumber{960}{2aa8}
\createlinenumber{961}{c221}
\createlinenumber{962}{b333}
\createlinenumber{963}{ecac}
\createlinenumber{964}{1b6f}
\createlinenumber{965}{f278}
\createlinenumber{966}{95cf}
\createlinenumber{967}{872b}
\createlinenumber{968}{427e}
\createlinenumber{969}{93e9}
\createlinenumber{970}{b9ec}
\createlinenumber{971}{adcc}
\createlinenumber{972}{f0a9}
\createlinenumber{973}{95cf}
\createlinenumber{974}{329b}
\createlinenumber{975}{cf19}
\createlinenumber{976}{87c7}
\createlinenumber{977}{2aa8}
\createlinenumber{978}{c221}
\createlinenumber{979}{b333}
\createlinenumber{980}{faed}
\createlinenumber{981}{f4ba}
\createlinenumber{982}{95cf}
\createlinenumber{983}{329b}
\createlinenumber{984}{84a7}
\createlinenumber{985}{a459}
\createlinenumber{986}{58c4}
\createlinenumber{987}{738f}
\createlinenumber{988}{b730}
\createlinenumber{989}{e7bc}
\createlinenumber{990}{0b19}
\createlinenumber{991}{eca2}
\createlinenumber{992}{95cf}
\createlinenumber{993}{3076}
\createlinenumber{994}{95cf}
\createlinenumber{995}{329b}
\createlinenumber{996}{9627}
\createlinenumber{997}{5c83}
\createlinenumber{998}{e1b6}
\createlinenumber{999}{6d45}
\createlinenumber{1000}{7300}
\createlinenumber{1001}{54f1}
\createlinenumber{1002}{a02c}
\createlinenumber{1003}{9c51}
\createlinenumber{1004}{ef6e}
\createlinenumber{1005}{95cf}
\createlinenumber{1006}{7300}
\createlinenumber{1007}{54f1}
\createlinenumber{1008}{a02c}
\createlinenumber{1009}{6c7e}
\createlinenumber{1010}{3d9b}
\createlinenumber{1011}{95cf}
\createlinenumber{1012}{c13e}
\createlinenumber{1013}{f445}
\createlinenumber{1014}{427e}
\createlinenumber{1015}{2e9a}
\createlinenumber{1016}{5c44}
\createlinenumber{1017}{649a}
\createlinenumber{1018}{0b67}
\createlinenumber{1019}{95cf}
\createlinenumber{1020}{3b32}
\createlinenumber{1021}{212b}
\createlinenumber{1022}{7618}
\createlinenumber{1023}{0dfa}
\createlinenumber{1024}{f049}
\createlinenumber{1025}{427e}
\createlinenumber{1026}{427e}
\createlinenumber{1027}{1937}
\createlinenumber{1028}{8b6f}
\createlinenumber{1029}{d9d9}
\createlinenumber{1030}{205d}
\createlinenumber{1031}{0dfa}
\createlinenumber{1032}{4208}
\createlinenumber{1033}{0369}
\createlinenumber{1034}{1937}
\createlinenumber{1035}{7021}
\createlinenumber{1036}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
#ifdef LOCAL
#include "debug.h"
#else
#define deb(...)
#endif
using namespace std;
#define ll long long
// #define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define db double
#define baoliu(x, y) cout << fixed << setprecision(y) << x
#define endl "\n"
#define alls(x) (x).begin(), (x).end()
#define fs first
#define sec second
#define bug(x) cerr << #x << " = " << x << endl
const int N = 2e5 + 10;
const int M = 1e6 + 10;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
const double eps = 1e-8;
const double PI = acos(-1.0);
struct treehash {
    int n;
    int rt = 0;         // 注意无向树的根怎么给
    vector<ll> h1, h2;  // hash的值在longlong范围内
    vector<int> siz;
    vector<vector<int>> e;
    treehash(int n_) : n(n_), h1(n_ + 1), h2(n_ + 1), siz(n_ + 1), e(n_ + 1) {}
    ll h(ll x) {
#pragma GCC diagnostic ignored "-Woverflow"
        return x * x * x * 1237123 + 19260817;
    }

    ll f(ll x) {
        ll cur = h(x & ((1 << 31) - 1)) + h(x >> 31);
        return cur;
    }
    void add(int u, int v) {
        e[u].push_back(v);
    }
    int pos = 0, pos2 = 0, ans = 1e9;
    void getroot(int u, int fa) {  // 找树的1-2重心
        siz[u] = 1;
        int mx = 0;
        for (auto v : e[u]) {
            if (v == fa)
                continue;
            getroot(v, u);
            siz[u] += siz[v];
            mx = max(mx, siz[v]);
        }
        mx = max(mx, n - siz[u]);
        // 维护了重心是pos
        if (mx < ans) {
            ans = mx, pos = u, pos2 = 0;
        } else if (mx == ans) {
            pos2 = u;
        }
    };
    void dfs1(int u, int fa, auto &h) {
        h[u] = 1;
        for (auto v : e[u]) {
            if (v == fa)
                continue;
            dfs1(v, u, h);
            h[u] += f(h[v]);
        }
    };
    ll work() {  // 无根树先找重心
        getroot(rt, 0);
        dfs1(pos, 0, h1);
        if (pos2)
            dfs1(pos2, 0, h2);
        ll val = h1[pos];
        if (pos2) {
            val = max(val, h2[pos2]);
        }
        return val;
    }
};
void solve() {
    int n;
    cin >> n;
    treehash h1(n), h2(n);
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        h1.add(u, v);
        h1.add(v, u);
    }
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        h2.add(u, v);
        h2.add(v, u);
    }
    h1.dfs1(1, 0, h1.h1);
    h2.dfs1(1, 0, h2.h1);

    if (h1.h1[1] == h2.h1[1])
        cout << "Isomorphism" << endl;
    else
        cout << "No" << endl;
}
signed main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
#ifdef LOCAL
    double starttime = clock();
    // freopen("in.txt", "r", stdin);
    // freopen("out.txt", "w", stdout);
#endif
    int t = 1;
    cin >> t;
    while (t--) solve();
#ifdef LOCAL
    double endtime = clock();
    cerr << "Time Used: " << (double)(endtime - starttime) / CLOCKS_PER_SEC * 1000 << " ms" << endl;
#endif
    return 0;
}
\end{lstlisting}
\subsection{k\_ancestor\_O(1)}
\createlinenumber{1037}{9627}
\createlinenumber{1038}{1ed7}
\createlinenumber{1039}{9c97}
\createlinenumber{1040}{510f}
\createlinenumber{1041}{7a04}
\createlinenumber{1042}{bf80}
\createlinenumber{1043}{e28e}
\createlinenumber{1044}{2c38}
\createlinenumber{1045}{4f61}
\createlinenumber{1046}{6dbf}
\createlinenumber{1047}{3c9e}
\createlinenumber{1048}{3398}
\createlinenumber{1049}{5ea8}
\createlinenumber{1050}{cf39}
\createlinenumber{1051}{b333}
\createlinenumber{1052}{95cf}
\createlinenumber{1053}{4ae7}
\createlinenumber{1054}{95cf}
\createlinenumber{1055}{2d2e}
\createlinenumber{1056}{efd4}
\createlinenumber{1057}{cf92}
\createlinenumber{1058}{2aa8}
\createlinenumber{1059}{bac1}
\createlinenumber{1060}{6d47}
\createlinenumber{1061}{18f1}
\createlinenumber{1062}{c326}
\createlinenumber{1063}{db8e}
\createlinenumber{1064}{95cf}
\createlinenumber{1065}{95cf}
\createlinenumber{1066}{329b}
\createlinenumber{1067}{9b40}
\createlinenumber{1068}{a577}
\createlinenumber{1069}{386f}
\createlinenumber{1070}{6130}
\createlinenumber{1071}{2229}
\createlinenumber{1072}{2088}
\createlinenumber{1073}{2aa8}
\createlinenumber{1074}{d005}
\createlinenumber{1075}{b333}
\createlinenumber{1076}{59d2}
\createlinenumber{1077}{95cf}
\createlinenumber{1078}{80cd}
\createlinenumber{1079}{329b}
\createlinenumber{1080}{7546}
\createlinenumber{1081}{5270}
\createlinenumber{1082}{d441}
\createlinenumber{1083}{b786}
\createlinenumber{1084}{2aac}
\createlinenumber{1085}{c663}
\createlinenumber{1086}{8ffb}
\createlinenumber{1087}{9698}
\createlinenumber{1088}{d62a}
\createlinenumber{1089}{c385}
\createlinenumber{1090}{95cf}
\createlinenumber{1091}{95cf}
\createlinenumber{1092}{172d}
\createlinenumber{1093}{2901}
\createlinenumber{1094}{2464}
\createlinenumber{1095}{5c86}
\createlinenumber{1096}{710c}
\createlinenumber{1097}{b7c4}
\createlinenumber{1098}{95cf}
\createlinenumber{1099}{95cf}
\createlinenumber{1100}{329b}
\createlinenumber{1101}{6428}
\createlinenumber{1102}{cb8b}
\createlinenumber{1103}{e149}
\createlinenumber{1104}{178f}
\createlinenumber{1105}{bf33}
\createlinenumber{1106}{427e}
\createlinenumber{1107}{e11c}
\createlinenumber{1108}{f6dd}
\createlinenumber{1109}{650e}
\createlinenumber{1110}{649a}
\createlinenumber{1111}{149e}
\createlinenumber{1112}{329b}
\createlinenumber{1113}{427e}
\createlinenumber{1114}{949d}
\createlinenumber{1115}{5c0a}
\createlinenumber{1116}{da6b}
\createlinenumber{1117}{ec94}
\createlinenumber{1118}{b830}
\createlinenumber{1119}{95cf}
\createlinenumber{1120}{95cf}
\createlinenumber{1121}{427e}
\begin{lstlisting}[language=C++]
void solve() {
    int n, q;
    cin >> n >> q;
    int rt = 0;
    vector<int> l(n + 1), r(n + 1), node(n + 1);
    int idx = 0;
    vector<int> fa(n + 1), dep(n + 1);
    vector<int> hson(n + 1), top(n + 1), len(n + 1);
    vector<vector<int>> e(n + 1);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        if (x == 0) {
            rt = i;
            continue;
        }
        e[x].push_back(i);
    }
    auto dfs1 = [&](auto self, int u, int curd = 1) -> void {
        dep[u] = curd;
        len[u] = 1;
        for (auto v : e[u]) {
            fa[v] = u;
            self(self, v, curd + 1);
            if (len[v] + 1 > len[u]) {
                hson[u] = v;
                len[u] = len[v] + 1;
            }
        }
    };
    auto dfs2 = [&](auto self, int u, int tp) -> void {
        l[u] = ++idx;
        node[idx] = u;
        top[u] = tp;
        if (hson[u])
            self(self, hson[u], tp);
        for (auto v : e[u]) {
            if (top[v])
                continue;
            self(self, v, v);
        }
        r[u] = idx;
    };
    int bei = __lg(n);
    vector<vector<int>> st(bei + 1, vector<int>(n + 1));
    vector<vector<int>> anc(n + 1), des(n + 1);
    auto work = [&](int rt) {
        dfs1(dfs1, rt);
        dfs2(dfs2, rt, rt);
        for (int i = 1; i <= n; i++) st[0][i] = fa[i];
        for (int i = 1; i <= bei; ++i) {
            for (int j = 1; j <= n; ++j) {
                st[i][j] = st[i - 1][st[i - 1][j]];
            }
        }
        for (int i = 1; i <= n; ++i) {
            if (top[i] == i) {
                for (int j = 0, p = i; j < len[i]; ++j, p = fa[p])
                    anc[i].push_back(p);
                for (int j = 0; j < len[i]; ++j)
                    des[i].push_back(node[l[i] + j]);
            }
        }
    };
    auto query = [&](int p, int k) {
        if (k == 0)
            return p;  // 特判
        int i = __lg(k), q = st[i][p];
        int tp = top[q];
        // q的k-(1<<i)级祖先小于链长，预处理了两倍链长的信息
        int d = k - (1 << i) - (dep[q] - dep[tp]);
        if (d > 0)
            return anc[tp][d];
        else
            return des[tp][-d];
    };

    for (int i = 1; i <= q; i++) {
        int x, k;
        cin >> x >> k;
        int res = query(x, k);
        cout << res << endl;
    }
}

\end{lstlisting}
\subsection{segtree}
\createlinenumber{1122}{436d}
\createlinenumber{1123}{d244}
\createlinenumber{1124}{4cfc}
\createlinenumber{1125}{7d4e}
\createlinenumber{1126}{5c83}
\createlinenumber{1127}{5799}
\createlinenumber{1128}{fc3e}
\createlinenumber{1129}{9b4f}
\createlinenumber{1130}{5fee}
\createlinenumber{1131}{2f1b}
\createlinenumber{1132}{4506}
\createlinenumber{1133}{eba1}
\createlinenumber{1134}{0c3d}
\createlinenumber{1135}{2d4b}
\createlinenumber{1136}{3a0d}
\createlinenumber{1137}{df55}
\createlinenumber{1138}{4f2d}
\createlinenumber{1139}{95cf}
\createlinenumber{1140}{bfe3}
\createlinenumber{1141}{0529}
\createlinenumber{1142}{8dfd}
\createlinenumber{1143}{9a13}
\createlinenumber{1144}{329b}
\createlinenumber{1145}{58a3}
\createlinenumber{1146}{95cf}
\createlinenumber{1147}{d10f}
\createlinenumber{1148}{8d27}
\createlinenumber{1149}{3a0d}
\createlinenumber{1150}{59ea}
\createlinenumber{1151}{4f2d}
\createlinenumber{1152}{95cf}
\createlinenumber{1153}{bfe3}
\createlinenumber{1154}{0567}
\createlinenumber{1155}{754c}
\createlinenumber{1156}{649a}
\createlinenumber{1157}{462b}
\createlinenumber{1158}{9a13}
\createlinenumber{1159}{95cf}
\createlinenumber{1160}{fb88}
\createlinenumber{1161}{9b17}
\createlinenumber{1162}{26ed}
\createlinenumber{1163}{65b6}
\createlinenumber{1164}{e821}
\createlinenumber{1165}{00d1}
\createlinenumber{1166}{bfe3}
\createlinenumber{1167}{38d4}
\createlinenumber{1168}{8797}
\createlinenumber{1169}{95cf}
\createlinenumber{1170}{bd00}
\createlinenumber{1171}{136b}
\createlinenumber{1172}{f328}
\createlinenumber{1173}{4b2a}
\createlinenumber{1174}{fb5e}
\createlinenumber{1175}{65bd}
\createlinenumber{1176}{2987}
\createlinenumber{1177}{bfe3}
\createlinenumber{1178}{80c5}
\createlinenumber{1179}{233f}
\createlinenumber{1180}{3740}
\createlinenumber{1181}{244d}
\createlinenumber{1182}{95cf}
\createlinenumber{1183}{136b}
\createlinenumber{1184}{998f}
\createlinenumber{1185}{4d76}
\createlinenumber{1186}{95cf}
\createlinenumber{1187}{136b}
\createlinenumber{1188}{a5ea}
\createlinenumber{1189}{4b2a}
\createlinenumber{1190}{fb5e}
\createlinenumber{1191}{65bd}
\createlinenumber{1192}{2987}
\createlinenumber{1193}{bfe3}
\createlinenumber{1194}{2572}
\createlinenumber{1195}{233f}
\createlinenumber{1196}{63b8}
\createlinenumber{1197}{244d}
\createlinenumber{1198}{95cf}
\createlinenumber{1199}{136b}
\createlinenumber{1200}{f61f}
\createlinenumber{1201}{1c8e}
\createlinenumber{1202}{95cf}
\createlinenumber{1203}{329b}
\createlinenumber{1204}{0dba}
\createlinenumber{1205}{c078}
\createlinenumber{1206}{329b}
\createlinenumber{1207}{303f}
\createlinenumber{1208}{3d15}
\createlinenumber{1209}{f429}
\createlinenumber{1210}{26e9}
\createlinenumber{1211}{14df}
\createlinenumber{1212}{329b}
\begin{lstlisting}[language=C++]
template <class Info>
struct Segtree {
#define ls(x) x << 1
#define rs(x) (x << 1) | 1
    int n;
    vector<Info> info;
    Segtree() : n(0) {}
    Segtree(int n_, Info v_ = Info()) { init(vector<Info>(n_ + 1, v_)); }
    Segtree(vector<Info> t_) { init(t_); }
    void init(vector<Info> a)  //[1,n]
    {
        n = a.size() - 1;
        info.assign((n << 2) + 1, Info());
        function<void(int, int, int)> build = [&](int x, int l, int r) -> void {
            if (l == r) {
                info[x] = a[l];
                return;
            }
            int mid = (l + r) >> 1;
            build(ls(x), l, mid);
            1 build(rs(x), mid + 1, r);
            pushup(x);
        };
        build(1, 1, n);
    }
    void pushup(int x) { info[x] = info[ls(x)] + info[rs(x)]; }
    void update(int x, int l, int r, int p, const Info& v) {
        if (l == r) {
            info[x] = v;
            return;
        }
        int mid = (l + r) >> 1;
        if (p <= mid)
            update(ls(x), l, mid, p, v);
        else
            update(rs(x), mid + 1, r, p, v);
        pushup(x);
    }
    void update(int p, const Info& v) { update(1, 1, n, p, v); }
    Info query(int x, int l, int r, int ql, int qr) {
        if (l > qr || r < ql)
            return Info();
        if (ql <= l && r <= qr)
            return info[x];
        int mid = (l + r) >> 1;
        return query(ls(x), l, mid, ql, qr) +
               query(rs(x), mid + 1, r, ql, qr);
    }
    Info query(int ql, int qr) { return query(1, 1, n, ql, qr); }
    template <class F>
    int findFirst(int x, int l, int r, int ql, int qr, F pred) {
        if (l > qr || r < ql || !pred(info[x]))
            return -1;
        if (l == r)
            return l;
        int mid = (l + r) >> 1;
        int res = findFirst(x << 1, l, mid, ql, qr, pred);
        if (res == -1)
            res = findFirst(x << 1 | 1, mid + 1, r, ql, qr, pred);
        return res;
    }
    template <class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 1, n, l, r, pred);
    }
    template <class F>
    int findLast(int x, int l, int r, int ql, int qr, F pred) {
        if (l > qr || r < ql || !pred(info[x]))
            return -1;
        if (l == r)
            return l;
        int mid = (l + r) >> 1;
        int res = findLast(x << 1 | 1, mid + 1, r, ql, qr, pred);
        if (res == -1)
            res = findLast(x << 1, l, mid, ql, qr, pred);
        return res;
    }
    template <class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 1, n, l, r, pred);
    }
};
struct Info {
    ll sum = 0, len = 1;
};
Info operator+(const Info& a, const Info& b) {  // 维护的信息怎么合并
    Info c = Info();
    c.sum = a.sum + b.sum;
    c.len = a.len + b.len;
    return c;
};
\end{lstlisting}
\subsection{segtree\_ps}
\createlinenumber{1213}{436d}
\createlinenumber{1214}{b003}
\createlinenumber{1215}{80b8}
\createlinenumber{1216}{6f26}
\createlinenumber{1217}{a9a1}
\createlinenumber{1218}{f35b}
\createlinenumber{1219}{329b}
\createlinenumber{1220}{5c83}
\createlinenumber{1221}{2eb3}
\createlinenumber{1222}{6ba8}
\createlinenumber{1223}{d34f}
\createlinenumber{1224}{b985}
\createlinenumber{1225}{721d}
\createlinenumber{1226}{95cf}
\createlinenumber{1227}{05c4}
\createlinenumber{1228}{35c2}
\createlinenumber{1229}{c105}
\createlinenumber{1230}{95cf}
\createlinenumber{1231}{35da}
\createlinenumber{1232}{e7d6}
\createlinenumber{1233}{c82e}
\createlinenumber{1234}{9c79}
\createlinenumber{1235}{10c4}
\createlinenumber{1236}{3016}
\createlinenumber{1237}{95cf}
\createlinenumber{1238}{c810}
\createlinenumber{1239}{5380}
\createlinenumber{1240}{eea4}
\createlinenumber{1241}{8e2e}
\createlinenumber{1242}{533d}
\createlinenumber{1243}{95cf}
\createlinenumber{1244}{3016}
\createlinenumber{1245}{95cf}
\createlinenumber{1246}{156f}
\createlinenumber{1247}{03fa}
\createlinenumber{1248}{10c4}
\createlinenumber{1249}{ad68}
\createlinenumber{1250}{95cf}
\createlinenumber{1251}{c810}
\createlinenumber{1252}{5380}
\createlinenumber{1253}{1163}
\createlinenumber{1254}{8e2e}
\createlinenumber{1255}{a954}
\createlinenumber{1256}{95cf}
\createlinenumber{1257}{95cf}
\createlinenumber{1258}{40d0}
\createlinenumber{1259}{a3a3}
\createlinenumber{1260}{0411}
\createlinenumber{1261}{65b6}
\createlinenumber{1262}{95cf}
\createlinenumber{1263}{3c2c}
\createlinenumber{1264}{ad68}
\createlinenumber{1265}{95cf}
\createlinenumber{1266}{c810}
\createlinenumber{1267}{347f}
\createlinenumber{1268}{95cf}
\createlinenumber{1269}{b083}
\createlinenumber{1270}{329b}
\createlinenumber{1271}{427e}
\createlinenumber{1272}{0dba}
\createlinenumber{1273}{3c9e}
\createlinenumber{1274}{6465}
\createlinenumber{1275}{436a}
\createlinenumber{1276}{329b}
\createlinenumber{1277}{5b40}
\createlinenumber{1278}{0963}
\createlinenumber{1279}{2b20}
\createlinenumber{1280}{244d}
\createlinenumber{1281}{95cf}
\createlinenumber{1282}{5798}
\createlinenumber{1283}{0963}
\createlinenumber{1284}{1511}
\createlinenumber{1285}{244d}
\createlinenumber{1286}{95cf}
\begin{lstlisting}[language=C++]
template <class Info>
struct Segment {
    struct Node {
        int left, right;
        Info info;
        Node() : left{0}, right{0}, info{} {}
    };
    int n;
    vector<Node> t;
    Segment(int n = 0) { init(n); }
    void init(int n) {
        this->n = n;
        t.assign(1, {});
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int modify(int prev, int l, int r, int x, const Info &v) {
        int curr = newNode();
        t[curr] = t[prev];
        t[curr].info.apply(v);
        if (r - l == 1) {
            return curr;
        }
        int m = (l + r) / 2;
        if (x < m) {
            t[curr].left = modify(t[prev].left, l, m, x, v);
        } else {
            t[curr].right = modify(t[prev].right, m, r, x, v);
        }
        return curr;
    }
    int modify(int prev, int x, const Info &v) { return modify(prev, 0, n, x, v); }
    Info query(int L, int R, int l, int r, int x) {
        if (r - l == 1) {
            return t[R].info - t[L].info;
        }
        int m = (l + r) / 2;
        if (x < m) {
            return query(t[L].left, t[R].left, l, m, x);
        } else {
            return query(t[L].right, t[R].right, m, r, x);
        }
    }
    Info query(int L, int R, int x) { return query(L, R, 0, n, x); }
    Info rangeQuery(int L, int R, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return t[R].info - t[L].info;
        }
        int m = (l + r) / 2;
        return rangeQuery(t[L].left, t[R].left, l, m, x, y) + rangeQuery(t[L].right, t[R].right, m, r, x, y);
    }
    Info rangeQuery(int L, int R, int l, int r) { return rangeQuery(L, R, 0, n, l, r); }
};

struct Info {
    int x;
    Info(int x = 0) : x{x} {}
    void apply(const Info &v) { x += v.x; }
};
Info operator+(Info lhs, Info rhs) {
    Info res = lhs;
    res.x += rhs.x;
    return res;
}
Info operator-(Info lhs, Info rhs) {
    Info res = lhs;
    res.x -= rhs.x;
    return res;
}
\end{lstlisting}
\subsection{segtreelazy0base}
\createlinenumber{1287}{9a27}
\createlinenumber{1288}{bf53}
\createlinenumber{1289}{5c83}
\createlinenumber{1290}{abed}
\createlinenumber{1291}{1d1b}
\createlinenumber{1292}{5710}
\createlinenumber{1293}{cc61}
\createlinenumber{1294}{839b}
\createlinenumber{1295}{95cf}
\createlinenumber{1296}{0c7b}
\createlinenumber{1297}{e64e}
\createlinenumber{1298}{d0e9}
\createlinenumber{1299}{95cf}
\createlinenumber{1300}{91c0}
\createlinenumber{1301}{0f5d}
\createlinenumber{1302}{95cf}
\createlinenumber{1303}{0c7b}
\createlinenumber{1304}{6e64}
\createlinenumber{1305}{2e7e}
\createlinenumber{1306}{0bae}
\createlinenumber{1307}{a729}
\createlinenumber{1308}{0764}
\createlinenumber{1309}{10c4}
\createlinenumber{1310}{1a37}
\createlinenumber{1311}{4f2d}
\createlinenumber{1312}{95cf}
\createlinenumber{1313}{c810}
\createlinenumber{1314}{5416}
\createlinenumber{1315}{e2d5}
\createlinenumber{1316}{3726}
\createlinenumber{1317}{329b}
\createlinenumber{1318}{a068}
\createlinenumber{1319}{95cf}
\createlinenumber{1320}{c98b}
\createlinenumber{1321}{8f70}
\createlinenumber{1322}{95cf}
\createlinenumber{1323}{1129}
\createlinenumber{1324}{06ed}
\createlinenumber{1325}{c297}
\createlinenumber{1326}{95cf}
\createlinenumber{1327}{30db}
\createlinenumber{1328}{6aaf}
\createlinenumber{1329}{80dc}
\createlinenumber{1330}{9d88}
\createlinenumber{1331}{95cf}
\createlinenumber{1332}{6cda}
\createlinenumber{1333}{10c4}
\createlinenumber{1334}{9e27}
\createlinenumber{1335}{4f2d}
\createlinenumber{1336}{95cf}
\createlinenumber{1337}{c810}
\createlinenumber{1338}{1275}
\createlinenumber{1339}{5380}
\createlinenumber{1340}{c73e}
\createlinenumber{1341}{8e2e}
\createlinenumber{1342}{e4ce}
\createlinenumber{1343}{95cf}
\createlinenumber{1344}{3726}
\createlinenumber{1345}{95cf}
\createlinenumber{1346}{8d00}
\createlinenumber{1347}{45e4}
\createlinenumber{1348}{95cf}
\createlinenumber{1349}{1bb7}
\createlinenumber{1350}{0411}
\createlinenumber{1351}{65b6}
\createlinenumber{1352}{95cf}
\createlinenumber{1353}{3c2c}
\createlinenumber{1354}{b5ee}
\createlinenumber{1355}{95cf}
\createlinenumber{1356}{c810}
\createlinenumber{1357}{1275}
\createlinenumber{1358}{1fb2}
\createlinenumber{1359}{95cf}
\createlinenumber{1360}{3be8}
\createlinenumber{1361}{5277}
\createlinenumber{1362}{95cf}
\createlinenumber{1363}{b746}
\createlinenumber{1364}{0411}
\createlinenumber{1365}{4f2d}
\createlinenumber{1366}{95cf}
\createlinenumber{1367}{3c2c}
\createlinenumber{1368}{513f}
\createlinenumber{1369}{4f2d}
\createlinenumber{1370}{95cf}
\createlinenumber{1371}{c810}
\createlinenumber{1372}{1275}
\createlinenumber{1373}{2be4}
\createlinenumber{1374}{b0db}
\createlinenumber{1375}{3726}
\createlinenumber{1376}{95cf}
\createlinenumber{1377}{c036}
\createlinenumber{1378}{9903}
\createlinenumber{1379}{95cf}
\createlinenumber{1380}{136b}
\createlinenumber{1381}{fb91}
\createlinenumber{1382}{23c7}
\createlinenumber{1383}{fb5e}
\createlinenumber{1384}{95cf}
\createlinenumber{1385}{10c4}
\createlinenumber{1386}{2987}
\createlinenumber{1387}{95cf}
\createlinenumber{1388}{c810}
\createlinenumber{1389}{1275}
\createlinenumber{1390}{fbfb}
\createlinenumber{1391}{13e7}
\createlinenumber{1392}{371a}
\createlinenumber{1393}{95cf}
\createlinenumber{1394}{244d}
\createlinenumber{1395}{95cf}
\createlinenumber{1396}{136b}
\createlinenumber{1397}{998f}
\createlinenumber{1398}{799a}
\createlinenumber{1399}{95cf}
\createlinenumber{1400}{136b}
\createlinenumber{1401}{2a26}
\createlinenumber{1402}{23c7}
\createlinenumber{1403}{fb5e}
\createlinenumber{1404}{95cf}
\createlinenumber{1405}{10c4}
\createlinenumber{1406}{2987}
\createlinenumber{1407}{95cf}
\createlinenumber{1408}{c810}
\createlinenumber{1409}{1275}
\createlinenumber{1410}{bc38}
\createlinenumber{1411}{13e7}
\createlinenumber{1412}{9675}
\createlinenumber{1413}{95cf}
\createlinenumber{1414}{244d}
\createlinenumber{1415}{95cf}
\createlinenumber{1416}{136b}
\createlinenumber{1417}{f61f}
\createlinenumber{1418}{dda5}
\createlinenumber{1419}{95cf}
\createlinenumber{1420}{329b}
\createlinenumber{1421}{427e}
\createlinenumber{1422}{efd7}
\createlinenumber{1423}{7812}
\createlinenumber{1424}{e9e8}
\createlinenumber{1425}{673d}
\createlinenumber{1426}{b5d1}
\createlinenumber{1427}{95cf}
\createlinenumber{1428}{329b}
\createlinenumber{1429}{427e}
\createlinenumber{1430}{28e7}
\createlinenumber{1431}{427e}
\createlinenumber{1432}{0dba}
\createlinenumber{1433}{411b}
\createlinenumber{1434}{e9e8}
\createlinenumber{1435}{7c3a}
\createlinenumber{1436}{d078}
\createlinenumber{1437}{9f5f}
\createlinenumber{1438}{95cf}
\createlinenumber{1439}{8042}
\createlinenumber{1440}{95cf}
\createlinenumber{1441}{329b}
\createlinenumber{1442}{0814}
\createlinenumber{1443}{30ad}
\createlinenumber{1444}{95cf}
\createlinenumber{1445}{427e}
\begin{lstlisting}[language=C++]
template<class Info, class Tag>
struct LazySegmentTree {
    int n;
    std::vector<Info> info;
    std::vector<Tag> tag;
    LazySegmentTree() : n(0) {}
    LazySegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    LazySegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {
        init(std::vector(n_, v_));
    }
    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(4 << std::__lg(n), Info());
        tag.assign(4 << std::__lg(n), Tag());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void apply(int p, const Tag &v) {
        info[p].apply(v);
        tag[p].apply(v);
    }
    void push(int p) {
        apply(2 * p, tag[p]);
        apply(2 * p + 1, tag[p]);
        tag[p] = Tag();
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        push(p);
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        push(p);
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n, l, r);
    }
    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {
        if (l >= y || r <= x) {
            return;
        }
        if (l >= x && r <= y) {
            apply(p, v);
            return;
        }
        int m = (l + r) / 2;
        push(p);
        rangeApply(2 * p, l, m, x, y, v);
        rangeApply(2 * p + 1, m, r, x, y, v);
        pull(p);
    }
    void rangeApply(int l, int r, const Tag &v) {
        return rangeApply(1, 0, n, l, r, v);
    }
    template<class F>
    int findFirst(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        push(p);
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 0, n, l, r, pred);
    }
    template<class F>
    int findLast(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        push(p);
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 0, n, l, r, pred);
    }
};

struct Tag {
    i64 a = 0, b = 0;
    void apply(Tag t) {
        a = std::min(a, b + t.a);
        b += t.b;
    }
};

int k;

struct Info {
    i64 x = 0;
    void apply(Tag t) {
        x += t.a;
        if (x < 0) {
            x = (x % k + k) % k;
        }
        x += t.b - t.a;
    }
};
Info operator+(Info a, Info b) {
    return {a.x + b.x};
}

\end{lstlisting}
\subsection{segtreelazy1base}
\createlinenumber{1446}{9a27}
\createlinenumber{1447}{bf53}
\createlinenumber{1448}{5c83}
\createlinenumber{1449}{5799}
\createlinenumber{1450}{e181}
\createlinenumber{1451}{5710}
\createlinenumber{1452}{c0c4}
\createlinenumber{1453}{219b}
\createlinenumber{1454}{2f1b}
\createlinenumber{1455}{4506}
\createlinenumber{1456}{eba1}
\createlinenumber{1457}{0c3d}
\createlinenumber{1458}{8131}
\createlinenumber{1459}{2d4b}
\createlinenumber{1460}{3a0d}
\createlinenumber{1461}{df55}
\createlinenumber{1462}{4f2d}
\createlinenumber{1463}{95cf}
\createlinenumber{1464}{b8b7}
\createlinenumber{1465}{6d9d}
\createlinenumber{1466}{b5a9}
\createlinenumber{1467}{9a13}
\createlinenumber{1468}{329b}
\createlinenumber{1469}{58a3}
\createlinenumber{1470}{95cf}
\createlinenumber{1471}{e151}
\createlinenumber{1472}{1129}
\createlinenumber{1473}{06ed}
\createlinenumber{1474}{c297}
\createlinenumber{1475}{95cf}
\createlinenumber{1476}{129a}
\createlinenumber{1477}{5317}
\createlinenumber{1478}{f100}
\createlinenumber{1479}{3a9a}
\createlinenumber{1480}{95cf}
\createlinenumber{1481}{8d27}
\createlinenumber{1482}{3a0d}
\createlinenumber{1483}{59ea}
\createlinenumber{1484}{4f2d}
\createlinenumber{1485}{95cf}
\createlinenumber{1486}{b8b7}
\createlinenumber{1487}{4e14}
\createlinenumber{1488}{0567}
\createlinenumber{1489}{3535}
\createlinenumber{1490}{649a}
\createlinenumber{1491}{5aa5}
\createlinenumber{1492}{9a13}
\createlinenumber{1493}{95cf}
\createlinenumber{1494}{fb88}
\createlinenumber{1495}{9b17}
\createlinenumber{1496}{26ed}
\createlinenumber{1497}{65b6}
\createlinenumber{1498}{e821}
\createlinenumber{1499}{00d1}
\createlinenumber{1500}{b8b7}
\createlinenumber{1501}{4e14}
\createlinenumber{1502}{6fb4}
\createlinenumber{1503}{c27e}
\createlinenumber{1504}{95cf}
\createlinenumber{1505}{bd00}
\createlinenumber{1506}{889e}
\createlinenumber{1507}{26ed}
\createlinenumber{1508}{4f2d}
\createlinenumber{1509}{bfef}
\createlinenumber{1510}{fe33}
\createlinenumber{1511}{4f2d}
\createlinenumber{1512}{95cf}
\createlinenumber{1513}{b8b7}
\createlinenumber{1514}{4e14}
\createlinenumber{1515}{acb0}
\createlinenumber{1516}{f758}
\createlinenumber{1517}{9a13}
\createlinenumber{1518}{95cf}
\createlinenumber{1519}{a1c9}
\createlinenumber{1520}{ef69}
\createlinenumber{1521}{95cf}
\createlinenumber{1522}{136b}
\createlinenumber{1523}{f328}
\createlinenumber{1524}{4b2a}
\createlinenumber{1525}{fb5e}
\createlinenumber{1526}{65bd}
\createlinenumber{1527}{2987}
\createlinenumber{1528}{b8b7}
\createlinenumber{1529}{4e14}
\createlinenumber{1530}{80c5}
\createlinenumber{1531}{233f}
\createlinenumber{1532}{3740}
\createlinenumber{1533}{244d}
\createlinenumber{1534}{95cf}
\createlinenumber{1535}{136b}
\createlinenumber{1536}{998f}
\createlinenumber{1537}{4d76}
\createlinenumber{1538}{95cf}
\createlinenumber{1539}{136b}
\createlinenumber{1540}{a5ea}
\createlinenumber{1541}{4b2a}
\createlinenumber{1542}{fb5e}
\createlinenumber{1543}{65bd}
\createlinenumber{1544}{2987}
\createlinenumber{1545}{b8b7}
\createlinenumber{1546}{4e14}
\createlinenumber{1547}{2572}
\createlinenumber{1548}{233f}
\createlinenumber{1549}{63b8}
\createlinenumber{1550}{244d}
\createlinenumber{1551}{95cf}
\createlinenumber{1552}{136b}
\createlinenumber{1553}{f61f}
\createlinenumber{1554}{1c8e}
\createlinenumber{1555}{95cf}
\createlinenumber{1556}{329b}
\createlinenumber{1557}{efd7}
\createlinenumber{1558}{e8b5}
\createlinenumber{1559}{ebc8}
\createlinenumber{1560}{329b}
\createlinenumber{1561}{0dba}
\createlinenumber{1562}{c078}
\createlinenumber{1563}{0e06}
\createlinenumber{1564}{329b}
\createlinenumber{1565}{303f}
\createlinenumber{1566}{3d15}
\createlinenumber{1567}{f429}
\createlinenumber{1568}{26e9}
\createlinenumber{1569}{14df}
\createlinenumber{1570}{95cf}
\begin{lstlisting}[language=C++]
template <class Info, class Tag>
struct LazySegmentTree {
    int n;
    vector<Info> info;
    vector<Tag> tag;
    LazySegmentTree() : n(0) {}
    LazySegmentTree(int n_, Info v_ = Info()) { init(vector<Info>(n_ + 1, v_)); }
    LazySegmentTree(vector<Info> t_) { init(t_); }
    void init(vector<Info> a)  //[1,n]
    {
        n = a.size() - 1;
        info.assign((n << 2) + 1, Info());
        tag.assign((n << 2) + 1, Tag());
        function<void(int, int, int)> build = [&](int x, int l, int r) -> void {
            if (l == r) {
                info[x] = a[l];
                return;
            }
            int mid = l + r >> 1;
            build(x << 1, l, mid);
            build(x << 1 | 1, mid + 1, r);
            pushup(x);
        };
        build(1, 1, n);
    }
    void pushup(int x) { info[x] = info[x << 1] + info[x << 1 | 1]; }
    void apply(int p, const Tag& v) {
        info[p].apply(v);  // 标记更新自己
        tag[p].apply(v);   // 下传标记
    }
    void pushdown(int x) {
        apply(x << 1, tag[x]);
        apply(x << 1 | 1, tag[x]);
        tag[x] = Tag();
    }
    void update(int x, int l, int r, int p, const Info& v) {
        if (l == r) {
            info[x] = v;
            return;
        }
        int mid = l + r >> 1;
        pushdown(x);
        if (p <= mid)
            update(x << 1, l, mid, p, v);
        else
            update(x << 1 | 1, mid + 1, r, p, v);
        pushup(x);
    }
    void update(int p, const Info& v) { update(1, 1, n, p, v); }
    Info query(int x, int l, int r, int ql, int qr) {
        if (l > qr || r < ql)
            return Info();
        if (ql <= l && r <= qr)
            return info[x];
        int mid = l + r >> 1;
        pushdown(x);
        return query(x << 1, l, mid, ql, qr) +
               query(x << 1 | 1, mid + 1, r, ql, qr);
    }
    Info query(int ql, int qr) { return query(1, 1, n, ql, qr); }
    void rangeupdate(int x, int l, int r, int ql, int qr, const Tag& v) {
        if (l > qr || r < ql)
            return;
        if (ql <= l && r <= qr) {
            apply(x, v);
            return;
        }
        int mid = l + r >> 1;
        pushdown(x);
        rangeupdate(x << 1, l, mid, ql, qr, v);
        rangeupdate(x << 1 | 1, mid + 1, r, ql, qr, v);
        pushup(x);
    }
    void rangeupdate(int ql, int qr, const Tag& v) {
        rangeupdate(1, 1, n, ql, qr, v);
    }
    template <class F>
    int findFirst(int x, int l, int r, int ql, int qr, F pred) {
        if (l > qr || r < ql || !pred(info[x]))
            return -1;
        if (l == r)
            return l;
        int mid = l + r >> 1;
        pushdown(x);
        int res = findFirst(x << 1, l, mid, ql, qr, pred);
        if (res == -1)
            res = findFirst(x << 1 | 1, mid + 1, r, ql, qr, pred);
        return res;
    }
    template <class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 1, n, l, r, pred);
    }
    template <class F>
    int findLast(int x, int l, int r, int ql, int qr, F pred) {
        if (l > qr || r < ql || !pred(info[x]))
            return -1;
        if (l == r)
            return l;
        int mid = l + r >> 1;
        pushdown(x);
        int res = findLast(x << 1 | 1, mid + 1, r, ql, qr, pred);
        if (res == -1)
            res = findLast(x << 1, l, mid, ql, qr, pred);
        return res;
    }
    template <class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 1, n, l, r, pred);
    }
};
struct Tag {
    ll add = 0;
    void apply(const Tag& v) { add += v.add; }  // 标记怎么合并
};
struct Info {
    ll sum = 0, len = 1;
    void apply(const Tag& v) { sum += len * v.add; }  // 标记怎么更新节点信息
};
Info operator+(const Info& a, const Info& b) {  // 维护的信息怎么合并
    Info c = Info();
    c.sum = a.sum + b.sum;
    c.len = a.len + b.len;
    return c;
}
\end{lstlisting}
\subsection{segtreelazy\_xkm}
\createlinenumber{1571}{dd28}
\createlinenumber{1572}{207d}
\createlinenumber{1573}{f52b}
\createlinenumber{1574}{9b41}
\createlinenumber{1575}{b4cf}
\createlinenumber{1576}{ff30}
\createlinenumber{1577}{65bd}
\createlinenumber{1578}{4f2d}
\createlinenumber{1579}{bfe3}
\createlinenumber{1580}{4781}
\createlinenumber{1581}{7895}
\createlinenumber{1582}{95cf}
\createlinenumber{1583}{b7ec}
\createlinenumber{1584}{07b5}
\createlinenumber{1585}{3a0d}
\createlinenumber{1586}{0287}
\createlinenumber{1587}{4f2d}
\createlinenumber{1588}{95cf}
\createlinenumber{1589}{bfe3}
\createlinenumber{1590}{c578}
\createlinenumber{1591}{7895}
\createlinenumber{1592}{95cf}
\createlinenumber{1593}{5716}
\createlinenumber{1594}{b609}
\createlinenumber{1595}{4f2d}
\createlinenumber{1596}{b9f0}
\createlinenumber{1597}{cccf}
\createlinenumber{1598}{abe2}
\createlinenumber{1599}{2421}
\createlinenumber{1600}{46f1}
\createlinenumber{1601}{95cf}
\createlinenumber{1602}{65a3}
\createlinenumber{1603}{bfbe}
\createlinenumber{1604}{8abe}
\createlinenumber{1605}{1be3}
\createlinenumber{1606}{4f2d}
\createlinenumber{1607}{95cf}
\createlinenumber{1608}{47da}
\createlinenumber{1609}{bfe3}
\createlinenumber{1610}{53f6}
\createlinenumber{1611}{f10b}
\createlinenumber{1612}{d699}
\createlinenumber{1613}{fbb5}
\createlinenumber{1614}{7895}
\createlinenumber{1615}{95cf}
\createlinenumber{1616}{c2b9}
\createlinenumber{1617}{603f}
\createlinenumber{1618}{5b9b}
\createlinenumber{1619}{47da}
\createlinenumber{1620}{bfe3}
\createlinenumber{1621}{0b09}
\createlinenumber{1622}{97e0}
\createlinenumber{1623}{32bc}
\createlinenumber{1624}{7fb8}
\createlinenumber{1625}{649a}
\createlinenumber{1626}{e335}
\createlinenumber{1627}{95cf}
\createlinenumber{1628}{427e}
\createlinenumber{1629}{63d4}
\createlinenumber{1630}{b811}
\createlinenumber{1631}{9b7d}
\createlinenumber{1632}{95cf}
\createlinenumber{1633}{b7ec}
\createlinenumber{1634}{a792}
\createlinenumber{1635}{ef40}
\createlinenumber{1636}{95cf}
\createlinenumber{1637}{e3f8}
\createlinenumber{1638}{d089}
\createlinenumber{1639}{95cf}
\createlinenumber{1640}{86a3}
\createlinenumber{1641}{9aad}
\createlinenumber{1642}{95cf}
\createlinenumber{1643}{329b}
\createlinenumber{1644}{427e}
\createlinenumber{1645}{9291}
\createlinenumber{1646}{424d}
\createlinenumber{1647}{da12}
\createlinenumber{1648}{5786}
\createlinenumber{1649}{e87d}
\createlinenumber{1650}{974a}
\createlinenumber{1651}{95cf}
\createlinenumber{1652}{9c87}
\createlinenumber{1653}{9922}
\createlinenumber{1654}{95cf}
\createlinenumber{1655}{329b}
\createlinenumber{1656}{6ad2}
\createlinenumber{1657}{57b7}
\createlinenumber{1658}{e7f7}
\createlinenumber{1659}{226e}
\createlinenumber{1660}{60b7}
\createlinenumber{1661}{8def}
\createlinenumber{1662}{937a}
\createlinenumber{1663}{263b}
\createlinenumber{1664}{95cf}
\createlinenumber{1665}{9c87}
\createlinenumber{1666}{2fec}
\createlinenumber{1667}{95cf}
\createlinenumber{1668}{329b}
\createlinenumber{1669}{427e}
\createlinenumber{1670}{427e}
\createlinenumber{1671}{9291}
\createlinenumber{1672}{affa}
\createlinenumber{1673}{da12}
\createlinenumber{1674}{2935}
\createlinenumber{1675}{e87d}
\createlinenumber{1676}{974a}
\createlinenumber{1677}{95cf}
\createlinenumber{1678}{9c87}
\createlinenumber{1679}{9922}
\createlinenumber{1680}{95cf}
\createlinenumber{1681}{329b}
\createlinenumber{1682}{6ad2}
\createlinenumber{1683}{fd78}
\createlinenumber{1684}{e7f7}
\createlinenumber{1685}{4c20}
\createlinenumber{1686}{76a5}
\createlinenumber{1687}{f041}
\createlinenumber{1688}{937a}
\createlinenumber{1689}{0b96}
\createlinenumber{1690}{2092}
\createlinenumber{1691}{8e2e}
\createlinenumber{1692}{a4c7}
\createlinenumber{1693}{95cf}
\createlinenumber{1694}{95cf}
\createlinenumber{1695}{9c87}
\createlinenumber{1696}{3c1c}
\createlinenumber{1697}{95cf}
\createlinenumber{1698}{329b}
\begin{lstlisting}[language=C++]
template <class info, class tag>
class LSGT {
    std::vector<info> node;
    std::vector<tag> ta;
    int siz;
    void build(int idx, int l, int r) {
        if (l == r)
            return;
        int mid = (l + r) >> 1;
        build(idx << 1, l, mid), build(idx << 1 | 1, mid + 1, r);
        node[idx] = node[idx << 1] + node[idx << 1 | 1];
    }
    template <typename T>
    void build(int idx, int l, int r, const std::vector<T> &vec) {
        if (l == r) {
            node[idx] = vec[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(idx << 1, l, mid, vec), build(idx << 1 | 1, mid + 1, r, vec);
        node[idx] = node[idx << 1] + node[idx << 1 | 1];
    }
    void apply(int idx) {
        if (ta[idx].empty())
            return;
        ta[idx << 1].apply(ta[idx]);
        ta[idx << 1 | 1].apply(ta[idx]);
        node[idx << 1].apply(ta[idx]);
        node[idx << 1 | 1].apply(ta[idx]);
        ta[idx] = {};
    }
    void modify(int idx, int l, int r, int ql, int qr, const tag &add) {
        if (ql <= l && qr >= r) {
            ta[idx].apply(add);
            node[idx].apply(add);
            return;
        }
        apply(idx);
        int mid = (l + r) >> 1;
        if (ql <= mid)
            modify(idx << 1, l, mid, ql, qr, add);
        if (qr > mid)
            modify(idx << 1 | 1, mid + 1, r, ql, qr, add);
        node[idx] = node[idx << 1] + node[idx << 1 | 1];
    }
    info query(int idx, int l, int r, int ql, int qr) {
        if (ql <= l && qr >= r)
            return node[idx];
        apply(idx);
        int mid = (l + r) >> 1;
        if (qr <= mid)
            return query(idx << 1, l, mid, ql, qr);
        else if (ql > mid)
            return query(idx << 1 | 1, mid + 1, r, ql, qr);
        else
            return query(idx << 1, l, mid, ql, qr) + query(idx << 1 | 1, mid + 1, r, ql, qr);
    }

public:
    LSGT(const int size) : node(size << 2), ta(size << 2), siz(size) {
        build(1, 1, siz);
    }
    template <typename T>
    LSGT(const std::vector<T> &vec) : node(vec.size() << 2), ta(vec.size() << 2), siz(vec.size() - 1) {
        build(1, 1, siz, vec);
    }
    void modify(int ql, int qr, const tag &add) {
        modify(1, 1, siz, ql, qr, add);
    }
    info query(int ql, int qr) {
        return query(1, 1, siz, ql, qr);
    }
};
//区间加/区间和
struct tag {
    long long add;
    tag() : add(0) {}
    tag(long long x) : add(x) {}
    bool empty() const {
        return !add;
    }
    void apply(const tag &o) {
        add += o.add;
    }
};
struct info {
    int len;
    long long sum;
    info() : len(1), sum(0) {}
    info(long long x) : len(1), sum(x) {}
    info(int len, long long sum) : len(len), sum(sum) {}
    info operator+(const info &o) const {
        return info{len + o.len, sum + o.sum};
    }
    void apply(const tag &o) {
        sum += o.add * len;
    }
};

//区间最小值计数
struct tag {
    int add;
    tag() : add(0) {}
    tag(int x) : add(x) {}
    bool empty() const {
        return !add;
    }
    void apply(const tag &o) {
        add += o.add;
    }
};
struct info {
    int minn;
    long long sum;
    info() : minn(0), sum(0) {}
    info(long long sum) : minn(0), sum(sum) {}
    info(int minn, long long sum) : minn(minn), sum(sum) {}
    info operator+(const info &o) const {
        if (minn == o.minn) {
            return {minn, sum + o.sum};
        } else {
            return minn < o.minn ? *this : o;
        }
    }
    void apply(const tag &o) {
        minn += o.add;
    }
};
\end{lstlisting}
\subsection{st}
\createlinenumber{1699}{839f}
\createlinenumber{1700}{c830}
\createlinenumber{1701}{5c83}
\createlinenumber{1702}{db67}
\createlinenumber{1703}{3d49}
\createlinenumber{1704}{427e}
\createlinenumber{1705}{a736}
\createlinenumber{1706}{c9b5}
\createlinenumber{1707}{48b3}
\createlinenumber{1708}{d4e2}
\createlinenumber{1709}{b359}
\createlinenumber{1710}{849f}
\createlinenumber{1711}{533c}
\createlinenumber{1712}{a316}
\createlinenumber{1713}{fd79}
\createlinenumber{1714}{95cf}
\createlinenumber{1715}{95cf}
\createlinenumber{1716}{95cf}
\createlinenumber{1717}{0d48}
\createlinenumber{1718}{b1bc}
\createlinenumber{1719}{f7a1}
\createlinenumber{1720}{95cf}
\createlinenumber{1721}{329b}
\createlinenumber{1722}{9627}
\createlinenumber{1723}{35b8}
\createlinenumber{1724}{9af0}
\createlinenumber{1725}{b943}
\createlinenumber{1726}{d535}
\createlinenumber{1727}{4d6d}
\createlinenumber{1728}{e052}
\createlinenumber{1729}{9f6b}
\createlinenumber{1730}{ad6f}
\createlinenumber{1731}{5c9b}
\createlinenumber{1732}{95cf}
\createlinenumber{1733}{95cf}
\createlinenumber{1734}{427e}
\begin{lstlisting}[language=C++]
template <typename T, class F = function<T(const T&, const T&)>>
struct SparseTable {
    int n;
    vector<vector<T>> st;
    F func;

    SparseTable(const vector<T>& a, const F& f) : func(f) {
        n = (int)a.size() - 1;
        int max_log = __lg(n) + 1;
        st.resize(max_log + 1);
        st[0] = a;
        for (int j = 1; j <= max_log; j++) {
            st[j].resize(n + 1);
            for (int i = 1; i + (1 << (j - 1)) <= n; i++) {
                st[j][i] = func(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
            }
        }
    }
    T get(int l, int r) const {
        int len = __lg(r - l + 1);
        return func(st[len][l], st[len][r - (1 << len) + 1]);
    }
};
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1, 0);
    for (int i = 1; i <= n; i++) cin >> a[i];
    SparseTable<int> qmx(a, [](int i, int j) { return max(i, j); });
    for (int i = 1; i <= m; i++) {
        int l, r;
        cin >> l >> r;
        cout << qmx.get(l, r) << endl;
    }
}

\end{lstlisting}
\subsection{st\_o(n)}
\createlinenumber{1735}{a8d9}
\createlinenumber{1736}{b3c5}
\createlinenumber{1737}{1f3e}
\createlinenumber{1738}{b621}
\createlinenumber{1739}{5eac}
\createlinenumber{1740}{6fce}
\createlinenumber{1741}{5c83}
\createlinenumber{1742}{8e3c}
\createlinenumber{1743}{0f90}
\createlinenumber{1744}{b6e5}
\createlinenumber{1745}{f7bc}
\createlinenumber{1746}{56d3}
\createlinenumber{1747}{a629}
\createlinenumber{1748}{95cf}
\createlinenumber{1749}{e6f6}
\createlinenumber{1750}{1e76}
\createlinenumber{1751}{d3b3}
\createlinenumber{1752}{fec6}
\createlinenumber{1753}{ce64}
\createlinenumber{1754}{4f2d}
\createlinenumber{1755}{95cf}
\createlinenumber{1756}{30ef}
\createlinenumber{1757}{d300}
\createlinenumber{1758}{9eee}
\createlinenumber{1759}{f050}
\createlinenumber{1760}{07d6}
\createlinenumber{1761}{e89c}
\createlinenumber{1762}{0aa1}
\createlinenumber{1763}{95cf}
\createlinenumber{1764}{95cf}
\createlinenumber{1765}{324a}
\createlinenumber{1766}{35f1}
\createlinenumber{1767}{ad8b}
\createlinenumber{1768}{95cf}
\createlinenumber{1769}{95cf}
\createlinenumber{1770}{7a5c}
\createlinenumber{1771}{8705}
\createlinenumber{1772}{57a2}
\createlinenumber{1773}{95cf}
\createlinenumber{1774}{95cf}
\createlinenumber{1775}{e15f}
\createlinenumber{1776}{912c}
\createlinenumber{1777}{13ab}
\createlinenumber{1778}{95cf}
\createlinenumber{1779}{95cf}
\createlinenumber{1780}{f050}
\createlinenumber{1781}{3d96}
\createlinenumber{1782}{bb6e}
\createlinenumber{1783}{7972}
\createlinenumber{1784}{e3b9}
\createlinenumber{1785}{2c0c}
\createlinenumber{1786}{26c8}
\createlinenumber{1787}{95cf}
\createlinenumber{1788}{6ef3}
\createlinenumber{1789}{0fad}
\createlinenumber{1790}{95cf}
\createlinenumber{1791}{95cf}
\createlinenumber{1792}{95cf}
\createlinenumber{1793}{21ca}
\createlinenumber{1794}{7d64}
\createlinenumber{1795}{dfef}
\createlinenumber{1796}{0054}
\createlinenumber{1797}{7496}
\createlinenumber{1798}{477e}
\createlinenumber{1799}{1c6a}
\createlinenumber{1800}{80e3}
\createlinenumber{1801}{95cf}
\createlinenumber{1802}{4206}
\createlinenumber{1803}{8e2e}
\createlinenumber{1804}{7ac1}
\createlinenumber{1805}{f318}
\createlinenumber{1806}{95cf}
\createlinenumber{1807}{95cf}
\createlinenumber{1808}{329b}
\createlinenumber{1809}{9627}
\createlinenumber{1810}{35b8}
\createlinenumber{1811}{9af0}
\createlinenumber{1812}{e7d5}
\createlinenumber{1813}{e8d3}
\createlinenumber{1814}{e374}
\createlinenumber{1815}{e052}
\createlinenumber{1816}{9f6b}
\createlinenumber{1817}{ad6f}
\createlinenumber{1818}{46d1}
\createlinenumber{1819}{03a0}
\createlinenumber{1820}{ca01}
\createlinenumber{1821}{95cf}
\createlinenumber{1822}{95cf}
\begin{lstlisting}[language=C++]
template <class T,
          class Cmp = std::less<T>>
struct RMQ {
    const Cmp cmp = Cmp();
    static constexpr unsigned B = 64;
    using u64 = unsigned long long;
    int n;
    std::vector<std::vector<T>> a;
    std::vector<T> pre, suf, ini;
    std::vector<u64> stk;
    RMQ() {}
    RMQ(const std::vector<T> &v) {
        init(v);
    }
    void init(const std::vector<T> &v) {
        n = v.size();
        pre = suf = ini = v;
        stk.resize(n);
        if (!n) {
            return;
        }
        const int M = (n - 1) / B + 1;
        const int lg = std::__lg(M);
        a.assign(lg + 1, std::vector<T>(M));
        for (int i = 0; i < M; i++) {
            a[0][i] = v[i * B];
            for (int j = 1; j < B && i * B + j < n; j++) {
                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);
            }
        }
        for (int i = 1; i < n; i++) {
            if (i % B) {
                pre[i] = std::min(pre[i], pre[i - 1], cmp);
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (i % B != B - 1) {
                suf[i] = std::min(suf[i], suf[i + 1], cmp);
            }
        }
        for (int j = 0; j < lg; j++) {
            for (int i = 0; i + (2 << j) <= M; i++) {
                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);
            }
        }
        for (int i = 0; i < M; i++) {
            const int l = i * B;
            const int r = std::min(1U * n, l + B);
            u64 s = 0;
            for (int j = l; j < r; j++) {
                while (s && cmp(v[j], v[std::__lg(s) + l])) {
                    s ^= 1ULL << std::__lg(s);
                }
                s |= 1ULL << (j - l);
                stk[j] = s;
            }
        }
    }
    T operator()(int l, int r) {  // 左闭右开
        if (l / B != (r - 1) / B) {
            T ans = std::min(suf[l], pre[r - 1], cmp);
            l = l / B + 1;
            r = r / B;
            if (l < r) {
                int k = std::__lg(r - l);
                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);
            }
            return ans;
        } else {
            int x = B * (l / B);
            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];
        }
    }
};
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    RMQ<int, greater<int>> qmx(a);
    for (int i = 1; i <= m; i++) {
        int l, r;
        cin >> l >> r;
        l--;
        r--;
        cout << qmx(l, r + 1) << endl;
    }
}
\end{lstlisting}
\subsection{tree\_virtual}
\createlinenumber{1823}{bcf8}
\createlinenumber{1824}{7a26}
\createlinenumber{1825}{329b}
\createlinenumber{1826}{617f}
\createlinenumber{1827}{5c83}
\createlinenumber{1828}{782b}
\createlinenumber{1829}{d454}
\createlinenumber{1830}{aad0}
\createlinenumber{1831}{5b2d}
\createlinenumber{1832}{427e}
\createlinenumber{1833}{c4d2}
\createlinenumber{1834}{752d}
\createlinenumber{1835}{217c}
\createlinenumber{1836}{95cf}
\createlinenumber{1837}{d34f}
\createlinenumber{1838}{b985}
\createlinenumber{1839}{fce3}
\createlinenumber{1840}{43f8}
\createlinenumber{1841}{0bc6}
\createlinenumber{1842}{7871}
\createlinenumber{1843}{a9db}
\createlinenumber{1844}{427e}
\createlinenumber{1845}{d920}
\createlinenumber{1846}{95cf}
\createlinenumber{1847}{5953}
\createlinenumber{1848}{77d1}
\createlinenumber{1849}{95cf}
\createlinenumber{1850}{e294}
\createlinenumber{1851}{200c}
\createlinenumber{1852}{07ac}
\createlinenumber{1853}{1a33}
\createlinenumber{1854}{edd8}
\createlinenumber{1855}{1c88}
\createlinenumber{1856}{95cf}
\createlinenumber{1857}{4d34}
\createlinenumber{1858}{e380}
\createlinenumber{1859}{f95d}
\createlinenumber{1860}{7861}
\createlinenumber{1861}{b333}
\createlinenumber{1862}{5906}
\createlinenumber{1863}{19a5}
\createlinenumber{1864}{bbda}
\createlinenumber{1865}{221a}
\createlinenumber{1866}{1b6f}
\createlinenumber{1867}{0ee8}
\createlinenumber{1868}{c326}
\createlinenumber{1869}{95cf}
\createlinenumber{1870}{95cf}
\createlinenumber{1871}{60ec}
\createlinenumber{1872}{643e}
\createlinenumber{1873}{a577}
\createlinenumber{1874}{1a26}
\createlinenumber{1875}{80cd}
\createlinenumber{1876}{4f2d}
\createlinenumber{1877}{95cf}
\createlinenumber{1878}{12f1}
\createlinenumber{1879}{f95d}
\createlinenumber{1880}{7593}
\createlinenumber{1881}{b333}
\createlinenumber{1882}{8064}
\createlinenumber{1883}{95cf}
\createlinenumber{1884}{80cd}
\createlinenumber{1885}{95cf}
\createlinenumber{1886}{0f0b}
\createlinenumber{1887}{03a1}
\createlinenumber{1888}{5c7d}
\createlinenumber{1889}{23a2}
\createlinenumber{1890}{8e2e}
\createlinenumber{1891}{560a}
\createlinenumber{1892}{95cf}
\createlinenumber{1893}{95cf}
\createlinenumber{1894}{d9e4}
\createlinenumber{1895}{95cf}
\createlinenumber{1896}{c0f6}
\createlinenumber{1897}{3505}
\createlinenumber{1898}{95cf}
\createlinenumber{1899}{329b}
\createlinenumber{1900}{9627}
\createlinenumber{1901}{5c83}
\createlinenumber{1902}{e1b6}
\createlinenumber{1903}{81b6}
\createlinenumber{1904}{7300}
\createlinenumber{1905}{3676}
\createlinenumber{1906}{cd17}
\createlinenumber{1907}{a767}
\createlinenumber{1908}{848a}
\createlinenumber{1909}{95cf}
\createlinenumber{1910}{7fc9}
\createlinenumber{1911}{f049}
\createlinenumber{1912}{329b}
\createlinenumber{1913}{8e5a}
\createlinenumber{1914}{3dcf}
\createlinenumber{1915}{6850}
\createlinenumber{1916}{d4a7}
\createlinenumber{1917}{c4aa}
\createlinenumber{1918}{fb1b}
\createlinenumber{1919}{2f92}
\createlinenumber{1920}{9fb4}
\createlinenumber{1921}{7a5a}
\createlinenumber{1922}{e889}
\createlinenumber{1923}{d4a7}
\createlinenumber{1924}{dab5}
\createlinenumber{1925}{64fd}
\createlinenumber{1926}{562f}
\createlinenumber{1927}{b21c}
\createlinenumber{1928}{a1ca}
\createlinenumber{1929}{048f}
\createlinenumber{1930}{0c3e}
\createlinenumber{1931}{95cf}
\createlinenumber{1932}{329b}
\createlinenumber{1933}{9bbd}
\createlinenumber{1934}{c998}
\createlinenumber{1935}{de3b}
\createlinenumber{1936}{6fa4}
\createlinenumber{1937}{f69c}
\createlinenumber{1938}{26e8}
\createlinenumber{1939}{0f02}
\createlinenumber{1940}{c221}
\createlinenumber{1941}{b333}
\createlinenumber{1942}{754a}
\createlinenumber{1943}{e97e}
\createlinenumber{1944}{2b92}
\createlinenumber{1945}{649a}
\createlinenumber{1946}{16c9}
\createlinenumber{1947}{95cf}
\createlinenumber{1948}{329b}
\createlinenumber{1949}{72ca}
\createlinenumber{1950}{e0cf}
\createlinenumber{1951}{629d}
\createlinenumber{1952}{c8ce}
\createlinenumber{1953}{4ebf}
\createlinenumber{1954}{95cf}
\createlinenumber{1955}{329b}
\createlinenumber{1956}{949d}
\createlinenumber{1957}{701e}
\createlinenumber{1958}{7e47}
\createlinenumber{1959}{88e6}
\createlinenumber{1960}{0f19}
\createlinenumber{1961}{3c9e}
\createlinenumber{1962}{3398}
\createlinenumber{1963}{1adf}
\createlinenumber{1964}{c871}
\createlinenumber{1965}{95cf}
\createlinenumber{1966}{e540}
\createlinenumber{1967}{379d}
\createlinenumber{1968}{11c2}
\createlinenumber{1969}{26ef}
\createlinenumber{1970}{95cf}
\createlinenumber{1971}{95cf}
\begin{lstlisting}[language=C++]
struct edge {
    int v, w;
};
struct HLD {
    int n;
    vector<int> siz, top, parent, l, r, hson, dep;
    vector<vector<edge>> adj;
    int idx;
    vector<int> mn;  // 1-u的最小边权

    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n + 1), hson.resize(n + 1), top.resize(n + 1);
        parent.resize(n + 1);
        l.resize(n + 1), r.resize(n + 1);
        idx = 0;
        adj.resize(n + 1), dep.resize(n + 1);
        // 根据题目要求加数据结构
        mn.resize(n + 1, 1e9);
    }
    void addEdge(int u, int v, int w) {
        adj[u].push_back({v, w});
    }
    void work(int root = 1) {
        top[root] = root;
        parent[root] = -1;
        dep[root] = 1;
        dfs1(root, -1);
        dfs2(root, root);
    }
    void dfs1(int u, int f) {  // 搞fa,dep,son
        siz[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (v == f)
                continue;
            mn[v] = min(mn[u], w);
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[hson[u]] < siz[v])
                hson[u] = v;
        }
    }
    void dfs2(int u, int t) {  // 搞top
        top[u] = t;            // 记录链头
        l[u] = ++idx;
        if (!hson[u]) {
            r[u] = idx;
            return;
        }  // 无重儿子
        dfs2(hson[u], t);  // 搜重儿子
        for (auto [v, w] : adj[u]) {
            if (v == parent[u] || v == hson[u])
                continue;
            dfs2(v, v);  // 搜轻儿子
        }
        r[u] = idx;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    bool isAncester(int u, int v) {  // 判断u是不是v的祖先
        return l[u] <= l[v] && r[v] <= r[u];
    }
};
void solve() {
    int n;
    cin >> n;
    HLD hld(n);
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        hld.addEdge(u, v, w);
        hld.addEdge(v, u, w);
    }
    auto cmp = [&](int i, int j) {
        return hld.l[i] < hld.l[j];
    };
    hld.work(1);
    auto buildvt = [&](vector<int>& node, vector<vector<edge>>& e) {
        node.push_back(1);  // 保证根节点在虚树中存在
        sort(alls(node), cmp);
        node.erase(unique(alls(node)), node.end());
        set<int> tmp;
        for (auto x : node) tmp.insert(x);
        for (int i = 1; i < (int)node.size(); i++) tmp.insert(hld.lca(node[i - 1], node[i]));
        node.clear();
        for (auto x : tmp) node.push_back(x);
        sort(alls(node), cmp);
        vector<int> st;  // 维护一个栈
        for (auto v : node) {
            while (!st.empty() && !hld.isAncester(st.back(), v))
                st.pop_back();
            if (!st.empty())
                e[st.back()].push_back({v, hld.mn[v]});
            st.push_back(v);
        }
    };
    int q;
    cin >> q;
    vector<vector<edge>> e(n + 1);
    vector<ll> dp(n + 1);  // 使得u子树内关键点与u不连通的代价
    vector<bool> vis(n + 1);
    auto cal = [&](auto self, int u, int fa) -> void {  // 计算答案
        for (auto [v, w] : e[u]) {
            if (v == fa)
                continue;
            self(self, v, u);
            if (vis[v])
                dp[u] += w;
            else
                dp[u] += min((ll)w, dp[v]);
        }
    };
    auto clear = [&](vector<int>& node) {  // 清空本次用的点的信息
        for (auto x : node) {
            vis[x] = 0;
            dp[x] = 0;
            e[x].clear();
        }
    };
    for (int i = 1; i <= q; i++) {
        int num;
        cin >> num;
        vector<int> node;
        for (int j = 1; j <= num; j++) {
            int x;
            cin >> x;
            node.push_back(x);
            vis[x] = 1;
        }
        buildvt(node, e);
        cal(cal, 1, 1);
        cout << dp[1] << endl;
        clear(node);
    }
}
\end{lstlisting}
\subsection{trie\_per}
\createlinenumber{1972}{302f}
\createlinenumber{1973}{427e}
\createlinenumber{1974}{421c}
\createlinenumber{1975}{427e}
\createlinenumber{1976}{a6ca}
\createlinenumber{1977}{427e}
\createlinenumber{1978}{427e}
\createlinenumber{1979}{5217}
\createlinenumber{1980}{86c3}
\createlinenumber{1981}{427e}
\createlinenumber{1982}{64e6}
\createlinenumber{1983}{b12f}
\createlinenumber{1984}{df76}
\createlinenumber{1985}{55f6}
\createlinenumber{1986}{a711}
\createlinenumber{1987}{f014}
\createlinenumber{1988}{9aae}
\createlinenumber{1989}{94b8}
\createlinenumber{1990}{9f44}
\createlinenumber{1991}{8e2e}
\createlinenumber{1992}{8e2f}
\createlinenumber{1993}{9f44}
\createlinenumber{1994}{95cf}
\createlinenumber{1995}{73b0}
\createlinenumber{1996}{95cf}
\createlinenumber{1997}{ff9b}
\createlinenumber{1998}{95cf}
\createlinenumber{1999}{bce4}
\createlinenumber{2000}{2837}
\createlinenumber{2001}{df76}
\createlinenumber{2002}{55f6}
\createlinenumber{2003}{5718}
\createlinenumber{2004}{821a}
\createlinenumber{2005}{8e2e}
\createlinenumber{2006}{837e}
\createlinenumber{2007}{95cf}
\createlinenumber{2008}{95cf}
\createlinenumber{2009}{ee75}
\createlinenumber{2010}{95cf}
\createlinenumber{2011}{3117}
\createlinenumber{2012}{f59e}
\createlinenumber{2013}{212b}
\createlinenumber{2014}{9af0}
\createlinenumber{2015}{6dbf}
\createlinenumber{2016}{879c}
\createlinenumber{2017}{6125}
\createlinenumber{2018}{3703}
\createlinenumber{2019}{55ee}
\createlinenumber{2020}{95cf}
\createlinenumber{2021}{3f3a}
\createlinenumber{2022}{b4da}
\createlinenumber{2023}{d217}
\createlinenumber{2024}{4425}
\createlinenumber{2025}{d2b3}
\createlinenumber{2026}{3398}
\createlinenumber{2027}{5b50}
\createlinenumber{2028}{0711}
\createlinenumber{2029}{1017}
\createlinenumber{2030}{8e2e}
\createlinenumber{2031}{a779}
\createlinenumber{2032}{1543}
\createlinenumber{2033}{83e5}
\createlinenumber{2034}{95cf}
\createlinenumber{2035}{95cf}
\createlinenumber{2036}{7021}
\createlinenumber{2037}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>

using namespace std;

const int N = 6e5 + 10, M = N * 25 + N;

// 数组大小应为，点数 × 层数（长度），然后第二维是看可能的分支数量。
int idx, tr[M][2], cnt[M], root[N], val[M];
int n, m, a[N];

void insert(int i, int x) {
    int p = root[i], q = root[i - 1];
    for (int k = 24; k >= 0; k--) {
        int t = x >> k & 1;
        if (tr[q][t ^ 1])
            tr[p][t ^ 1] = tr[q][t ^ 1];
        if (tr[p][t]) {
            p = tr[p][t];
            q = tr[q][t];
        } else {
            p = tr[p][t] = ++idx;
            q = tr[q][t];
        }
        cnt[p] = cnt[q] + 1;
    }
    val[p] = x;
}
int query(int l, int r, int x) {
    int p = root[r], q = root[max(0, l - 1)];
    for (int k = 24; k >= 0; k--) {
        int t = x >> k & 1;
        if (tr[p][t ^ 1] && cnt[tr[p][t ^ 1]] - cnt[tr[q][t ^ 1]] > 0) {
            p = tr[p][t ^ 1], q = tr[q][t ^ 1];
        } else {
            p = tr[p][t], q = tr[q][t];
        }
    }
    return x ^ val[p];
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        root[i] = ++idx;
        a[i] ^= a[i - 1];
        insert(i, a[i]);
    }
    while (m--) {
        char op;
        int l, r, x;
        cin >> op;
        if (op == 'A') {
            cin >> x;
            root[++n] = ++idx;
            a[n] = a[n - 1] ^ x;
            insert(n, a[n]);
        } else {
            cin >> l >> r >> x;
            int y = a[n] ^ x;
            cout << query(l - 1, r - 1, y) << '\n';
        }
    }
    return 0;
}
\end{lstlisting}
\subsection{twoheap}
\createlinenumber{2038}{6392}
\createlinenumber{2039}{075f}
\createlinenumber{2040}{5f32}
\createlinenumber{2041}{ab2f}
\createlinenumber{2042}{9268}
\createlinenumber{2043}{037f}
\createlinenumber{2044}{aea8}
\createlinenumber{2045}{95cf}
\createlinenumber{2046}{95cf}
\createlinenumber{2047}{6516}
\createlinenumber{2048}{0621}
\createlinenumber{2049}{95cf}
\createlinenumber{2050}{d2f1}
\createlinenumber{2051}{e972}
\createlinenumber{2052}{e151}
\createlinenumber{2053}{95cf}
\createlinenumber{2054}{4410}
\createlinenumber{2055}{406c}
\createlinenumber{2056}{95cf}
\begin{lstlisting}[language=C++]
priority_queue<int> down;                           // 大根堆
priority_queue<int, vector<int>, greater<int> > b;  // 前k大的元素在这里，第k大在堆顶
void insert(int x) {
    if (b.empty() || x >= b.top())
        b.push(x);  // 插入
    else {
        down.push(x);
    }
}
int stob(int sum, int small) {  // 第small小转化为第k大，当前总数意义下
    return sum + 1 - small;
}
void makebl(int k) {                                        // 维护前k大性质
    while ((int)b.size() > k) down.push(b.top()), b.pop();  // 调整
    while ((int)b.size() < k) b.push(down.top()), down.pop();
}
int getkth() {
    return b.top();
}
\end{lstlisting}
\subsection{twoheaplazy}
\createlinenumber{2057}{302f}
\createlinenumber{2058}{421c}
\createlinenumber{2059}{5a4f}
\createlinenumber{2060}{098b}
\createlinenumber{2061}{d29e}
\createlinenumber{2062}{96b5}
\createlinenumber{2063}{e74e}
\createlinenumber{2064}{427e}
\createlinenumber{2065}{b7ec}
\createlinenumber{2066}{c4cb}
\createlinenumber{2067}{48cf}
\createlinenumber{2068}{894c}
\createlinenumber{2069}{bbd2}
\createlinenumber{2070}{96d6}
\createlinenumber{2071}{3ce7}
\createlinenumber{2072}{14b0}
\createlinenumber{2073}{e596}
\createlinenumber{2074}{d268}
\createlinenumber{2075}{6173}
\createlinenumber{2076}{95cf}
\createlinenumber{2077}{95cf}
\createlinenumber{2078}{427e}
\createlinenumber{2079}{97d8}
\createlinenumber{2080}{ea97}
\createlinenumber{2081}{3687}
\createlinenumber{2082}{e26c}
\createlinenumber{2083}{62de}
\createlinenumber{2084}{af08}
\createlinenumber{2085}{98af}
\createlinenumber{2086}{a568}
\createlinenumber{2087}{ed4a}
\createlinenumber{2088}{c5b2}
\createlinenumber{2089}{2ddc}
\createlinenumber{2090}{5eca}
\createlinenumber{2091}{d715}
\createlinenumber{2092}{95cf}
\createlinenumber{2093}{95cf}
\createlinenumber{2094}{427e}
\createlinenumber{2095}{63d4}
\createlinenumber{2096}{1141}
\createlinenumber{2097}{427e}
\createlinenumber{2098}{6ed7}
\createlinenumber{2099}{5e04}
\createlinenumber{2100}{10dd}
\createlinenumber{2101}{2ddc}
\createlinenumber{2102}{8e2e}
\createlinenumber{2103}{4feb}
\createlinenumber{2104}{fdff}
\createlinenumber{2105}{f983}
\createlinenumber{2106}{62de}
\createlinenumber{2107}{8e2e}
\createlinenumber{2108}{10dd}
\createlinenumber{2109}{2ddc}
\createlinenumber{2110}{95cf}
\createlinenumber{2111}{95cf}
\createlinenumber{2112}{e34a}
\createlinenumber{2113}{95cf}
\createlinenumber{2114}{427e}
\createlinenumber{2115}{4cd6}
\createlinenumber{2116}{fbd5}
\createlinenumber{2117}{432c}
\createlinenumber{2118}{af08}
\createlinenumber{2119}{8f67}
\createlinenumber{2120}{98af}
\createlinenumber{2121}{8e2e}
\createlinenumber{2122}{5eca}
\createlinenumber{2123}{4c90}
\createlinenumber{2124}{d715}
\createlinenumber{2125}{95cf}
\createlinenumber{2126}{e34a}
\createlinenumber{2127}{95cf}
\createlinenumber{2128}{427e}
\createlinenumber{2129}{03f0}
\createlinenumber{2130}{9010}
\createlinenumber{2131}{b1d9}
\createlinenumber{2132}{649a}
\createlinenumber{2133}{a20b}
\createlinenumber{2134}{95cf}
\createlinenumber{2135}{329b}
\createlinenumber{2136}{427e}
\createlinenumber{2137}{3117}
\createlinenumber{2138}{0aad}
\createlinenumber{2139}{427e}
\createlinenumber{2140}{427e}
\createlinenumber{2141}{e1b6}
\createlinenumber{2142}{6dbf}
\createlinenumber{2143}{879c}
\createlinenumber{2144}{a1a8}
\createlinenumber{2145}{95cf}
\createlinenumber{2146}{427e}
\createlinenumber{2147}{427e}
\createlinenumber{2148}{427e}
\createlinenumber{2149}{427e}
\createlinenumber{2150}{427e}
\createlinenumber{2151}{6dbf}
\createlinenumber{2152}{b559}
\createlinenumber{2153}{427e}
\createlinenumber{2154}{4c3b}
\createlinenumber{2155}{3251}
\createlinenumber{2156}{a1a8}
\createlinenumber{2157}{95cf}
\createlinenumber{2158}{427e}
\createlinenumber{2159}{427e}
\createlinenumber{2160}{427e}
\createlinenumber{2161}{427e}
\createlinenumber{2162}{427e}
\createlinenumber{2163}{427e}
\createlinenumber{2164}{427e}
\createlinenumber{2165}{427e}
\createlinenumber{2166}{427e}
\createlinenumber{2167}{7021}
\createlinenumber{2168}{95cf}
\createlinenumber{2169}{427e}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
class MedianFinder {//可删除对顶堆，动态维护中位数
    priority_queue<int, vector<int>, greater<int>> minheap;
    priority_queue<int> maxheap;
    unordered_map<int, int> delayed;
    int minSize, maxSize;  // decrease delayed

    template <typename T>
    void prune(T &heap) {
        while (!heap.empty()) {
            int num = heap.top();
            if (delayed.count(num)) {
                delayed[num]--;
                if (delayed[num] == 0)
                    delayed.erase(num);
                heap.pop();
            } else
                break;
        }
    }

    void makebalance() {
        if (maxSize > minSize + 1) {
            minheap.push(maxheap.top());
            maxheap.pop();
            minSize++;
            maxSize--;
            prune(maxheap);
        } else if (maxSize < minSize) {
            maxheap.push(minheap.top());
            minheap.pop();
            maxSize++;
            minSize--;
            prune(minheap);
        }
    }

public:
    MedianFinder() : minSize(0), maxSize(0) {}

    void insert(int num) {
        if (minheap.empty() && maxheap.empty()) {
            maxheap.push(num);
            maxSize++;
        } else {
            int topnum = maxheap.top();
            if (topnum < num) {
                minheap.push(num);
                minSize++;
            } else {
                maxheap.push(num);
                maxSize++;
            }
        }
        makebalance();
    }

    void erase(int num) {
        delayed[num]++;
        if (num <= maxheap.top()) {
            maxSize--;
            if (num == maxheap.top())
                prune(maxheap);
        } else {
            minSize--;
            if (num == minheap.top())
                prune(minheap);
        }
        makebalance();
    }

    double getMedian() {
        if (minSize == maxSize)
            return ((double)minheap.top() + maxheap.top()) / 2;  // 防范int溢出
        else
            return (double)maxheap.top();
    }
};

int main() {
    MedianFinder mf;

    // 插入一些数据
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        mf.insert(a[i]);
    }
    // mf.insert(3);
    // mf.insert(1);
    // mf.insert(5);
    // mf.insert(8);
    // mf.insert(2);
    for (int i = 1; i <= n; i++) {
        mf.erase(a[i]);
        // cout<<mf.getMedian() << endl;
        baoliu(mf.getMedian(), 1);
        cout << endl;
        mf.insert(a[i]);
    }
    // // 输出当前中位数
    // cout << "Current median: " << mf.getMedian() << endl;
    //
    // // 删除一个元素
    // mf.erase(1);
    //
    // // 再次输出中位数
    // cout << "Updated median: " << mf.getMedian() << endl;

    return 0;
}

\end{lstlisting}
\subsection{笛卡尔树}
\createlinenumber{2170}{5b7d}
\createlinenumber{2171}{5c83}
\createlinenumber{2172}{3001}
\createlinenumber{2173}{24b6}
\createlinenumber{2174}{e603}
\createlinenumber{2175}{427e}
\createlinenumber{2176}{8e96}
\createlinenumber{2177}{427e}
\createlinenumber{2178}{427e}
\createlinenumber{2179}{7eaf}
\createlinenumber{2180}{cfb9}
\createlinenumber{2181}{6dbf}
\createlinenumber{2182}{22ea}
\createlinenumber{2183}{427e}
\createlinenumber{2184}{3499}
\createlinenumber{2185}{a839}
\createlinenumber{2186}{b439}
\createlinenumber{2187}{95cf}
\createlinenumber{2188}{a9d4}
\createlinenumber{2189}{e7dd}
\createlinenumber{2190}{8e2e}
\createlinenumber{2191}{8072}
\createlinenumber{2192}{95cf}
\createlinenumber{2193}{9233}
\createlinenumber{2194}{989f}
\createlinenumber{2195}{95cf}
\createlinenumber{2196}{290d}
\createlinenumber{2197}{95cf}
\createlinenumber{2198}{329b}
\begin{lstlisting}[language=C++]
struct DKR {
    int n;
    vector<int> l, r;
    int root;
    stack<int> st;

    DKR(int nn) : n(nn), l(nn + 1), r(nn + 1), root(0) {}
    // 默认为小根堆，维护最小值所在区间
    // dkr.built(a,less<int>());大根堆
    int built(const vector<int>& a, function<bool(int, int)> cmp = greater<int>()) {
        while (!st.empty()) st.pop();  // 清空栈
        for (int i = 1; i <= n; i++) {
            int last = 0;

            while (!st.empty() && cmp(a[st.top()], a[i])) {
                last = st.top();
                st.pop();
            }
            if (!st.empty()) {
                r[st.top()] = i;
            } else {
                root = i;
            }
            l[i] = last;
            st.push(i);
        }
        return root;
    }
};
\end{lstlisting}
\section{Graph}
\subsection{2-sat}
\createlinenumber{2199}{445d}
\createlinenumber{2200}{5c83}
\createlinenumber{2201}{9d4c}
\createlinenumber{2202}{9727}
\createlinenumber{2203}{55a2}
\createlinenumber{2204}{6ae5}
\createlinenumber{2205}{427e}
\createlinenumber{2206}{427e}
\createlinenumber{2207}{ce25}
\createlinenumber{2208}{d260}
\createlinenumber{2209}{4f2d}
\createlinenumber{2210}{e271}
\createlinenumber{2211}{95cf}
\createlinenumber{2212}{5943}
\createlinenumber{2213}{9404}
\createlinenumber{2214}{2e91}
\createlinenumber{2215}{e098}
\createlinenumber{2216}{cb5e}
\createlinenumber{2217}{0c42}
\createlinenumber{2218}{2da4}
\createlinenumber{2219}{2aa8}
\createlinenumber{2220}{055c}
\createlinenumber{2221}{67bb}
\createlinenumber{2222}{a19f}
\createlinenumber{2223}{20eb}
\createlinenumber{2224}{769a}
\createlinenumber{2225}{95cf}
\createlinenumber{2226}{95cf}
\createlinenumber{2227}{4804}
\createlinenumber{2228}{3b67}
\createlinenumber{2229}{a69f}
\createlinenumber{2230}{a29f}
\createlinenumber{2231}{4c7a}
\createlinenumber{2232}{5c22}
\createlinenumber{2233}{0ab5}
\createlinenumber{2234}{06cb}
\createlinenumber{2235}{95cf}
\createlinenumber{2236}{329b}
\createlinenumber{2237}{420e}
\createlinenumber{2238}{ce6e}
\createlinenumber{2239}{d081}
\createlinenumber{2240}{6c2f}
\createlinenumber{2241}{b545}
\createlinenumber{2242}{438e}
\createlinenumber{2243}{d03c}
\createlinenumber{2244}{95cf}
\createlinenumber{2245}{3361}
\createlinenumber{2246}{95cf}
\createlinenumber{2247}{4239}
\createlinenumber{2248}{329b}
\createlinenumber{2249}{9627}
\createlinenumber{2250}{35b8}
\createlinenumber{2251}{9af0}
\createlinenumber{2252}{05f9}
\createlinenumber{2253}{e052}
\createlinenumber{2254}{54f1}
\createlinenumber{2255}{e8b9}
\createlinenumber{2256}{427e}
\createlinenumber{2257}{5293}
\createlinenumber{2258}{5ad5}
\createlinenumber{2259}{852f}
\createlinenumber{2260}{5623}
\createlinenumber{2261}{95cf}
\createlinenumber{2262}{e4ad}
\createlinenumber{2263}{a7de}
\createlinenumber{2264}{098b}
\createlinenumber{2265}{d268}
\createlinenumber{2266}{7c0f}
\createlinenumber{2267}{95cf}
\createlinenumber{2268}{427e}
\begin{lstlisting}[language=C++]
struct TwoSat {
    int n;
    vector<vector<int>> e;
    vector<bool> ans;
    TwoSat(int n) : n(n), e(2 * n), ans(n) {}
    void add(int u, bool f, int v, bool g) {
        // 偶数是u取反的变量，奇数是正变量
        // 一般来说需要反变量向正变量连边。
        e[2 * u + !f].push_back(2 * v + g);
        if (u == v)
            return;  // 对于单变量指定特判
        e[2 * v + !g].push_back(2 * u + f);
    }
    bool judge() {
        vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);
        vector<int> stk;
        int now = 0, cnt = 0;
        function<void(int)> tarjan = [&](int u) {
            stk.push_back(u);
            dfn[u] = low[u] = now++;
            for (auto v : e[u]) {
                if (dfn[v] == -1) {
                    tarjan(v);
                    low[u] = min(low[u], low[v]);
                } else if (id[v] == -1) {
                    low[u] = min(low[u], dfn[v]);
                }
            }
            if (dfn[u] == low[u]) {
                int v;
                do {
                    v = stk.back();
                    stk.pop_back();
                    id[v] = cnt;
                } while (v != u);
                ++cnt;
            }
        };
        for (int i = 0; i < 2 * n; ++i)
            if (dfn[i] == -1)
                tarjan(i);
        for (int i = 0; i < n; ++i) {
            if (id[2 * i] == id[2 * i + 1])
                return false;
            ans[i] = id[2 * i] > id[2 * i + 1];
        }
        return true;
    }
    vector<bool> answer() { return ans; }
};
void solve() {
    int n, m;
    cin >> n >> m;
    TwoSat sat2(n);
    for (int i = 1; i <= m; i++) {
        int u, v;
        bool f1, f2;
        //u为f1或v为f2
        cin >> u >> f1 >> v >> f2;
        u--;
        v--;
        sat2.add(u, f1, v, f2);
    }
    if (sat2.judge()) {
        cout << "POSSIBLE" << endl;
        for (int i = 0; i < n; i++) cout << sat2.ans[i] << " ";
    } else
        cout << "IMPOSSIBLE" << endl;
}

\end{lstlisting}
\subsection{dfs判环的具体路径}
\createlinenumber{2269}{418a}
\createlinenumber{2270}{eb7c}
\createlinenumber{2271}{fe44}
\createlinenumber{2272}{427e}
\createlinenumber{2273}{cdad}
\createlinenumber{2274}{f344}
\createlinenumber{2275}{2aa8}
\createlinenumber{2276}{c221}
\createlinenumber{2277}{b333}
\createlinenumber{2278}{8e5f}
\createlinenumber{2279}{b33f}
\createlinenumber{2280}{1656}
\createlinenumber{2281}{754a}
\createlinenumber{2282}{bb81}
\createlinenumber{2283}{0a5b}
\createlinenumber{2284}{3996}
\createlinenumber{2285}{059b}
\createlinenumber{2286}{e980}
\createlinenumber{2287}{f832}
\createlinenumber{2288}{95cf}
\createlinenumber{2289}{6107}
\createlinenumber{2290}{e08b}
\createlinenumber{2291}{95cf}
\createlinenumber{2292}{95cf}
\createlinenumber{2293}{ef4f}
\createlinenumber{2294}{329b}
\createlinenumber{2295}{427e}
\createlinenumber{2296}{6dbf}
\createlinenumber{2297}{854c}
\createlinenumber{2298}{b5f4}
\createlinenumber{2299}{95cf}
\createlinenumber{2300}{95cf}
\createlinenumber{2301}{95cf}
\createlinenumber{2302}{9627}
\createlinenumber{2303}{5c83}
\createlinenumber{2304}{e1b6}
\createlinenumber{2305}{8572}
\createlinenumber{2306}{6dbf}
\createlinenumber{2307}{54f1}
\createlinenumber{2308}{a02c}
\createlinenumber{2309}{65ff}
\createlinenumber{2310}{0a13}
\createlinenumber{2311}{95cf}
\createlinenumber{2312}{9035}
\createlinenumber{2313}{c13a}
\createlinenumber{2314}{edb9}
\createlinenumber{2315}{9611}
\createlinenumber{2316}{a1ac}
\createlinenumber{2317}{3251}
\createlinenumber{2318}{95cf}
\createlinenumber{2319}{95cf}
\createlinenumber{2320}{95cf}
\begin{lstlisting}[language=C++]
void get_cycle(const vector<vector<int>>& e, vector<vector<int>>& cycle) {
    int n = e.size() - 1;//适用于每个点只在一个环上的情况，不考虑环套环
    vector<int> vis(n + 1), pre(n + 1);

    auto dfs = [&](auto&& self, int u, int fa) -> void {
        vis[u] = 1;  // 标记当前节点正在访问
        for (auto v : e[u]) {
            if (v == fa)  // 无向图中跳过父节点
                continue;
            deb(u, v);
            if (vis[v] == 0) {         // 未访问过的节点
                pre[v] = u;            // 记录前驱节点
                self(self, v, u);      // 递归访问
            } else if (vis[v] == 1) {  // 找到一个环
                vector<int> temp;
                int tmp = u;
                while (tmp != v) {  // 回溯找到环中的节点
                    temp.push_back(tmp);
                    tmp = pre[tmp];
                }
                temp.push_back(v);
                cycle.push_back(temp);  // 将环存入cycle
            }
        }
        vis[u] = 2;  // 标记为已访问
    };

    for (int i = 1; i <= n; i++) {
        if (vis[i] == 0) {  // 对每个未访问节点进行 DFS
            dfs(dfs, i, 0);
        }
    }
}
void solve() {
    int n;
    cin >> n;
    vector<vector<int>> e(n + 1), cycle(n + 1);
    for (int i = 1; i <= n; i++) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    get_cycle(e, cycle);
    for (int i = 0; i < (int)cycle.size(); i++) {
        if (cycle[i].size()) {
            sort(alls(cycle[i]));//不排序才是环上正确的路径
            for (auto x : cycle[i]) cout << x << " ";
            cout << endl;
        }
    }
}
\end{lstlisting}
\subsection{匈牙利}
\createlinenumber{2321}{c3a5}
\createlinenumber{2322}{0037}
\createlinenumber{2323}{9d4c}
\createlinenumber{2324}{6fe1}
\createlinenumber{2325}{ff4f}
\createlinenumber{2326}{02c9}
\createlinenumber{2327}{4ad9}
\createlinenumber{2328}{cd86}
\createlinenumber{2329}{ac07}
\createlinenumber{2330}{4a5d}
\createlinenumber{2331}{36f5}
\createlinenumber{2332}{95cf}
\createlinenumber{2333}{f6f4}
\createlinenumber{2334}{19df}
\createlinenumber{2335}{95cf}
\createlinenumber{2336}{f33f}
\createlinenumber{2337}{2aa8}
\createlinenumber{2338}{427e}
\createlinenumber{2339}{e97e}
\createlinenumber{2340}{b333}
\createlinenumber{2341}{c450}
\createlinenumber{2342}{eda4}
\createlinenumber{2343}{90a6}
\createlinenumber{2344}{7459}
\createlinenumber{2345}{95cf}
\createlinenumber{2346}{95cf}
\createlinenumber{2347}{7021}
\createlinenumber{2348}{95cf}
\createlinenumber{2349}{007c}
\createlinenumber{2350}{3b0f}
\createlinenumber{2351}{01e5}
\createlinenumber{2352}{84c0}
\createlinenumber{2353}{1c52}
\createlinenumber{2354}{95cf}
\createlinenumber{2355}{4206}
\createlinenumber{2356}{95cf}
\createlinenumber{2357}{f583}
\createlinenumber{2358}{ccd7}
\createlinenumber{2359}{6f27}
\createlinenumber{2360}{244d}
\createlinenumber{2361}{329b}
\createlinenumber{2362}{329b}
\begin{lstlisting}[language=C++]
struct XYL {
    vector<int> vis, match;
    vector<vector<int>> e;
    int n1, n2, m;
    XYL(int n1_, int n2_, int m_) {
        n1 = n1_;
        n2 = n2_;
        m = m_;
        vis.resize(n2 + 1);
        match.resize(n2 + 1);
        e.resize(n1 + 1);
    }
    void addEdge(int u, int v) {
        e[u].emplace_back(v);
    }
    int dfs(int u) {
        for (auto v : e[u]) {
            // 妹子的编号v
            if (vis[v])
                continue;
            vis[v] = 1;  // 先标记这个妹子
            if (!match[v] || dfs(match[v])) {
                match[v] = u;  // 配成对
                return 1;
            }
        }
        return 0;
    }
    int work() {
        int ans = 0;
        for (int i = 1; i <= n1; i++) {
            fill(alls(vis), 0);  // 每轮找增广路以前清空vis
            ans += dfs(i);
        }
        return ans;
    }
    vector<int> fangan() {
        vector<int> res(max(n1, n2) + 1);
        for (int i = 1; i <= n2; i++) res[match[i]] = i;
        return res;  // res[i]表示匹配的女生编号
    };
};
\end{lstlisting}
\subsection{无向图判环}
\createlinenumber{2363}{bf9e}
\createlinenumber{2364}{93d2}
\createlinenumber{2365}{8be9}
\createlinenumber{2366}{f69c}
\createlinenumber{2367}{56cc}
\createlinenumber{2368}{0daa}
\createlinenumber{2369}{91b0}
\createlinenumber{2370}{eb31}
\createlinenumber{2371}{95cf}
\createlinenumber{2372}{1c7d}
\createlinenumber{2373}{74d5}
\createlinenumber{2374}{15dd}
\createlinenumber{2375}{2aa8}
\createlinenumber{2376}{5053}
\createlinenumber{2377}{c134}
\createlinenumber{2378}{eab7}
\createlinenumber{2379}{b34c}
\createlinenumber{2380}{95cf}
\createlinenumber{2381}{95cf}
\createlinenumber{2382}{95cf}
\createlinenumber{2383}{56cc}
\createlinenumber{2384}{8d85}
\createlinenumber{2385}{3361}
\createlinenumber{2386}{95cf}
\createlinenumber{2387}{438e}
\createlinenumber{2388}{95cf}
\begin{lstlisting}[language=C++]
bool iscycle_undirect(vector<vector<int>> &e, vector<int> &deg) {  // 有环返回true
    queue<int> q;
    int n = deg.size() - 1;
    vector<bool> vis(n + 1);
    for (int i = 1; i <= n; i++)
        if (deg[i] == 1) {
            vis[i] = true;
            q.push(i);
        }
    while (q.size()) {
        auto u = q.front();
        q.pop();
        for (auto v : e[u]) {
            deg[v]--;
            if (deg[v] <= 1 && vis[v] == 0) {
                q.push(v);
                vis[v] = true;
            }
        }
    }
    for (int i = 1; i <= n; i++)
        if (deg[i] > 1) {  // 最后度数大于1的点在环上
            return true;
        }
    return false;
}//还需要对不同连通块分别处理具体路径和环长度
\end{lstlisting}
\subsection{最短路\_迪杰斯特拉}
\createlinenumber{2389}{bcf8}
\createlinenumber{2390}{7a26}
\createlinenumber{2391}{329b}
\createlinenumber{2392}{c8a3}
\createlinenumber{2393}{9927}
\createlinenumber{2394}{0473}
\createlinenumber{2395}{f69c}
\createlinenumber{2396}{721d}
\createlinenumber{2397}{aee7}
\createlinenumber{2398}{1c7d}
\createlinenumber{2399}{0988}
\createlinenumber{2400}{15dd}
\createlinenumber{2401}{2364}
\createlinenumber{2402}{859f}
\createlinenumber{2403}{b333}
\createlinenumber{2404}{f344}
\createlinenumber{2405}{427e}
\createlinenumber{2406}{0f02}
\createlinenumber{2407}{427e}
\createlinenumber{2408}{2de2}
\createlinenumber{2409}{a6b8}
\createlinenumber{2410}{3c98}
\createlinenumber{2411}{95cf}
\createlinenumber{2412}{95cf}
\createlinenumber{2413}{427e}
\createlinenumber{2414}{95cf}
\createlinenumber{2415}{5d89}
\createlinenumber{2416}{95cf}
\begin{lstlisting}[language=C++]
struct edge {
    int v, w;
};
vector<int> dijs(vector<vector<edge>>& e, int s) {
    priority_queue<pii, vector<pii>, greater<pii>> q;
    vector<int> d(n + 1, (1LL<<31)-1);
    vector<bool> vis(n + 1);
    d[s] = 0;
    q.push({d[s],s});
    while (q.size()) {
        auto t = q.top();
        q.pop();
        int u = t.sec;
        if (vis[u])
            continue;  // 再进队就直接跳过
        vis[u] = 1;    // 标记u已出队
        
        for (auto [v, w] : e[u]) {
            
            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push({d[v], v});  // 小根堆
            }
        }
        
    }
    return d;
}
\end{lstlisting}
\subsection{有向图判环}
\createlinenumber{2417}{bce0}
\createlinenumber{2418}{93d2}
\createlinenumber{2419}{8be9}
\createlinenumber{2420}{56cc}
\createlinenumber{2421}{60f3}
\createlinenumber{2422}{eb31}
\createlinenumber{2423}{1c7d}
\createlinenumber{2424}{74d5}
\createlinenumber{2425}{15dd}
\createlinenumber{2426}{2aa8}
\createlinenumber{2427}{5053}
\createlinenumber{2428}{7245}
\createlinenumber{2429}{eab7}
\createlinenumber{2430}{95cf}
\createlinenumber{2431}{95cf}
\createlinenumber{2432}{56cc}
\createlinenumber{2433}{8c16}
\createlinenumber{2434}{3361}
\createlinenumber{2435}{95cf}
\createlinenumber{2436}{438e}
\createlinenumber{2437}{95cf}
\begin{lstlisting}[language=C++]
bool iscycle_direct(vector<vector<int>> &e, vector<int> &deg) {//有环返回true
    queue<int> q;
    int n = deg.size() - 1;
    for (int i = 1; i <= n; i++)
        if (deg[i] == 0)
            q.push(i);
    while (q.size()) {
        auto u = q.front();
        q.pop();
        for (auto v : e[u]) {
            deg[v]--;
            if (deg[v] == 0)
                q.push(v);
        }
    }
    for (int i = 1; i <= n; i++)
        if (deg[i]) {
            return true;
        }
    return false;
}
\end{lstlisting}
\section{Math}
\subsection{Frac}
\createlinenumber{2438}{0c7b}
\createlinenumber{2439}{0f64}
\createlinenumber{2440}{254b}
\createlinenumber{2441}{ab1e}
\createlinenumber{2442}{ae1e}
\createlinenumber{2443}{18dc}
\createlinenumber{2444}{9e4a}
\createlinenumber{2445}{ef66}
\createlinenumber{2446}{95cf}
\createlinenumber{2447}{95cf}
\createlinenumber{2448}{d7ad}
\createlinenumber{2449}{f35e}
\createlinenumber{2450}{71d3}
\createlinenumber{2451}{797b}
\createlinenumber{2452}{b636}
\createlinenumber{2453}{18d1}
\createlinenumber{2454}{95cf}
\createlinenumber{2455}{e482}
\createlinenumber{2456}{a163}
\createlinenumber{2457}{95cf}
\createlinenumber{2458}{326b}
\createlinenumber{2459}{3f52}
\createlinenumber{2460}{1a20}
\createlinenumber{2461}{a09f}
\createlinenumber{2462}{95cf}
\createlinenumber{2463}{bb1b}
\createlinenumber{2464}{73d3}
\createlinenumber{2465}{1a20}
\createlinenumber{2466}{a09f}
\createlinenumber{2467}{95cf}
\createlinenumber{2468}{e633}
\createlinenumber{2469}{0540}
\createlinenumber{2470}{1a20}
\createlinenumber{2471}{a09f}
\createlinenumber{2472}{95cf}
\createlinenumber{2473}{6392}
\createlinenumber{2474}{d622}
\createlinenumber{2475}{9266}
\createlinenumber{2476}{18dc}
\createlinenumber{2477}{ef66}
\createlinenumber{2478}{9e4a}
\createlinenumber{2479}{95cf}
\createlinenumber{2480}{a09f}
\createlinenumber{2481}{95cf}
\createlinenumber{2482}{5c94}
\createlinenumber{2483}{40bd}
\createlinenumber{2484}{95cf}
\createlinenumber{2485}{1770}
\createlinenumber{2486}{c01d}
\createlinenumber{2487}{95cf}
\createlinenumber{2488}{0701}
\createlinenumber{2489}{42c0}
\createlinenumber{2490}{95cf}
\createlinenumber{2491}{e967}
\createlinenumber{2492}{c26c}
\createlinenumber{2493}{95cf}
\createlinenumber{2494}{94bc}
\createlinenumber{2495}{9414}
\createlinenumber{2496}{95cf}
\createlinenumber{2497}{af16}
\createlinenumber{2498}{44cc}
\createlinenumber{2499}{95cf}
\createlinenumber{2500}{791d}
\createlinenumber{2501}{1c02}
\createlinenumber{2502}{95cf}
\createlinenumber{2503}{8373}
\createlinenumber{2504}{ddeb}
\createlinenumber{2505}{95cf}
\createlinenumber{2506}{abaf}
\createlinenumber{2507}{c6b1}
\createlinenumber{2508}{95cf}
\createlinenumber{2509}{9958}
\createlinenumber{2510}{07dc}
\createlinenumber{2511}{95cf}
\createlinenumber{2512}{a365}
\createlinenumber{2513}{2feb}
\createlinenumber{2514}{95cf}
\createlinenumber{2515}{e05c}
\createlinenumber{2516}{0fec}
\createlinenumber{2517}{d2f2}
\createlinenumber{2518}{5f45}
\createlinenumber{2519}{8e2e}
\createlinenumber{2520}{cac3}
\createlinenumber{2521}{95cf}
\createlinenumber{2522}{95cf}
\createlinenumber{2523}{329b}
\begin{lstlisting}[language=C++]
template <class T>
struct Frac {
    T zi;
    T mu;
    Frac(T num_, T den_) : zi(num_), mu(den_) {
        if (mu < 0) {
            mu = -mu;
            zi = -zi;
        }
    }
    Frac() : Frac(0, 1) {}  // (1/0)
    Frac(T num_) : Frac(num_, 1) {}
    void reduce() {
        T g = std::gcd(zi, mu);  // 调用 std::gcd 计算最大公约数
        zi /= g;                 // 将分子除以最大公约数
        mu /= g;                 // 将分母除以最大公约数
    }
    explicit operator double() const {
        return 1. * zi / mu;
    }
    Frac &operator+=(const Frac &rhs) {
        zi = zi * rhs.mu + rhs.zi * mu;
        mu *= rhs.mu;
        return *this;
    }
    Frac &operator-=(const Frac &rhs) {
        zi = zi * rhs.mu - rhs.zi * mu;
        mu *= rhs.mu;
        return *this;
    }
    Frac &operator*=(const Frac &rhs) {
        zi *= rhs.zi;
        mu *= rhs.mu;
        return *this;
    }
    Frac &operator/=(const Frac &rhs) {
        zi *= rhs.mu;
        mu *= rhs.zi;
        if (mu < 0) {
            zi = -zi;
            mu = -mu;
        }
        return *this;
    }
    friend Frac operator+(Frac lhs, const Frac &rhs) {
        return lhs += rhs;
    }
    friend Frac operator-(Frac lhs, const Frac &rhs) {
        return lhs -= rhs;
    }
    friend Frac operator*(Frac lhs, const Frac &rhs) {
        return lhs *= rhs;
    }
    friend Frac operator/(Frac lhs, const Frac &rhs) {
        return lhs /= rhs;
    }
    friend Frac operator-(const Frac &a) {
        return Frac(-a.zi, a.mu);
    }
    friend bool operator==(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu == rhs.zi * lhs.mu;
    }
    friend bool operator!=(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu != rhs.zi * lhs.mu;
    }
    friend bool operator<(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu < rhs.zi * lhs.mu;
    }
    friend bool operator>(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu > rhs.zi * lhs.mu;
    }
    friend bool operator<=(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu <= rhs.zi * lhs.mu;
    }
    friend bool operator>=(const Frac &lhs, const Frac &rhs) {
        return lhs.zi * rhs.mu >= rhs.zi * lhs.mu;
    }
    friend std::ostream &operator<<(std::ostream &os, Frac x) {
        T g = std::gcd(x.zi, x.mu);
        if (x.mu == g) {
            return os << x.zi / g;
        } else {
            return os << x.zi / g << "/" << x.mu / g;
        }
    }
};
\end{lstlisting}
\subsection{Gauss}
\createlinenumber{2524}{7f0d}
\createlinenumber{2525}{1b6e}
\createlinenumber{2526}{6d0f}
\createlinenumber{2527}{427e}
\createlinenumber{2528}{d963}
\createlinenumber{2529}{3f80}
\createlinenumber{2530}{81f2}
\createlinenumber{2531}{5093}
\createlinenumber{2532}{73b1}
\createlinenumber{2533}{b333}
\createlinenumber{2534}{427e}
\createlinenumber{2535}{427e}
\createlinenumber{2536}{75b8}
\createlinenumber{2537}{427e}
\createlinenumber{2538}{427e}
\createlinenumber{2539}{d414}
\createlinenumber{2540}{427e}
\createlinenumber{2541}{427e}
\createlinenumber{2542}{bcae}
\createlinenumber{2543}{28f1}
\createlinenumber{2544}{14c5}
\createlinenumber{2545}{d4d2}
\createlinenumber{2546}{07ee}
\createlinenumber{2547}{95cf}
\createlinenumber{2548}{d883}
\createlinenumber{2549}{073b}
\createlinenumber{2550}{9ca6}
\createlinenumber{2551}{7021}
\createlinenumber{2552}{95cf}
\createlinenumber{2553}{ca92}
\createlinenumber{2554}{95cf}
\createlinenumber{2555}{427e}
\createlinenumber{2556}{d7dd}
\createlinenumber{2557}{87a8}
\createlinenumber{2558}{524a}
\createlinenumber{2559}{7459}
\createlinenumber{2560}{95cf}
\createlinenumber{2561}{427e}
\createlinenumber{2562}{9627}
\createlinenumber{2563}{5c83}
\createlinenumber{2564}{e1b6}
\createlinenumber{2565}{92f2}
\createlinenumber{2566}{56cc}
\createlinenumber{2567}{aaa2}
\createlinenumber{2568}{c685}
\createlinenumber{2569}{c34b}
\createlinenumber{2570}{c743}
\createlinenumber{2571}{9922}
\createlinenumber{2572}{7566}
\createlinenumber{2573}{d6fe}
\createlinenumber{2574}{8e2e}
\createlinenumber{2575}{6dbf}
\createlinenumber{2576}{03b5}
\createlinenumber{2577}{3251}
\createlinenumber{2578}{95cf}
\createlinenumber{2579}{95cf}
\createlinenumber{2580}{95cf}
\begin{lstlisting}[language=C++]
int gauss(vector<vector<db>>& a, int n) {
    int r = 1;                      // 当前行
    for (int c = 1; c <= n; c++) {  // 消元进行到第c列
        // 1.找到c列的最大行t
        int t = r;
        for (int i = r; i <= n; i++)
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps)
            continue;  // c列已全为0

        // 2.把最大行换到上面
        for (int i = c; i <= n + 1; i++) swap(a[t][i], a[r][i]);

        // 3.把当前行r的第一个数，变成1
        for (int i = n + 1; i >= c; i--) a[r][i] /= a[r][c];

        // 4.把当前列c下面的所有数，全部消成0
        for (int i = r + 1; i <= n; i++)
            if (fabs(a[i][c]) > eps)
                for (int j = n + 1; j >= c; j--)
                    a[i][j] -= a[i][c] * a[r][j];
        r++;  // 从下一行开始消元下一列
    }
    if (r <= n) {  // 说明已经提前变成梯形矩阵
        for (int i = r; i <= n; i++) {
            if (fabs(a[i][n + 1]) > eps)
                return 0;
        }  // 左边=0，右边≠0,无解
        return 2;  // 0==0，无穷多解
    }
    // 5.唯一解，从下往上回代，得到方程的解
    for (int i = n; i >= 1; i--)
        for (int j = i + 1; j <= n; j++)
            a[i][n + 1] -= a[i][j] * a[j][n + 1];
    return 1;
}

void solve() {
    int n;
    cin >> n;
    vector b(n + 1, vector<db>(n + 2));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n + 1; j++)
            cin >> b[i][j];
    int t = gauss(b, n);
    if (t == 0) {
        cout << "No solution " << endl;
    } else if (t == 2) {
        cout << "Infinite group solutions" << endl;
    } else {
        for (int i = 1; i <= n; i++) {
            baoliu(b[i][n + 1], 2);
            cout << endl;
        }
    }
}
\end{lstlisting}
\subsection{Gauss\_matrix}
\createlinenumber{2581}{f4e8}
\createlinenumber{2582}{7a44}
\createlinenumber{2583}{1477}
\createlinenumber{2584}{37b0}
\createlinenumber{2585}{6dbf}
\createlinenumber{2586}{58c5}
\createlinenumber{2587}{dda5}
\createlinenumber{2588}{95cf}
\createlinenumber{2589}{a3f2}
\createlinenumber{2590}{95cf}
\createlinenumber{2591}{8537}
\createlinenumber{2592}{95cf}
\createlinenumber{2593}{a29d}
\createlinenumber{2594}{6297}
\createlinenumber{2595}{0e0c}
\createlinenumber{2596}{fde1}
\createlinenumber{2597}{1b6e}
\createlinenumber{2598}{0b29}
\createlinenumber{2599}{427e}
\createlinenumber{2600}{d963}
\createlinenumber{2601}{3f80}
\createlinenumber{2602}{81f2}
\createlinenumber{2603}{5093}
\createlinenumber{2604}{c5a0}
\createlinenumber{2605}{b333}
\createlinenumber{2606}{c870}
\createlinenumber{2607}{427e}
\createlinenumber{2608}{e341}
\createlinenumber{2609}{427e}
\createlinenumber{2610}{2aa1}
\createlinenumber{2611}{427e}
\createlinenumber{2612}{bcae}
\createlinenumber{2613}{28f1}
\createlinenumber{2614}{a5e5}
\createlinenumber{2615}{d4d2}
\createlinenumber{2616}{32cc}
\createlinenumber{2617}{46ba}
\createlinenumber{2618}{07ee}
\createlinenumber{2619}{95cf}
\createlinenumber{2620}{427e}
\createlinenumber{2621}{427e}
\createlinenumber{2622}{f7b6}
\createlinenumber{2623}{831e}
\createlinenumber{2624}{ed41}
\createlinenumber{2625}{427e}
\createlinenumber{2626}{6399}
\createlinenumber{2627}{073b}
\createlinenumber{2628}{0343}
\createlinenumber{2629}{7021}
\createlinenumber{2630}{95cf}
\createlinenumber{2631}{95cf}
\createlinenumber{2632}{e052}
\createlinenumber{2633}{1cd1}
\createlinenumber{2634}{427e}
\createlinenumber{2635}{0bf0}
\createlinenumber{2636}{95cf}
\createlinenumber{2637}{95cf}
\createlinenumber{2638}{427e}
\createlinenumber{2639}{84f7}
\createlinenumber{2640}{8e5f}
\createlinenumber{2641}{82c6}
\createlinenumber{2642}{b333}
\createlinenumber{2643}{2025}
\createlinenumber{2644}{95cf}
\createlinenumber{2645}{427e}
\createlinenumber{2646}{8b1a}
\createlinenumber{2647}{95cf}
\createlinenumber{2648}{f4ed}
\createlinenumber{2649}{ca92}
\createlinenumber{2650}{8e2e}
\createlinenumber{2651}{427e}
\createlinenumber{2652}{3d4b}
\createlinenumber{2653}{0ee0}
\createlinenumber{2654}{7459}
\createlinenumber{2655}{ca92}
\createlinenumber{2656}{95cf}
\createlinenumber{2657}{95cf}
\createlinenumber{2658}{9627}
\createlinenumber{2659}{35b8}
\createlinenumber{2660}{9af0}
\createlinenumber{2661}{6dbf}
\createlinenumber{2662}{8e5f}
\createlinenumber{2663}{c685}
\createlinenumber{2664}{95cf}
\createlinenumber{2665}{95cf}
\createlinenumber{2666}{c5fb}
\createlinenumber{2667}{eb78}
\createlinenumber{2668}{a0d0}
\createlinenumber{2669}{c743}
\createlinenumber{2670}{72d4}
\createlinenumber{2671}{8e2e}
\createlinenumber{2672}{0bc2}
\createlinenumber{2673}{f806}
\createlinenumber{2674}{95cf}
\createlinenumber{2675}{95cf}
\begin{lstlisting}[language=C++]
db b[N][N];  // 增广矩阵
int id[N];   // id[j]=i：表示第j列的答案最终在第i行被计算
int rid[N];  // 第i行可以算出第j列的主元
void print(int n, int m) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m + 1; j++) {
            cerr << setiosflags(ios::left) << setw(5) << b[i][j];
        }
        cerr << endl;
    }
    cerr << "---------------------" << endl;
}
int rksz;
int freenum;
vector<db> ans;
int gauss(db a[][N], int n, int m) {  // n个方程，m个未知数。默认多余自由变量为0，记录映射关系
    int r = 1;                        // 当前行
    for (int c = 1; c <= m; c++) {    // 消元进行到第c列
        // 1.找到c列的最大行t
        int t = r;
        for (int i = r; i <= n; i++)
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (t > n || fabs(a[t][c]) < eps)
            continue;  // c列已全为0
        assert(t <= n);
        // 2.把最大行换到上面
        for (int i = c; i <= m + 1; i++) swap(a[t][i], a[r][i]);
        // 3.把当前行r的第一个数，变成1
        for (int i = m + 1; i >= c; i--) a[r][i] /= a[r][c];
        // 4.把当前列c下面的所有数，全部消成0
        for (int i = r + 1; i <= n; i++)
            if (fabs(a[i][c]) > eps)
                for (int j = m + 1; j >= c; j--)
                    a[i][j] -= a[i][c] * a[r][j];
        id[c] = r;
        rid[r] = c;
        r++;  // 从下一行开始消元下一列
    }
    //---------------------------
    // print(n, m);
    rksz = r - 1;
    freenum = m - r + 1;
    ans.resize(m + 1);
    //------------------------
    if (r <= m) {  // 说明已经提前变成梯形矩阵
        for (int i = r; i <= n; i++) {
            if (fabs(a[i][m + 1]) > eps)
                return 0;  // 左边=0，右边≠0,无解
        }
    }
    for (int i = 1; i <= m; i++) {
        if (id[i] == 0) {
            // deb(i);
            ans[i] = 1;  // 如果第i列的主元没有对应行，自由变量随机赋值
        }
    }
    // 5.唯一解，从下往上回代，得到方程的解
    for (int i = rksz; i >= 1; i--) {
        for (int j = 1; j <= m; j++) {  // 左侧自由变量残余，右侧已经算出来的以及右侧自由变量
            if (j == rid[i])
                continue;
            a[i][m + 1] -= a[i][j] * ans[j];
        }
        // deb(rid[i]);
        ans[rid[i]] = a[i][m + 1];  // 第i行的主元在rid[i]列
    }
    if (m > n) {
        return 2;
    } else {
        // m<=n;
        assert(rksz <= m);
        if (rksz == m)
            return 1;
        return 2;
    }
}
void solve() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> b[i][j];
        }
    }
    for (int i = 1; i <= n; i++) cin >> b[i][m + 1];
    int t = gauss(b, n, m);  // n个方程,m个未知数
    deb(t, rksz, freenum);
    if (t == 0) {
        cout << "NO" << endl;
    } else {
        cout << "YES" << endl;
        for (int i = 1; i <= m; i++) cout << fixed << setprecision(12) << ans[i] << endl;
    }
}
\end{lstlisting}
\subsection{Gauss\_mod}
\createlinenumber{2676}{302f}
\createlinenumber{2677}{421c}
\createlinenumber{2678}{2697}
\createlinenumber{2679}{6bef}
\createlinenumber{2680}{35b8}
\createlinenumber{2681}{22f8}
\createlinenumber{2682}{b263}
\createlinenumber{2683}{96a1}
\createlinenumber{2684}{ee6f}
\createlinenumber{2685}{95cf}
\createlinenumber{2686}{da74}
\createlinenumber{2687}{06e8}
\createlinenumber{2688}{2d5c}
\createlinenumber{2689}{7021}
\createlinenumber{2690}{7459}
\createlinenumber{2691}{95cf}
\createlinenumber{2692}{851b}
\createlinenumber{2693}{46bf}
\createlinenumber{2694}{5e84}
\createlinenumber{2695}{4f2d}
\createlinenumber{2696}{95cf}
\createlinenumber{2697}{516e}
\createlinenumber{2698}{bd65}
\createlinenumber{2699}{edec}
\createlinenumber{2700}{95cf}
\createlinenumber{2701}{cc5a}
\createlinenumber{2702}{0f8b}
\createlinenumber{2703}{6d1a}
\createlinenumber{2704}{2848}
\createlinenumber{2705}{95cf}
\createlinenumber{2706}{9f5c}
\createlinenumber{2707}{1585}
\createlinenumber{2708}{6dbf}
\createlinenumber{2709}{c448}
\createlinenumber{2710}{0325}
\createlinenumber{2711}{b333}
\createlinenumber{2712}{59eb}
\createlinenumber{2713}{efdf}
\createlinenumber{2714}{a8b2}
\createlinenumber{2715}{95cf}
\createlinenumber{2716}{c467}
\createlinenumber{2717}{9891}
\createlinenumber{2718}{ede7}
\createlinenumber{2719}{859b}
\createlinenumber{2720}{b333}
\createlinenumber{2721}{5603}
\createlinenumber{2722}{95cf}
\createlinenumber{2723}{7927}
\createlinenumber{2724}{95cf}
\createlinenumber{2725}{5385}
\createlinenumber{2726}{ba29}
\createlinenumber{2727}{f25a}
\createlinenumber{2728}{2830}
\createlinenumber{2729}{f7f4}
\createlinenumber{2730}{d6e1}
\createlinenumber{2731}{50a7}
\createlinenumber{2732}{1e22}
\createlinenumber{2733}{4f2d}
\createlinenumber{2734}{95cf}
\createlinenumber{2735}{95cf}
\createlinenumber{2736}{95cf}
\createlinenumber{2737}{f832}
\createlinenumber{2738}{6dbf}
\createlinenumber{2739}{15b6}
\createlinenumber{2740}{9480}
\createlinenumber{2741}{038b}
\createlinenumber{2742}{7927}
\createlinenumber{2743}{95cf}
\createlinenumber{2744}{95cf}
\createlinenumber{2745}{3b32}
\createlinenumber{2746}{9af0}
\createlinenumber{2747}{6dbf}
\createlinenumber{2748}{28e7}
\createlinenumber{2749}{bae7}
\createlinenumber{2750}{dd62}
\createlinenumber{2751}{a763}
\createlinenumber{2752}{84b5}
\createlinenumber{2753}{1d1d}
\createlinenumber{2754}{95cf}
\createlinenumber{2755}{95cf}
\createlinenumber{2756}{0812}
\createlinenumber{2757}{6f28}
\createlinenumber{2758}{7aed}
\createlinenumber{2759}{f064}
\createlinenumber{2760}{d311}
\createlinenumber{2761}{ae1b}
\createlinenumber{2762}{6ca2}
\createlinenumber{2763}{95cf}
\createlinenumber{2764}{0c4b}
\createlinenumber{2765}{95cf}
\createlinenumber{2766}{8bf4}
\createlinenumber{2767}{7021}
\createlinenumber{2768}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 205;
int n, m;
int s[N], t[N], G[N][N];
int a[N][N];
void swap_line(int x, int y) {
    for (int i = 1; i <= n + 1; i++) swap(a[x][i], a[y][i]);
}
bool empty_line(int x, int y) {
    for (int i = x; i <= n; i++)
        if (a[i][y])
            return 0;
    return 1;
}
void exgcd(int n, int m, int &x, int &y) {
    if (m == 0) {
        x = 1, y = 0;
        return;
    }
    int x1, y1;
    exgcd(m, n % m, x1, y1);
    x = y1, y = x1 - n / m * y1;
}
int get_inv(int p) {
    int x, y;
    exgcd(p, m, x, y);
    return (x % m + m) % m;
}
void gauss() {
    int hang = 1, pos;
    for (int i = 1; i <= n; i++) {
        pos = hang;
        if (empty_line(pos, i))
            continue;
        for (int j = hang; j <= n; j++) {
            if (a[j][i] > a[pos][i])
                pos = j;
        }
        swap_line(hang, pos);
        int op = get_inv(a[hang][i]);
        for (int j = 1; j <= n; j++) {
            if (hang == j)
                continue;
            for (int k = n + 1; k >= i; k--) a[j][k] = (a[j][k] - (a[hang][k] * a[j][i] % m + m) % m * op % m + m) % m;
        }
        hang++;
    }
    if (hang <= n) {
        for (int i = hang; i <= n; i++) {
            bool flag = 0;
            for (int j = 1; j <= n; j++)
                if (a[i][j])
                    flag = 1;
            if (!flag && a[i][n + 1]) {
                cout << "niuza";
                return;
            }
        }
    }
    hang = 1;
    for (int i = 1; i <= n; i++) {
        cout << a[hang][n + 1] * get_inv(a[hang][i]) % m << " ";
        a[hang][n + 1] = 0;
        if (!a[hang][i + 1])
            hang++;
    }
}
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int k;
        cin >> k;
        for (int j = 1; j <= k; j++) {
            int u;
            cin >> u;
            G[i][u] = 1;
        }
    }
    for (int i = 1; i <= n; i++) cin >> s[i];
    for (int i = 1; i <= n; i++) cin >> t[i];
    for (int u = 1; u <= n; u++) {
        a[u][u] = 1;  //!@!!!
        for (int v = 1; v <= n; v++) {
            if (G[v][u])
                a[u][v] = 1;
        }
        a[u][n + 1] = ((t[u] - s[u]) % m + m) % m;
    }
    gauss();
    return 0;
}
\end{lstlisting}
\subsection{Gauss\_xor}
\createlinenumber{2769}{8094}
\createlinenumber{2770}{2be0}
\createlinenumber{2771}{c8a5}
\createlinenumber{2772}{d1c5}
\createlinenumber{2773}{3355}
\createlinenumber{2774}{427e}
\createlinenumber{2775}{1b6e}
\createlinenumber{2776}{6d0f}
\createlinenumber{2777}{d963}
\createlinenumber{2778}{427e}
\createlinenumber{2779}{073b}
\createlinenumber{2780}{5c61}
\createlinenumber{2781}{5093}
\createlinenumber{2782}{6173}
\createlinenumber{2783}{95cf}
\createlinenumber{2784}{95cf}
\createlinenumber{2785}{2480}
\createlinenumber{2786}{0be2}
\createlinenumber{2787}{b333}
\createlinenumber{2788}{95cf}
\createlinenumber{2789}{939c}
\createlinenumber{2790}{be30}
\createlinenumber{2791}{fb89}
\createlinenumber{2792}{2079}
\createlinenumber{2793}{95cf}
\createlinenumber{2794}{427e}
\createlinenumber{2795}{3a3c}
\createlinenumber{2796}{9fc4}
\createlinenumber{2797}{16d6}
\createlinenumber{2798}{95cf}
\createlinenumber{2799}{07ee}
\createlinenumber{2800}{95cf}
\createlinenumber{2801}{427e}
\createlinenumber{2802}{427e}
\createlinenumber{2803}{073b}
\createlinenumber{2804}{6c28}
\createlinenumber{2805}{7021}
\createlinenumber{2806}{95cf}
\createlinenumber{2807}{427e}
\createlinenumber{2808}{4289}
\createlinenumber{2809}{427e}
\createlinenumber{2810}{4aea}
\createlinenumber{2811}{427e}
\createlinenumber{2812}{84f7}
\createlinenumber{2813}{737e}
\createlinenumber{2814}{ede7}
\createlinenumber{2815}{dfd6}
\createlinenumber{2816}{b333}
\createlinenumber{2817}{95cf}
\createlinenumber{2818}{1f31}
\createlinenumber{2819}{95cf}
\createlinenumber{2820}{f505}
\createlinenumber{2821}{95cf}
\createlinenumber{2822}{0566}
\createlinenumber{2823}{ba31}
\createlinenumber{2824}{ca92}
\createlinenumber{2825}{7459}
\createlinenumber{2826}{95cf}
\createlinenumber{2827}{427e}
\begin{lstlisting}[language=C++]
异或线性方程组就是常数项和各变量系数都是0/1，
并且各变量取值也是0/1
 gauss(vector<vector<int>>& a, int n, vector<int>& solution) {
    vector<int> freevar;           // 记录自由变量对应的列
    vector<int> pivot(n + 1, -1);  // 记录每一行的主元所在的列
    //solution.assign(n + 1, 0);
    int r = 1;
    for (int c = 1; c <= n; c++) {
        int t = r;
        // 找到当前列中的主元
        for (int i = r; i <= n; i++) {
            if (a[i][c]) {
                t = i;
                break;
            }
        }
        if (!a[t][c]) {
            freevar.push_back(c);
            continue;  // 当前列没有主元，继续到下一列
        }
        pivot[r] = c;  // 第 r 行的主元在 c 列
        if (t != r) {  // 交换行，将主元行放在第 r 行
            for (int i = c; i <= n + 1; i++)
                swap(a[r][i], a[t][i]);
        }
        // 消去主元下方的所有行
        for (int i = r + 1; i <= n; i++) {
            if (a[i][c])
                for (int j = n + 1; j >= c; j--) a[i][j] ^= a[r][j];
        }
        r++;
    }

    // 检查是否有解
    for (int i = r; i <= n; i++) {
        if (a[i][n + 1])
            return 0;  // 无解
    }
    //int tot = 0;
    int rksz = r - 1;  // 这是系数矩阵的秩
    // 自由变量根据题目要求情况去赋值
    for (auto i : freevar) solution[i] =0;
    //------------------------------
    for (int i = rksz; i >= 1; i--) {
        int sum = a[i][n + 1];
        for (int j = 1; j <= n; j++) {
            if (j == pivot[i]) {
                continue;
            }  // 如果不是主元所在的列
            sum ^= (a[i][j] * solution[j]);  // 右边已经求出来的，左边自由变量遗留
        }
        solution[pivot[i]] = sum;  // 求解对应的主元变量
    }
    assert(rksz <= n);
    if (rksz < n)
        return 2;  // 无穷多解
    return 1;      // 唯一解
}
// int t = gauss(b, n, sol);
\end{lstlisting}
\subsection{Gauss\_xor\_bitset}
\createlinenumber{2828}{a29d}
\createlinenumber{2829}{427e}
\createlinenumber{2830}{4ceb}
\createlinenumber{2831}{5065}
\createlinenumber{2832}{d1c5}
\createlinenumber{2833}{3355}
\createlinenumber{2834}{1b6e}
\createlinenumber{2835}{0b29}
\createlinenumber{2836}{d963}
\createlinenumber{2837}{427e}
\createlinenumber{2838}{073b}
\createlinenumber{2839}{5c61}
\createlinenumber{2840}{5093}
\createlinenumber{2841}{6173}
\createlinenumber{2842}{95cf}
\createlinenumber{2843}{95cf}
\createlinenumber{2844}{489b}
\createlinenumber{2845}{0be2}
\createlinenumber{2846}{b333}
\createlinenumber{2847}{95cf}
\createlinenumber{2848}{939c}
\createlinenumber{2849}{be30}
\createlinenumber{2850}{ebd2}
\createlinenumber{2851}{95cf}
\createlinenumber{2852}{427e}
\createlinenumber{2853}{3a3c}
\createlinenumber{2854}{9fc4}
\createlinenumber{2855}{e906}
\createlinenumber{2856}{95cf}
\createlinenumber{2857}{07ee}
\createlinenumber{2858}{95cf}
\createlinenumber{2859}{427e}
\createlinenumber{2860}{427e}
\createlinenumber{2861}{073b}
\createlinenumber{2862}{4e0e}
\createlinenumber{2863}{7021}
\createlinenumber{2864}{95cf}
\createlinenumber{2865}{427e}
\createlinenumber{2866}{f7b6}
\createlinenumber{2867}{427e}
\createlinenumber{2868}{4aea}
\createlinenumber{2869}{427e}
\createlinenumber{2870}{84f7}
\createlinenumber{2871}{fb1f}
\createlinenumber{2872}{8e5f}
\createlinenumber{2873}{dfd6}
\createlinenumber{2874}{b333}
\createlinenumber{2875}{95cf}
\createlinenumber{2876}{1f31}
\createlinenumber{2877}{95cf}
\createlinenumber{2878}{f505}
\createlinenumber{2879}{95cf}
\createlinenumber{2880}{427e}
\createlinenumber{2881}{ce16}
\createlinenumber{2882}{ca92}
\createlinenumber{2883}{7459}
\createlinenumber{2884}{95cf}
\createlinenumber{2885}{427e}
\begin{lstlisting}[language=C++]
int rksz;
// 还需要处理m方程，n变量，m>n
#define bit(x) bitset<(x)>
int gauss(vector<bit(5002)>& a, int n, int m, vector<int>& solution) {
    vector<int> freevar;           // 记录自由变量对应的列
    vector<int> pivot(n + 1, -1);  // 记录每一行的主元所在的列
    int r = 1;
    for (int c = 1; c <= m; c++) {
        int t = r;
        // 找到当前列中的主元
        for (int i = r; i <= n; i++) {
            if (a[i][c]) {
                t = i;
                break;
            }
        }
        if (t > n || !a[t][c]) {
            freevar.push_back(c);
            continue;  // 当前列没有主元，继续到下一列
        }
        pivot[r] = c;  // 第 r 行的主元在 c 列
        if (t != r) {  // 交换行，将主元行放在第 r 行
            swap(a[r], a[t]);
        }
        // 消去主元下方的所有行
        for (int i = r + 1; i <= n; i++) {
            if (a[i][c])
                a[i] ^= a[r];
        }
        r++;
    }

    // 检查是否有解
    for (int i = r; i <= n; i++) {
        if (a[i][m + 1])
            return 0;  // 无解
    }
    // int tot = 0;
    rksz = r - 1;  // 这是系数矩阵的秩
    // 自由变量根据题目要求情况去赋值
    for (auto i : freevar) solution[i] = 0;
    //------------------------------
    for (int i = rksz; i >= 1; i--) {
        int sum = a[i][m + 1];
        for (int j = 1; j <= m; j++) {
            if (j == pivot[i]) {
                continue;
            }  // 如果不是主元所在的列
            sum ^= (a[i][j] * solution[j]);  // 右边已经求出来的，左边自由变量遗留
        }
        solution[pivot[i]] = sum;  // 求解对应的主元变量
    }
    // assert(rksz <= m);
    if (rksz < m)
        return 2;  // 无穷多解
    return 1;      // 唯一解
}
// int t = gauss(b, n，m, sol);
\end{lstlisting}
\subsection{Gauss\_xor\_matrix}
\createlinenumber{2886}{a29d}
\createlinenumber{2887}{427e}
\createlinenumber{2888}{7a28}
\createlinenumber{2889}{d1c5}
\createlinenumber{2890}{3355}
\createlinenumber{2891}{1b6e}
\createlinenumber{2892}{0b29}
\createlinenumber{2893}{d963}
\createlinenumber{2894}{427e}
\createlinenumber{2895}{073b}
\createlinenumber{2896}{5c61}
\createlinenumber{2897}{5093}
\createlinenumber{2898}{6173}
\createlinenumber{2899}{95cf}
\createlinenumber{2900}{95cf}
\createlinenumber{2901}{427e}
\createlinenumber{2902}{427e}
\createlinenumber{2903}{427e}
\createlinenumber{2904}{427e}
\createlinenumber{2905}{489b}
\createlinenumber{2906}{0be2}
\createlinenumber{2907}{b333}
\createlinenumber{2908}{95cf}
\createlinenumber{2909}{939c}
\createlinenumber{2910}{be30}
\createlinenumber{2911}{9199}
\createlinenumber{2912}{2079}
\createlinenumber{2913}{95cf}
\createlinenumber{2914}{427e}
\createlinenumber{2915}{3a3c}
\createlinenumber{2916}{9fc4}
\createlinenumber{2917}{ca34}
\createlinenumber{2918}{95cf}
\createlinenumber{2919}{07ee}
\createlinenumber{2920}{95cf}
\createlinenumber{2921}{427e}
\createlinenumber{2922}{427e}
\createlinenumber{2923}{073b}
\createlinenumber{2924}{4e0e}
\createlinenumber{2925}{7021}
\createlinenumber{2926}{95cf}
\createlinenumber{2927}{427e}
\createlinenumber{2928}{f7b6}
\createlinenumber{2929}{427e}
\createlinenumber{2930}{4aea}
\createlinenumber{2931}{427e}
\createlinenumber{2932}{84f7}
\createlinenumber{2933}{fb1f}
\createlinenumber{2934}{8e5f}
\createlinenumber{2935}{dfd6}
\createlinenumber{2936}{b333}
\createlinenumber{2937}{95cf}
\createlinenumber{2938}{1f31}
\createlinenumber{2939}{95cf}
\createlinenumber{2940}{f505}
\createlinenumber{2941}{95cf}
\createlinenumber{2942}{427e}
\createlinenumber{2943}{ce16}
\createlinenumber{2944}{ca92}
\createlinenumber{2945}{7459}
\createlinenumber{2946}{95cf}
\createlinenumber{2947}{427e}
\begin{lstlisting}[language=C++]
int rksz;
// 还没有处理n方程，m变量的情况(n>m)
int gauss(vector<vector<int>>& a, int n, int m, vector<int>& solution) {
    vector<int> freevar;           // 记录自由变量对应的列
    vector<int> pivot(n + 1, -1);  // 记录每一行的主元所在的列
    int r = 1;
    for (int c = 1; c <= m; c++) {
        int t = r;
        // 找到当前列中的主元
        for (int i = r; i <= n; i++) {
            if (a[i][c]) {
                t = i;
                break;
            }
        }
        // if (t > n)
        //     deb(t, n, c, m);
        // assert(t <= n);
        // assert(c <= m);
        if (t > n || !a[t][c]) {
            freevar.push_back(c);
            continue;  // 当前列没有主元，继续到下一列
        }
        pivot[r] = c;  // 第 r 行的主元在 c 列
        if (t != r) {  // 交换行，将主元行放在第 r 行
            for (int i = c; i <= m + 1; i++)
                swap(a[r][i], a[t][i]);
        }
        // 消去主元下方的所有行
        for (int i = r + 1; i <= n; i++) {
            if (a[i][c])
                for (int j = m + 1; j >= c; j--) a[i][j] ^= a[r][j];
        }
        r++;
    }

    // 检查是否有解
    for (int i = r; i <= n; i++) {
        if (a[i][m + 1])
            return 0;  // 无解
    }
    // int tot = 0;
    rksz = r - 1;  // 这是系数矩阵的秩
    // 自由变量根据题目要求情况去赋值
    for (auto i : freevar) solution[i] = 0;
    //------------------------------
    for (int i = rksz; i >= 1; i--) {
        int sum = a[i][m + 1];
        for (int j = 1; j <= m; j++) {
            if (j == pivot[i]) {
                continue;
            }  // 如果不是主元所在的列
            sum ^= (a[i][j] * solution[j]);  // 右边已经求出来的，左边自由变量遗留
        }
        solution[pivot[i]] = sum;  // 求解对应的主元变量
    }
    // assert(rksz <= m);
    if (rksz < m)
        return 2;  // 无穷多解
    return 1;      // 唯一解
}
// int t = gauss(b, n，m, sol);
\end{lstlisting}
\subsection{Miller\_Robin}
\createlinenumber{2948}{3c92}
\createlinenumber{2949}{ee66}
\createlinenumber{2950}{a4b3}
\createlinenumber{2951}{95cf}
\createlinenumber{2952}{9a69}
\createlinenumber{2953}{fa68}
\createlinenumber{2954}{a386}
\createlinenumber{2955}{6f75}
\createlinenumber{2956}{e72c}
\createlinenumber{2957}{244d}
\createlinenumber{2958}{95cf}
\createlinenumber{2959}{b6c3}
\createlinenumber{2960}{a4d9}
\createlinenumber{2961}{438e}
\createlinenumber{2962}{043a}
\createlinenumber{2963}{d77a}
\createlinenumber{2964}{f9a3}
\createlinenumber{2965}{acb2}
\createlinenumber{2966}{32fb}
\createlinenumber{2967}{3361}
\createlinenumber{2968}{5415}
\createlinenumber{2969}{d97e}
\createlinenumber{2970}{b333}
\createlinenumber{2971}{0996}
\createlinenumber{2972}{22b4}
\createlinenumber{2973}{9d44}
\createlinenumber{2974}{d216}
\createlinenumber{2975}{048a}
\createlinenumber{2976}{6173}
\createlinenumber{2977}{95cf}
\createlinenumber{2978}{95cf}
\createlinenumber{2979}{9449}
\createlinenumber{2980}{438e}
\createlinenumber{2981}{95cf}
\createlinenumber{2982}{3361}
\createlinenumber{2983}{95cf}
\begin{lstlisting}[language=C++]
using i64 = long long;
i64 mul(i64 a, i64 b, i64 m) {
    return static_cast<__int128>(a) * b % m;
}
i64 power(i64 a, i64 b, i64 m) {
    i64 res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m))
        if (b & 1)
            res = mul(res, a, m);
    return res;
}
bool isprime(i64 n) {
    if (n < 2)
        return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    int s = __builtin_ctzll(n - 1);
    i64 d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n)
            return true;
        i64 x = power(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool ok = false;
        for (int i = 0; i < s - 1; ++i) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok)
            return false;
    }
    return true;
}
\end{lstlisting}
\subsection{bigint}
\createlinenumber{2984}{fad9}
\createlinenumber{2985}{5bf2}
\createlinenumber{2986}{427e}
\createlinenumber{2987}{427e}
\createlinenumber{2988}{30f0}
\createlinenumber{2989}{427e}
\createlinenumber{2990}{e81d}
\createlinenumber{2991}{427e}
\createlinenumber{2992}{ccc5}
\createlinenumber{2993}{427e}
\createlinenumber{2994}{0703}
\createlinenumber{2995}{cb0d}
\createlinenumber{2996}{0d7a}
\createlinenumber{2997}{6f75}
\createlinenumber{2998}{7b3d}
\createlinenumber{2999}{244d}
\createlinenumber{3000}{95cf}
\createlinenumber{3001}{427e}
\createlinenumber{3002}{323f}
\createlinenumber{3003}{4a30}
\createlinenumber{3004}{1a53}
\createlinenumber{3005}{427e}
\createlinenumber{3006}{058c}
\createlinenumber{3007}{427e}
\createlinenumber{3008}{d34f}
\createlinenumber{3009}{dbfa}
\createlinenumber{3010}{9de8}
\createlinenumber{3011}{7a76}
\createlinenumber{3012}{541f}
\createlinenumber{3013}{8c68}
\createlinenumber{3014}{86bb}
\createlinenumber{3015}{f699}
\createlinenumber{3016}{95cf}
\createlinenumber{3017}{bed1}
\createlinenumber{3018}{c018}
\createlinenumber{3019}{5de2}
\createlinenumber{3020}{95cf}
\createlinenumber{3021}{95cf}
\createlinenumber{3022}{427e}
\createlinenumber{3023}{3fa8}
\createlinenumber{3024}{8231}
\createlinenumber{3025}{9670}
\createlinenumber{3026}{ba79}
\createlinenumber{3027}{9753}
\createlinenumber{3028}{fea4}
\createlinenumber{3029}{20ad}
\createlinenumber{3030}{fe76}
\createlinenumber{3031}{4f98}
\createlinenumber{3032}{5fbd}
\createlinenumber{3033}{4257}
\createlinenumber{3034}{95cf}
\createlinenumber{3035}{95cf}
\createlinenumber{3036}{95cf}
\createlinenumber{3037}{2379}
\createlinenumber{3038}{e54a}
\createlinenumber{3039}{95cf}
\createlinenumber{3040}{95cf}
\createlinenumber{3041}{427e}
\createlinenumber{3042}{549b}
\createlinenumber{3043}{3f00}
\createlinenumber{3044}{9670}
\createlinenumber{3045}{ba79}
\createlinenumber{3046}{5e09}
\createlinenumber{3047}{fea4}
\createlinenumber{3048}{4da2}
\createlinenumber{3049}{fe76}
\createlinenumber{3050}{4f98}
\createlinenumber{3051}{ce9b}
\createlinenumber{3052}{81a4}
\createlinenumber{3053}{95cf}
\createlinenumber{3054}{95cf}
\createlinenumber{3055}{95cf}
\createlinenumber{3056}{d596}
\createlinenumber{3057}{5bff}
\createlinenumber{3058}{2379}
\createlinenumber{3059}{2fbb}
\createlinenumber{3060}{e73f}
\createlinenumber{3061}{e54a}
\createlinenumber{3062}{95cf}
\createlinenumber{3063}{95cf}
\createlinenumber{3064}{95cf}
\createlinenumber{3065}{427e}
\createlinenumber{3066}{991b}
\createlinenumber{3067}{7739}
\createlinenumber{3068}{9222}
\createlinenumber{3069}{43c1}
\createlinenumber{3070}{0286}
\createlinenumber{3071}{c536}
\createlinenumber{3072}{427e}
\createlinenumber{3073}{6855}
\createlinenumber{3074}{a69f}
\createlinenumber{3075}{54f3}
\createlinenumber{3076}{c189}
\createlinenumber{3077}{67b5}
\createlinenumber{3078}{95cf}
\createlinenumber{3079}{427e}
\createlinenumber{3080}{b4bb}
\createlinenumber{3081}{0f36}
\createlinenumber{3082}{f8c6}
\createlinenumber{3083}{9630}
\createlinenumber{3084}{95cf}
\createlinenumber{3085}{427e}
\createlinenumber{3086}{fb0f}
\createlinenumber{3087}{fdf9}
\createlinenumber{3088}{4960}
\createlinenumber{3089}{95cf}
\createlinenumber{3090}{95cf}
\createlinenumber{3091}{427e}
\createlinenumber{3092}{1126}
\createlinenumber{3093}{42af}
\createlinenumber{3094}{95cf}
\createlinenumber{3095}{427e}
\createlinenumber{3096}{43d2}
\createlinenumber{3097}{dba5}
\createlinenumber{3098}{5fb4}
\createlinenumber{3099}{22a7}
\createlinenumber{3100}{a92c}
\createlinenumber{3101}{95cf}
\createlinenumber{3102}{427e}
\createlinenumber{3103}{5f56}
\createlinenumber{3104}{8eea}
\createlinenumber{3105}{7094}
\createlinenumber{3106}{a109}
\createlinenumber{3107}{b333}
\createlinenumber{3108}{880d}
\createlinenumber{3109}{4482}
\createlinenumber{3110}{95cf}
\createlinenumber{3111}{e5df}
\createlinenumber{3112}{0825}
\createlinenumber{3113}{b20e}
\createlinenumber{3114}{95cf}
\createlinenumber{3115}{329b}
\createlinenumber{3116}{427e}
\createlinenumber{3117}{427e}
\createlinenumber{3118}{4b94}
\createlinenumber{3119}{b917}
\createlinenumber{3120}{9e63}
\createlinenumber{3121}{c74f}
\createlinenumber{3122}{9d24}
\createlinenumber{3123}{c036}
\createlinenumber{3124}{438e}
\createlinenumber{3125}{95cf}
\createlinenumber{3126}{427e}
\createlinenumber{3127}{a5ba}
\createlinenumber{3128}{8d34}
\createlinenumber{3129}{95cf}
\createlinenumber{3130}{427e}
\createlinenumber{3131}{949a}
\createlinenumber{3132}{9846}
\createlinenumber{3133}{95cf}
\createlinenumber{3134}{427e}
\createlinenumber{3135}{1884}
\createlinenumber{3136}{54fd}
\createlinenumber{3137}{95cf}
\createlinenumber{3138}{427e}
\createlinenumber{3139}{9571}
\createlinenumber{3140}{3e48}
\createlinenumber{3141}{95cf}
\createlinenumber{3142}{427e}
\createlinenumber{3143}{08ba}
\createlinenumber{3144}{776c}
\createlinenumber{3145}{95cf}
\createlinenumber{3146}{427e}
\createlinenumber{3147}{427e}
\createlinenumber{3148}{52f1}
\createlinenumber{3149}{75bf}
\createlinenumber{3150}{044b}
\createlinenumber{3151}{2f70}
\createlinenumber{3152}{7ada}
\createlinenumber{3153}{8831}
\createlinenumber{3154}{2fa2}
\createlinenumber{3155}{4572}
\createlinenumber{3156}{95cf}
\createlinenumber{3157}{bf0a}
\createlinenumber{3158}{d817}
\createlinenumber{3159}{95cf}
\createlinenumber{3160}{ba62}
\createlinenumber{3161}{a7d4}
\createlinenumber{3162}{95cf}
\createlinenumber{3163}{b2c9}
\createlinenumber{3164}{244d}
\createlinenumber{3165}{95cf}
\createlinenumber{3166}{427e}
\createlinenumber{3167}{427e}
\createlinenumber{3168}{de23}
\createlinenumber{3169}{0f14}
\createlinenumber{3170}{c53f}
\createlinenumber{3171}{8eb8}
\createlinenumber{3172}{b426}
\createlinenumber{3173}{ab5d}
\createlinenumber{3174}{57ae}
\createlinenumber{3175}{1321}
\createlinenumber{3176}{d960}
\createlinenumber{3177}{7ce4}
\createlinenumber{3178}{b19a}
\createlinenumber{3179}{95cf}
\createlinenumber{3180}{037f}
\createlinenumber{3181}{1494}
\createlinenumber{3182}{6efa}
\createlinenumber{3183}{95cf}
\createlinenumber{3184}{95cf}
\createlinenumber{3185}{b2c9}
\createlinenumber{3186}{244d}
\createlinenumber{3187}{95cf}
\createlinenumber{3188}{427e}
\createlinenumber{3189}{427e}
\createlinenumber{3190}{c9fa}
\createlinenumber{3191}{75bf}
\createlinenumber{3192}{1522}
\createlinenumber{3193}{a2ee}
\createlinenumber{3194}{333a}
\createlinenumber{3195}{8980}
\createlinenumber{3196}{09e2}
\createlinenumber{3197}{fcd9}
\createlinenumber{3198}{c0de}
\createlinenumber{3199}{b420}
\createlinenumber{3200}{88dc}
\createlinenumber{3201}{cac3}
\createlinenumber{3202}{8964}
\createlinenumber{3203}{06b2}
\createlinenumber{3204}{4f80}
\createlinenumber{3205}{8861}
\createlinenumber{3206}{7d38}
\createlinenumber{3207}{70ff}
\createlinenumber{3208}{ba62}
\createlinenumber{3209}{a7d4}
\createlinenumber{3210}{95cf}
\createlinenumber{3211}{b2c9}
\createlinenumber{3212}{244d}
\createlinenumber{3213}{95cf}
\createlinenumber{3214}{427e}
\createlinenumber{3215}{427e}
\createlinenumber{3216}{bc4b}
\createlinenumber{3217}{0f14}
\createlinenumber{3218}{b0c6}
\createlinenumber{3219}{c1eb}
\createlinenumber{3220}{93a2}
\createlinenumber{3221}{f409}
\createlinenumber{3222}{4325}
\createlinenumber{3223}{95cf}
\createlinenumber{3224}{cb55}
\createlinenumber{3225}{9a92}
\createlinenumber{3226}{4325}
\createlinenumber{3227}{95cf}
\createlinenumber{3228}{244d}
\createlinenumber{3229}{95cf}
\createlinenumber{3230}{427e}
\createlinenumber{3231}{427e}
\createlinenumber{3232}{5265}
\createlinenumber{3233}{b0c6}
\createlinenumber{3234}{e7ec}
\createlinenumber{3235}{7021}
\createlinenumber{3236}{8e9a}
\createlinenumber{3237}{07d9}
\createlinenumber{3238}{02f2}
\createlinenumber{3239}{c93c}
\createlinenumber{3240}{f140}
\createlinenumber{3241}{95cf}
\createlinenumber{3242}{d401}
\createlinenumber{3243}{5048}
\createlinenumber{3244}{a9e4}
\createlinenumber{3245}{4b95}
\createlinenumber{3246}{5a34}
\createlinenumber{3247}{558c}
\createlinenumber{3248}{81d6}
\createlinenumber{3249}{4d28}
\createlinenumber{3250}{97d8}
\createlinenumber{3251}{28ec}
\createlinenumber{3252}{8586}
\createlinenumber{3253}{d878}
\createlinenumber{3254}{64c0}
\createlinenumber{3255}{95cf}
\createlinenumber{3256}{95cf}
\createlinenumber{3257}{9559}
\createlinenumber{3258}{69ff}
\createlinenumber{3259}{95cf}
\createlinenumber{3260}{95cf}
\createlinenumber{3261}{fb02}
\createlinenumber{3262}{4206}
\createlinenumber{3263}{95cf}
\createlinenumber{3264}{427e}
\createlinenumber{3265}{427e}
\createlinenumber{3266}{cc1b}
\createlinenumber{3267}{d401}
\createlinenumber{3268}{c873}
\createlinenumber{3269}{7c08}
\createlinenumber{3270}{901e}
\createlinenumber{3271}{442e}
\createlinenumber{3272}{aff4}
\createlinenumber{3273}{95cf}
\createlinenumber{3274}{21e1}
\createlinenumber{3275}{fb02}
\createlinenumber{3276}{4206}
\createlinenumber{3277}{95cf}
\createlinenumber{3278}{427e}
\createlinenumber{3279}{427e}
\createlinenumber{3280}{c8e2}
\createlinenumber{3281}{4551}
\createlinenumber{3282}{9f98}
\createlinenumber{3283}{95cf}
\createlinenumber{3284}{427e}
\createlinenumber{3285}{427e}
\createlinenumber{3286}{5cde}
\createlinenumber{3287}{4551}
\createlinenumber{3288}{9f98}
\createlinenumber{3289}{95cf}
\createlinenumber{3290}{427e}
\createlinenumber{3291}{427e}
\createlinenumber{3292}{735a}
\createlinenumber{3293}{8c2b}
\createlinenumber{3294}{e290}
\createlinenumber{3295}{f13a}
\createlinenumber{3296}{adae}
\createlinenumber{3297}{f9f7}
\createlinenumber{3298}{95cf}
\createlinenumber{3299}{244d}
\createlinenumber{3300}{95cf}
\createlinenumber{3301}{427e}
\createlinenumber{3302}{427e}
\createlinenumber{3303}{11da}
\createlinenumber{3304}{ac7f}
\createlinenumber{3305}{95f9}
\createlinenumber{3306}{1ac4}
\createlinenumber{3307}{244d}
\createlinenumber{3308}{95cf}
\createlinenumber{3309}{427e}
\begin{lstlisting}[language=C++]
using uint = unsigned;
const int MOD = 998244353; // NTT模数

// 模加法
int Add(int x, int y) { return (x + y >= MOD) ? x + y - MOD : x + y; }
// 模减法
int Dec(int x, int y) { return (x - y < 0) ? x - y + MOD : x - y; }
// 模乘法
int mul(int x, int y) { return 1ll * x * y % MOD; }
// 快速幂计算
uint qp(uint a, int b) { 
    uint res = 1; 
    for (; b; b >>= 1, a = mul(a, a))  
        if (b & 1)  
            res = mul(res, a); 
    return res; 
}

namespace NTT {
    int sz; // FFT大小
    uint w[2500005], w_mf[2500005]; // 存储预计算的单位根及其乘法因子
    // 计算乘法因子
    int mf(int x) { return (1ll * x << 32) / MOD; }
    // 初始化NTT
    void init(int n) {
        for (sz = 2; sz < n; sz <<= 1);
        uint pr = qp(3, (MOD - 1) / sz);
        w[sz / 2] = 1; 
        w_mf[sz / 2] = mf(1);
        for (int i = 1; i < sz / 2; i++) {
            w[sz / 2 + i] = mul(w[sz / 2 + i - 1], pr);
            w_mf[sz / 2 + i] = mf(w[sz / 2 + i]);
        }
        for (int i = sz / 2 - 1; i; i--) {
            w[i] = w[i << 1];
            w_mf[i] = w_mf[i << 1];
        }
    }
    // 前向NTT
    void ntt(vector<uint>& A, int L) {
        for (int d = L >> 1; d; d >>= 1) {
            for (int i = 0; i < L; i += (d << 1)) {
                for (int j = 0; j < d; j++) {
                    uint x = A[i + j] + A[i + d + j];
                    if (x >= 2 * MOD) x -= 2 * MOD;
                    ll t = A[i + j] + 2 * MOD - A[i + d + j];
                    ll q = t * w_mf[d + j] >> 32; 
                    int y = t * w[d + j] - q * MOD;
                    A[i + j] = x; 
                    A[i + d + j] = y;
                }
            }
        }
        for (int i = 0; i < L; i++) {
            if (A[i] >= MOD) A[i] -= MOD;
        }
    }
    // 逆NTT
    void intt(vector<uint>& A, int L) {
        for (int d = 1; d < L; d <<= 1) {
            for (int i = 0; i < L; i += (d << 1)) {
                for (int j = 0; j < d; j++) {
                    uint x = A[i + j]; 
                    if (x >= 2 * MOD) x -= 2 * MOD;
                    ll t = A[i + d + j];
                    ll q = t * w_mf[d + j] >> 32;
                    int y = t * w[d + j] - q * MOD;
                    A[i + j] = x + y; 
                    A[i + d + j] = x + 2 * MOD - y;
                }
            }
        }
        int k = (L & (-L));
        reverse(A.begin() + 1, A.end());
        for (int i = 0; i < L; i++) {
            ll m = -A[i] & (L - 1);
            A[i] = (A[i] + m * MOD) / k;
            if (A[i] >= MOD) A[i] -= MOD;
        }
    }
}

struct bigint {
    vector<int> nums; // 存储大整数的每一位
    int operator[](const int& k)const { return nums[k]; }
    int& operator[](const int& k) { return nums[k]; }
    int size() { return nums.size(); }
    void push_back(int x) { nums.push_back(x); }
    // 从整数构造大整数
    bigint(int x = 0) {
        do {
            nums.push_back(x % 10);
            x /= 10;
        } while (x);
    }
    // 从字符串构造大整数
    bigint(string s) {
        for (int i = s.size() - 1; i >= 0; i--)
            nums.push_back(s[i] - '0');
        trim();
    }
    // 去掉多余的前导零
    void trim() {
        while (nums.size() > 1 && nums.back() == 0) {
            nums.pop_back();
        }
    }
    // 清空大整数
    void clear() {
        nums.clear();
    }
    // 输入大整数
    friend istream& operator>>(istream& cin, bigint& num) {
        string tnum;
        cin >> tnum;
        num = tnum;
        return cin;
    }
    // 输出大整数
    friend ostream& operator<<(ostream& cout, bigint num) {
        bool start = false;
        for (int i = num.size() - 1; i >= 0; i--) {
            if (!start && num[i] == 0)
                continue;
            start = true;
            cout << num[i];
        }
        if (!start)
            cout << 0;
        return cout;
    }
};

// 比较运算符重载
bool operator<(bigint a, bigint b) {
    if (a.size() != b.size())
        return a.size() < b.size();
    for (int i = a.size() - 1; i >= 0; i--)
        if (a[i] != b[i])
            return a[i] < b[i];
    return false;
}

bool operator>(bigint a, bigint b) {
    return b < a;
}

bool operator<=(bigint a, bigint b) {
    return !(a > b);
}

bool operator>=(bigint a, bigint b) {
    return !(a < b);
}

bool operator==(bigint a, bigint b) {
    return !(a < b) && !(a > b);
}

bool operator!=(bigint a, bigint b) {
    return a < b || a > b;
}

// 大整数加法
bigint operator+(bigint a, bigint b) {
    bigint res;
    res.clear();
    int t = 0;
    int mx = max(a.size(), b.size());
    for (int i = 0; i < mx || t; i++) {
        if (i < a.size()) {
            t += a[i];
        }
        if (i < b.size()) {
            t += b[i];
        }
        res.push_back(t % 10);
        t /= 10;
    }
    res.trim();
    return res;
}

// 大整数减法
bigint operator-(bigint a, bigint b) {
    bigint res(a);
    bigint sub(b);
    int flag = 0;
    int len = res.size();
    while (sub.size() < res.size())
        sub.push_back(0);
    for (int i = 0; i < len; i++) {
        if (res[i] + flag >= sub[i]) {
            res[i] = res[i] + flag - sub[i];
            flag = 0;
        }
        else {
            res[i] = res[i] + 10 + flag - sub[i];
            flag = -1;
        }
    }
    res.trim();
    return res;
}

// 大整数乘法（nlogn）
bigint operator*(bigint a, bigint b) {
    bigint res;
    res.nums.pop_back();
    int dega = a.size() - 1, degb = b.size() - 1;
    int n = dega + degb + 1;
    int lim;
    for (lim = 1; lim < n; lim <<= 1); 
    NTT::init(lim);
    vector<uint> A(lim);
    for (int i = 0; i <= dega; i++) A[i] = a[i];
    vector<uint> B(lim);
    for (int i = 0; i <= degb; i++) B[i] = b[i];
    NTT::ntt(A, lim);
    NTT::ntt(B, lim);
    for (int i = 0; i < lim; i++) A[i] = mul(A[i], B[i]);
    NTT::intt(A, lim);
    for (int i = 0, t = 0; i < lim || t; i++) {
        if (i < lim) t += A[i];
        res.push_back(t % 10);
        t /= 10;
    }
    res.trim();
    return res;
}

// 大整数与长整数乘法
bigint operator*(bigint a, ll b) {
    bigint res(a);
    int carry = 0;
    for (int i = 0; i < a.size(); i++) {
        carry += a[i] * b;
        res[i] = carry % 10;
        carry /= 10;
    }
    while (carry > 0) {
        res.push_back(carry % 10);
        carry /= 10;
    }
    return res;
}

// 大整数除法
bigint operator/(bigint a, bigint b) {
    bigint tnum(a);
    if (a < b)
        return 0;
    int n = a.size() - b.size();
    b.nums.insert(b.nums.begin(), n, 0);
    if (tnum >= b) {
        n++;
        b.nums.insert(b.nums.begin(), 0);
    }
    bigint ans;
    ans.nums.assign(n, 0);
    int n2 = b.size();
    while (n--) {
        n2--;
        b.nums.erase(b.nums.begin());
        while (!(tnum < b)) {
            int n1 = tnum.size();
            for (int j = 0; j < n2; j++) {
                tnum[j] -= b[j];
                if (tnum[j] < 0) {
                    tnum[j + 1]--;
                    tnum[j] += 10;
                }
            }
            tnum.trim();
            ans[n]++;
        }
    }
    ans.trim();
    return ans;
}

// 大整数与长整数除法
bigint operator/(bigint a, ll b) {
    bigint ans;
    ans.clear();
    int r = 0;
    for (int i = a.size() - 1; i >= 0; i--) {
        r = r % b * 10 + a[i];
        ans.push_back(r / b);
    }
    reverse(ans.nums.begin(), ans.nums.end());
    ans.trim();
    return ans;
}

// 大整数取模
bigint operator%(bigint a, bigint b) {
    bigint div_res = a / b;
    return a - div_res * b;
}

// 大整数与长整数取模
bigint operator%(bigint a, ll b) {
    bigint div_res = a / b;
    return a - div_res * b;
}

// 大整数快速幂
bigint qp(bigint a, ll n) {
    bigint res(1);
    while (n) {
        if (n & 1) res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res;
}

// 大整数组合数
bigint comb(bigint n, bigint m) {
    bigint res = 1;
    for (bigint up = n, down = 1; down <= m; up = up - 1, down = down + 1)
        res = res * up, res = res / down;
    return res;
}

\end{lstlisting}
\subsection{comb}
\createlinenumber{3310}{2697}
\createlinenumber{3311}{97e5}
\createlinenumber{3312}{ef1b}
\createlinenumber{3313}{2294}
\createlinenumber{3314}{ca22}
\createlinenumber{3315}{6f75}
\createlinenumber{3316}{6b47}
\createlinenumber{3317}{05a8}
\createlinenumber{3318}{ca1f}
\createlinenumber{3319}{95cf}
\createlinenumber{3320}{244d}
\createlinenumber{3321}{95cf}
\createlinenumber{3322}{e00c}
\createlinenumber{3323}{acd8}
\createlinenumber{3324}{95cf}
\createlinenumber{3325}{d34f}
\createlinenumber{3326}{48ce}
\createlinenumber{3327}{170d}
\createlinenumber{3328}{fd7e}
\createlinenumber{3329}{0c3f}
\createlinenumber{3330}{fdd9}
\createlinenumber{3331}{8106}
\createlinenumber{3332}{95cf}
\createlinenumber{3333}{95cf}
\createlinenumber{3334}{5b90}
\createlinenumber{3335}{99e0}
\createlinenumber{3336}{7459}
\createlinenumber{3337}{2e3b}
\createlinenumber{3338}{95cf}
\createlinenumber{3339}{427e}
\createlinenumber{3340}{4646}
\createlinenumber{3341}{99e0}
\createlinenumber{3342}{7459}
\createlinenumber{3343}{5b46}
\createlinenumber{3344}{95cf}
\begin{lstlisting}[language=C++]
#define int long long
int fac[N], infac[N], inv[N];
int qmi(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1)
            res = (res * a) % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
int askinv(int x) {
    return qmi(x, mod - 2);
}
void init(int n) {
    fac[0] = 1, infac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;
    infac[n] = askinv(fac[n]);
    for (int i = n; i >= 1; i--) {
        infac[i - 1] = infac[i] * i % mod;
        inv[i] = fac[i - 1] * infac[i] % mod;
    }
}
int C(int n, int m) {
    if (n == 0 || m == 0)
        return 1;
    return fac[n] * infac[m] % mod * infac[n - m] % mod;
}

int A(int n, int m) {
    if (n == 0 || m == 0)
        return 1;
    return fac[n] * infac[n - m] % mod;
}
\end{lstlisting}
\subsection{comb\_Z}
\createlinenumber{3345}{3b29}
\createlinenumber{3346}{5c83}
\createlinenumber{3347}{c38b}
\createlinenumber{3348}{d1a1}
\createlinenumber{3349}{37b5}
\createlinenumber{3350}{427e}
\createlinenumber{3351}{d9c2}
\createlinenumber{3352}{9a39}
\createlinenumber{3353}{217c}
\createlinenumber{3354}{95cf}
\createlinenumber{3355}{427e}
\createlinenumber{3356}{a869}
\createlinenumber{3357}{a1d8}
\createlinenumber{3358}{1623}
\createlinenumber{3359}{d263}
\createlinenumber{3360}{d4c8}
\createlinenumber{3361}{65fe}
\createlinenumber{3362}{427e}
\createlinenumber{3363}{5eb9}
\createlinenumber{3364}{8de7}
\createlinenumber{3365}{95cf}
\createlinenumber{3366}{da89}
\createlinenumber{3367}{200b}
\createlinenumber{3368}{ba03}
\createlinenumber{3369}{86d0}
\createlinenumber{3370}{95cf}
\createlinenumber{3371}{7852}
\createlinenumber{3372}{95cf}
\createlinenumber{3373}{427e}
\createlinenumber{3374}{3def}
\createlinenumber{3375}{0aaf}
\createlinenumber{3376}{d4e4}
\createlinenumber{3377}{95cf}
\createlinenumber{3378}{8f91}
\createlinenumber{3379}{0aaf}
\createlinenumber{3380}{53df}
\createlinenumber{3381}{95cf}
\createlinenumber{3382}{0b12}
\createlinenumber{3383}{0aaf}
\createlinenumber{3384}{0061}
\createlinenumber{3385}{95cf}
\createlinenumber{3386}{5558}
\createlinenumber{3387}{dd89}
\createlinenumber{3388}{1e16}
\createlinenumber{3389}{95cf}
\createlinenumber{3390}{5090}
\createlinenumber{3391}{427e}
\begin{lstlisting}[language=C++]
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        m = std::min(m, Z::getMod() - 1);
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

\end{lstlisting}
\subsection{det}
\createlinenumber{3392}{4400}
\createlinenumber{3393}{b67a}
\createlinenumber{3394}{40f4}
\createlinenumber{3395}{427e}
\createlinenumber{3396}{172d}
\createlinenumber{3397}{4050}
\createlinenumber{3398}{fa2a}
\createlinenumber{3399}{ebe5}
\createlinenumber{3400}{a608}
\createlinenumber{3401}{9ffd}
\createlinenumber{3402}{af23}
\createlinenumber{3403}{16b6}
\createlinenumber{3404}{95cf}
\createlinenumber{3405}{af23}
\createlinenumber{3406}{16b6}
\createlinenumber{3407}{95cf}
\createlinenumber{3408}{95cf}
\createlinenumber{3409}{e4b7}
\createlinenumber{3410}{2ad4}
\createlinenumber{3411}{5746}
\createlinenumber{3412}{d3d0}
\createlinenumber{3413}{6ec7}
\createlinenumber{3414}{95cf}
\createlinenumber{3415}{9627}
\createlinenumber{3416}{5c83}
\createlinenumber{3417}{dcd9}
\createlinenumber{3418}{3bc7}
\createlinenumber{3419}{56cc}
\createlinenumber{3420}{2830}
\createlinenumber{3421}{c685}
\createlinenumber{3422}{64c7}
\createlinenumber{3423}{d592}
\createlinenumber{3424}{95cf}
\createlinenumber{3425}{427e}
\begin{lstlisting}[language=C++]
ll MOD;
int cal(vector<vector<int>>& a, int n) {
    ll flag = 1;
    // 转化成上三角矩阵
    for (int i = 1; i <= n; ++i) {  // 枚举行
        for (int k = i + 1; k <= n; ++k) {
            while (a[i][i]) {  // 辗转相除
                ll tim = a[k][i] / a[i][i];
                for (int j = i; j <= n; ++j)
                    a[k][j] = (a[k][j] - tim * a[i][j] % MOD + MOD) % MOD;
                swap(a[k], a[i]);  // 把较小的放上去
                flag = -flag;
            }
            swap(a[k], a[i]);
            flag = -flag;
        }
    }
    ll res = 1;
    for (int i = 1; i <= n; ++i)
        res = res * a[i][i] % MOD;
    res *= flag;
    return (res + MOD) % MOD;
}
void solve() {
    int n;
    cin >> n >> MOD;
    vector b(n + 1, vector<int>(n + 1));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> b[i][j];
    ll ans = cal(b, n);
    cout << ans << endl;
}

\end{lstlisting}
\subsection{int128}
\createlinenumber{3426}{fad9}
\createlinenumber{3427}{5bf2}
\createlinenumber{3428}{427e}
\createlinenumber{3429}{427e}
\createlinenumber{3430}{30f0}
\createlinenumber{3431}{427e}
\createlinenumber{3432}{e81d}
\createlinenumber{3433}{427e}
\createlinenumber{3434}{ccc5}
\createlinenumber{3435}{427e}
\createlinenumber{3436}{0703}
\createlinenumber{3437}{cb0d}
\createlinenumber{3438}{0d7a}
\createlinenumber{3439}{6f75}
\createlinenumber{3440}{7b3d}
\createlinenumber{3441}{244d}
\createlinenumber{3442}{95cf}
\createlinenumber{3443}{427e}
\createlinenumber{3444}{323f}
\createlinenumber{3445}{4a30}
\createlinenumber{3446}{1a53}
\createlinenumber{3447}{427e}
\createlinenumber{3448}{058c}
\createlinenumber{3449}{427e}
\createlinenumber{3450}{d34f}
\createlinenumber{3451}{dbfa}
\createlinenumber{3452}{9de8}
\createlinenumber{3453}{7a76}
\createlinenumber{3454}{541f}
\createlinenumber{3455}{8c68}
\createlinenumber{3456}{86bb}
\createlinenumber{3457}{f699}
\createlinenumber{3458}{95cf}
\createlinenumber{3459}{bed1}
\createlinenumber{3460}{c018}
\createlinenumber{3461}{5de2}
\createlinenumber{3462}{95cf}
\createlinenumber{3463}{95cf}
\createlinenumber{3464}{427e}
\createlinenumber{3465}{3fa8}
\createlinenumber{3466}{8231}
\createlinenumber{3467}{9670}
\createlinenumber{3468}{ba79}
\createlinenumber{3469}{9753}
\createlinenumber{3470}{fea4}
\createlinenumber{3471}{20ad}
\createlinenumber{3472}{fe76}
\createlinenumber{3473}{4f98}
\createlinenumber{3474}{5fbd}
\createlinenumber{3475}{4257}
\createlinenumber{3476}{95cf}
\createlinenumber{3477}{95cf}
\createlinenumber{3478}{95cf}
\createlinenumber{3479}{2379}
\createlinenumber{3480}{e54a}
\createlinenumber{3481}{95cf}
\createlinenumber{3482}{95cf}
\createlinenumber{3483}{427e}
\createlinenumber{3484}{549b}
\createlinenumber{3485}{3f00}
\createlinenumber{3486}{9670}
\createlinenumber{3487}{ba79}
\createlinenumber{3488}{5e09}
\createlinenumber{3489}{fea4}
\createlinenumber{3490}{4da2}
\createlinenumber{3491}{fe76}
\createlinenumber{3492}{4f98}
\createlinenumber{3493}{ce9b}
\createlinenumber{3494}{81a4}
\createlinenumber{3495}{95cf}
\createlinenumber{3496}{95cf}
\createlinenumber{3497}{95cf}
\createlinenumber{3498}{d596}
\createlinenumber{3499}{5bff}
\createlinenumber{3500}{2379}
\createlinenumber{3501}{2fbb}
\createlinenumber{3502}{e73f}
\createlinenumber{3503}{e54a}
\createlinenumber{3504}{95cf}
\createlinenumber{3505}{95cf}
\createlinenumber{3506}{95cf}
\createlinenumber{3507}{427e}
\createlinenumber{3508}{991b}
\createlinenumber{3509}{7739}
\createlinenumber{3510}{9222}
\createlinenumber{3511}{43c1}
\createlinenumber{3512}{0286}
\createlinenumber{3513}{c536}
\createlinenumber{3514}{427e}
\createlinenumber{3515}{6855}
\createlinenumber{3516}{a69f}
\createlinenumber{3517}{54f3}
\createlinenumber{3518}{c189}
\createlinenumber{3519}{67b5}
\createlinenumber{3520}{95cf}
\createlinenumber{3521}{427e}
\createlinenumber{3522}{b4bb}
\createlinenumber{3523}{0f36}
\createlinenumber{3524}{f8c6}
\createlinenumber{3525}{9630}
\createlinenumber{3526}{95cf}
\createlinenumber{3527}{427e}
\createlinenumber{3528}{fb0f}
\createlinenumber{3529}{fdf9}
\createlinenumber{3530}{4960}
\createlinenumber{3531}{95cf}
\createlinenumber{3532}{95cf}
\createlinenumber{3533}{427e}
\createlinenumber{3534}{1126}
\createlinenumber{3535}{42af}
\createlinenumber{3536}{95cf}
\createlinenumber{3537}{427e}
\createlinenumber{3538}{43d2}
\createlinenumber{3539}{dba5}
\createlinenumber{3540}{5fb4}
\createlinenumber{3541}{22a7}
\createlinenumber{3542}{a92c}
\createlinenumber{3543}{95cf}
\createlinenumber{3544}{427e}
\createlinenumber{3545}{5f56}
\createlinenumber{3546}{8eea}
\createlinenumber{3547}{7094}
\createlinenumber{3548}{a109}
\createlinenumber{3549}{b333}
\createlinenumber{3550}{880d}
\createlinenumber{3551}{4482}
\createlinenumber{3552}{95cf}
\createlinenumber{3553}{e5df}
\createlinenumber{3554}{0825}
\createlinenumber{3555}{b20e}
\createlinenumber{3556}{95cf}
\createlinenumber{3557}{329b}
\createlinenumber{3558}{427e}
\createlinenumber{3559}{427e}
\createlinenumber{3560}{4b94}
\createlinenumber{3561}{b917}
\createlinenumber{3562}{9e63}
\createlinenumber{3563}{c74f}
\createlinenumber{3564}{9d24}
\createlinenumber{3565}{c036}
\createlinenumber{3566}{438e}
\createlinenumber{3567}{95cf}
\createlinenumber{3568}{427e}
\createlinenumber{3569}{a5ba}
\createlinenumber{3570}{8d34}
\createlinenumber{3571}{95cf}
\createlinenumber{3572}{427e}
\createlinenumber{3573}{949a}
\createlinenumber{3574}{9846}
\createlinenumber{3575}{95cf}
\createlinenumber{3576}{427e}
\createlinenumber{3577}{1884}
\createlinenumber{3578}{54fd}
\createlinenumber{3579}{95cf}
\createlinenumber{3580}{427e}
\createlinenumber{3581}{9571}
\createlinenumber{3582}{3e48}
\createlinenumber{3583}{95cf}
\createlinenumber{3584}{427e}
\createlinenumber{3585}{08ba}
\createlinenumber{3586}{776c}
\createlinenumber{3587}{95cf}
\createlinenumber{3588}{427e}
\createlinenumber{3589}{427e}
\createlinenumber{3590}{52f1}
\createlinenumber{3591}{75bf}
\createlinenumber{3592}{044b}
\createlinenumber{3593}{2f70}
\createlinenumber{3594}{7ada}
\createlinenumber{3595}{8831}
\createlinenumber{3596}{2fa2}
\createlinenumber{3597}{4572}
\createlinenumber{3598}{95cf}
\createlinenumber{3599}{bf0a}
\createlinenumber{3600}{d817}
\createlinenumber{3601}{95cf}
\createlinenumber{3602}{ba62}
\createlinenumber{3603}{a7d4}
\createlinenumber{3604}{95cf}
\createlinenumber{3605}{b2c9}
\createlinenumber{3606}{244d}
\createlinenumber{3607}{95cf}
\createlinenumber{3608}{427e}
\createlinenumber{3609}{427e}
\createlinenumber{3610}{de23}
\createlinenumber{3611}{0f14}
\createlinenumber{3612}{c53f}
\createlinenumber{3613}{8eb8}
\createlinenumber{3614}{b426}
\createlinenumber{3615}{ab5d}
\createlinenumber{3616}{57ae}
\createlinenumber{3617}{1321}
\createlinenumber{3618}{d960}
\createlinenumber{3619}{7ce4}
\createlinenumber{3620}{b19a}
\createlinenumber{3621}{95cf}
\createlinenumber{3622}{037f}
\createlinenumber{3623}{1494}
\createlinenumber{3624}{6efa}
\createlinenumber{3625}{95cf}
\createlinenumber{3626}{95cf}
\createlinenumber{3627}{b2c9}
\createlinenumber{3628}{244d}
\createlinenumber{3629}{95cf}
\createlinenumber{3630}{427e}
\createlinenumber{3631}{427e}
\createlinenumber{3632}{c9fa}
\createlinenumber{3633}{75bf}
\createlinenumber{3634}{1522}
\createlinenumber{3635}{a2ee}
\createlinenumber{3636}{333a}
\createlinenumber{3637}{8980}
\createlinenumber{3638}{09e2}
\createlinenumber{3639}{fcd9}
\createlinenumber{3640}{c0de}
\createlinenumber{3641}{b420}
\createlinenumber{3642}{88dc}
\createlinenumber{3643}{cac3}
\createlinenumber{3644}{8964}
\createlinenumber{3645}{06b2}
\createlinenumber{3646}{4f80}
\createlinenumber{3647}{8861}
\createlinenumber{3648}{7d38}
\createlinenumber{3649}{70ff}
\createlinenumber{3650}{ba62}
\createlinenumber{3651}{a7d4}
\createlinenumber{3652}{95cf}
\createlinenumber{3653}{b2c9}
\createlinenumber{3654}{244d}
\createlinenumber{3655}{95cf}
\createlinenumber{3656}{427e}
\createlinenumber{3657}{427e}
\createlinenumber{3658}{bc4b}
\createlinenumber{3659}{0f14}
\createlinenumber{3660}{b0c6}
\createlinenumber{3661}{c1eb}
\createlinenumber{3662}{93a2}
\createlinenumber{3663}{f409}
\createlinenumber{3664}{4325}
\createlinenumber{3665}{95cf}
\createlinenumber{3666}{cb55}
\createlinenumber{3667}{9a92}
\createlinenumber{3668}{4325}
\createlinenumber{3669}{95cf}
\createlinenumber{3670}{244d}
\createlinenumber{3671}{95cf}
\createlinenumber{3672}{427e}
\createlinenumber{3673}{427e}
\createlinenumber{3674}{5265}
\createlinenumber{3675}{b0c6}
\createlinenumber{3676}{e7ec}
\createlinenumber{3677}{7021}
\createlinenumber{3678}{8e9a}
\createlinenumber{3679}{07d9}
\createlinenumber{3680}{02f2}
\createlinenumber{3681}{c93c}
\createlinenumber{3682}{f140}
\createlinenumber{3683}{95cf}
\createlinenumber{3684}{d401}
\createlinenumber{3685}{5048}
\createlinenumber{3686}{a9e4}
\createlinenumber{3687}{4b95}
\createlinenumber{3688}{5a34}
\createlinenumber{3689}{558c}
\createlinenumber{3690}{81d6}
\createlinenumber{3691}{4d28}
\createlinenumber{3692}{97d8}
\createlinenumber{3693}{28ec}
\createlinenumber{3694}{8586}
\createlinenumber{3695}{d878}
\createlinenumber{3696}{64c0}
\createlinenumber{3697}{95cf}
\createlinenumber{3698}{95cf}
\createlinenumber{3699}{9559}
\createlinenumber{3700}{69ff}
\createlinenumber{3701}{95cf}
\createlinenumber{3702}{95cf}
\createlinenumber{3703}{fb02}
\createlinenumber{3704}{4206}
\createlinenumber{3705}{95cf}
\createlinenumber{3706}{427e}
\createlinenumber{3707}{427e}
\createlinenumber{3708}{cc1b}
\createlinenumber{3709}{d401}
\createlinenumber{3710}{c873}
\createlinenumber{3711}{7c08}
\createlinenumber{3712}{901e}
\createlinenumber{3713}{442e}
\createlinenumber{3714}{aff4}
\createlinenumber{3715}{95cf}
\createlinenumber{3716}{21e1}
\createlinenumber{3717}{fb02}
\createlinenumber{3718}{4206}
\createlinenumber{3719}{95cf}
\createlinenumber{3720}{427e}
\createlinenumber{3721}{427e}
\createlinenumber{3722}{c8e2}
\createlinenumber{3723}{4551}
\createlinenumber{3724}{9f98}
\createlinenumber{3725}{95cf}
\createlinenumber{3726}{427e}
\createlinenumber{3727}{427e}
\createlinenumber{3728}{5cde}
\createlinenumber{3729}{4551}
\createlinenumber{3730}{9f98}
\createlinenumber{3731}{95cf}
\createlinenumber{3732}{427e}
\createlinenumber{3733}{427e}
\createlinenumber{3734}{735a}
\createlinenumber{3735}{8c2b}
\createlinenumber{3736}{e290}
\createlinenumber{3737}{f13a}
\createlinenumber{3738}{adae}
\createlinenumber{3739}{f9f7}
\createlinenumber{3740}{95cf}
\createlinenumber{3741}{244d}
\createlinenumber{3742}{95cf}
\createlinenumber{3743}{427e}
\createlinenumber{3744}{427e}
\createlinenumber{3745}{11da}
\createlinenumber{3746}{ac7f}
\createlinenumber{3747}{95f9}
\createlinenumber{3748}{1ac4}
\createlinenumber{3749}{244d}
\createlinenumber{3750}{95cf}
\createlinenumber{3751}{427e}
\begin{lstlisting}[language=C++]
using uint = unsigned;
const int MOD = 998244353; // NTT模数

// 模加法
int Add(int x, int y) { return (x + y >= MOD) ? x + y - MOD : x + y; }
// 模减法
int Dec(int x, int y) { return (x - y < 0) ? x - y + MOD : x - y; }
// 模乘法
int mul(int x, int y) { return 1ll * x * y % MOD; }
// 快速幂计算
uint qp(uint a, int b) { 
    uint res = 1; 
    for (; b; b >>= 1, a = mul(a, a))  
        if (b & 1)  
            res = mul(res, a); 
    return res; 
}

namespace NTT {
    int sz; // FFT大小
    uint w[2500005], w_mf[2500005]; // 存储预计算的单位根及其乘法因子
    // 计算乘法因子
    int mf(int x) { return (1ll * x << 32) / MOD; }
    // 初始化NTT
    void init(int n) {
        for (sz = 2; sz < n; sz <<= 1);
        uint pr = qp(3, (MOD - 1) / sz);
        w[sz / 2] = 1; 
        w_mf[sz / 2] = mf(1);
        for (int i = 1; i < sz / 2; i++) {
            w[sz / 2 + i] = mul(w[sz / 2 + i - 1], pr);
            w_mf[sz / 2 + i] = mf(w[sz / 2 + i]);
        }
        for (int i = sz / 2 - 1; i; i--) {
            w[i] = w[i << 1];
            w_mf[i] = w_mf[i << 1];
        }
    }
    // 前向NTT
    void ntt(vector<uint>& A, int L) {
        for (int d = L >> 1; d; d >>= 1) {
            for (int i = 0; i < L; i += (d << 1)) {
                for (int j = 0; j < d; j++) {
                    uint x = A[i + j] + A[i + d + j];
                    if (x >= 2 * MOD) x -= 2 * MOD;
                    ll t = A[i + j] + 2 * MOD - A[i + d + j];
                    ll q = t * w_mf[d + j] >> 32; 
                    int y = t * w[d + j] - q * MOD;
                    A[i + j] = x; 
                    A[i + d + j] = y;
                }
            }
        }
        for (int i = 0; i < L; i++) {
            if (A[i] >= MOD) A[i] -= MOD;
        }
    }
    // 逆NTT
    void intt(vector<uint>& A, int L) {
        for (int d = 1; d < L; d <<= 1) {
            for (int i = 0; i < L; i += (d << 1)) {
                for (int j = 0; j < d; j++) {
                    uint x = A[i + j]; 
                    if (x >= 2 * MOD) x -= 2 * MOD;
                    ll t = A[i + d + j];
                    ll q = t * w_mf[d + j] >> 32;
                    int y = t * w[d + j] - q * MOD;
                    A[i + j] = x + y; 
                    A[i + d + j] = x + 2 * MOD - y;
                }
            }
        }
        int k = (L & (-L));
        reverse(A.begin() + 1, A.end());
        for (int i = 0; i < L; i++) {
            ll m = -A[i] & (L - 1);
            A[i] = (A[i] + m * MOD) / k;
            if (A[i] >= MOD) A[i] -= MOD;
        }
    }
}

struct bigint {
    vector<int> nums; // 存储大整数的每一位
    int operator[](const int& k)const { return nums[k]; }
    int& operator[](const int& k) { return nums[k]; }
    int size() { return nums.size(); }
    void push_back(int x) { nums.push_back(x); }
    // 从整数构造大整数
    bigint(int x = 0) {
        do {
            nums.push_back(x % 10);
            x /= 10;
        } while (x);
    }
    // 从字符串构造大整数
    bigint(string s) {
        for (int i = s.size() - 1; i >= 0; i--)
            nums.push_back(s[i] - '0');
        trim();
    }
    // 去掉多余的前导零
    void trim() {
        while (nums.size() > 1 && nums.back() == 0) {
            nums.pop_back();
        }
    }
    // 清空大整数
    void clear() {
        nums.clear();
    }
    // 输入大整数
    friend istream& operator>>(istream& cin, bigint& num) {
        string tnum;
        cin >> tnum;
        num = tnum;
        return cin;
    }
    // 输出大整数
    friend ostream& operator<<(ostream& cout, bigint num) {
        bool start = false;
        for (int i = num.size() - 1; i >= 0; i--) {
            if (!start && num[i] == 0)
                continue;
            start = true;
            cout << num[i];
        }
        if (!start)
            cout << 0;
        return cout;
    }
};

// 比较运算符重载
bool operator<(bigint a, bigint b) {
    if (a.size() != b.size())
        return a.size() < b.size();
    for (int i = a.size() - 1; i >= 0; i--)
        if (a[i] != b[i])
            return a[i] < b[i];
    return false;
}

bool operator>(bigint a, bigint b) {
    return b < a;
}

bool operator<=(bigint a, bigint b) {
    return !(a > b);
}

bool operator>=(bigint a, bigint b) {
    return !(a < b);
}

bool operator==(bigint a, bigint b) {
    return !(a < b) && !(a > b);
}

bool operator!=(bigint a, bigint b) {
    return a < b || a > b;
}

// 大整数加法
bigint operator+(bigint a, bigint b) {
    bigint res;
    res.clear();
    int t = 0;
    int mx = max(a.size(), b.size());
    for (int i = 0; i < mx || t; i++) {
        if (i < a.size()) {
            t += a[i];
        }
        if (i < b.size()) {
            t += b[i];
        }
        res.push_back(t % 10);
        t /= 10;
    }
    res.trim();
    return res;
}

// 大整数减法
bigint operator-(bigint a, bigint b) {
    bigint res(a);
    bigint sub(b);
    int flag = 0;
    int len = res.size();
    while (sub.size() < res.size())
        sub.push_back(0);
    for (int i = 0; i < len; i++) {
        if (res[i] + flag >= sub[i]) {
            res[i] = res[i] + flag - sub[i];
            flag = 0;
        }
        else {
            res[i] = res[i] + 10 + flag - sub[i];
            flag = -1;
        }
    }
    res.trim();
    return res;
}

// 大整数乘法（nlogn）
bigint operator*(bigint a, bigint b) {
    bigint res;
    res.nums.pop_back();
    int dega = a.size() - 1, degb = b.size() - 1;
    int n = dega + degb + 1;
    int lim;
    for (lim = 1; lim < n; lim <<= 1); 
    NTT::init(lim);
    vector<uint> A(lim);
    for (int i = 0; i <= dega; i++) A[i] = a[i];
    vector<uint> B(lim);
    for (int i = 0; i <= degb; i++) B[i] = b[i];
    NTT::ntt(A, lim);
    NTT::ntt(B, lim);
    for (int i = 0; i < lim; i++) A[i] = mul(A[i], B[i]);
    NTT::intt(A, lim);
    for (int i = 0, t = 0; i < lim || t; i++) {
        if (i < lim) t += A[i];
        res.push_back(t % 10);
        t /= 10;
    }
    res.trim();
    return res;
}

// 大整数与长整数乘法
bigint operator*(bigint a, ll b) {
    bigint res(a);
    int carry = 0;
    for (int i = 0; i < a.size(); i++) {
        carry += a[i] * b;
        res[i] = carry % 10;
        carry /= 10;
    }
    while (carry > 0) {
        res.push_back(carry % 10);
        carry /= 10;
    }
    return res;
}

// 大整数除法
bigint operator/(bigint a, bigint b) {
    bigint tnum(a);
    if (a < b)
        return 0;
    int n = a.size() - b.size();
    b.nums.insert(b.nums.begin(), n, 0);
    if (tnum >= b) {
        n++;
        b.nums.insert(b.nums.begin(), 0);
    }
    bigint ans;
    ans.nums.assign(n, 0);
    int n2 = b.size();
    while (n--) {
        n2--;
        b.nums.erase(b.nums.begin());
        while (!(tnum < b)) {
            int n1 = tnum.size();
            for (int j = 0; j < n2; j++) {
                tnum[j] -= b[j];
                if (tnum[j] < 0) {
                    tnum[j + 1]--;
                    tnum[j] += 10;
                }
            }
            tnum.trim();
            ans[n]++;
        }
    }
    ans.trim();
    return ans;
}

// 大整数与长整数除法
bigint operator/(bigint a, ll b) {
    bigint ans;
    ans.clear();
    int r = 0;
    for (int i = a.size() - 1; i >= 0; i--) {
        r = r % b * 10 + a[i];
        ans.push_back(r / b);
    }
    reverse(ans.nums.begin(), ans.nums.end());
    ans.trim();
    return ans;
}

// 大整数取模
bigint operator%(bigint a, bigint b) {
    bigint div_res = a / b;
    return a - div_res * b;
}

// 大整数与长整数取模
bigint operator%(bigint a, ll b) {
    bigint div_res = a / b;
    return a - div_res * b;
}

// 大整数快速幂
bigint qp(bigint a, ll n) {
    bigint res(1);
    while (n) {
        if (n & 1) res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res;
}

// 大整数组合数
bigint comb(bigint n, bigint m) {
    bigint res = 1;
    for (bigint up = n, down = 1; down <= m; up = up - 1, down = down + 1)
        res = res * up, res = res / down;
    return res;
}

\end{lstlisting}
\subsection{linerbasis}
\createlinenumber{3752}{ef1b}
\createlinenumber{3753}{2294}
\createlinenumber{3754}{ca22}
\createlinenumber{3755}{6f75}
\createlinenumber{3756}{c2f9}
\createlinenumber{3757}{a1bb}
\createlinenumber{3758}{ca1f}
\createlinenumber{3759}{95cf}
\createlinenumber{3760}{244d}
\createlinenumber{3761}{95cf}
\createlinenumber{3762}{2f3f}
\createlinenumber{3763}{ba26}
\createlinenumber{3764}{fbdd}
\createlinenumber{3765}{108f}
\createlinenumber{3766}{1a30}
\createlinenumber{3767}{54e7}
\createlinenumber{3768}{427e}
\createlinenumber{3769}{c576}
\createlinenumber{3770}{2567}
\createlinenumber{3771}{95cf}
\createlinenumber{3772}{427e}
\createlinenumber{3773}{32f5}
\createlinenumber{3774}{c93c}
\createlinenumber{3775}{d20a}
\createlinenumber{3776}{fa03}
\createlinenumber{3777}{167c}
\createlinenumber{3778}{b333}
\createlinenumber{3779}{ccd7}
\createlinenumber{3780}{c89e}
\createlinenumber{3781}{037f}
\createlinenumber{3782}{7836}
\createlinenumber{3783}{da8a}
\createlinenumber{3784}{597c}
\createlinenumber{3785}{bcd7}
\createlinenumber{3786}{cd7b}
\createlinenumber{3787}{040d}
\createlinenumber{3788}{07fd}
\createlinenumber{3789}{71cf}
\createlinenumber{3790}{3361}
\createlinenumber{3791}{95cf}
\createlinenumber{3792}{95cf}
\createlinenumber{3793}{438e}
\createlinenumber{3794}{95cf}
\createlinenumber{3795}{427e}
\createlinenumber{3796}{3fff}
\createlinenumber{3797}{7cb9}
\createlinenumber{3798}{2a36}
\createlinenumber{3799}{4206}
\createlinenumber{3800}{95cf}
\createlinenumber{3801}{867f}
\createlinenumber{3802}{7cb9}
\createlinenumber{3803}{a4d6}
\createlinenumber{3804}{4206}
\createlinenumber{3805}{95cf}
\createlinenumber{3806}{427e}
\createlinenumber{3807}{95ae}
\createlinenumber{3808}{863b}
\createlinenumber{3809}{b3ca}
\createlinenumber{3810}{4f2d}
\createlinenumber{3811}{1a17}
\createlinenumber{3812}{7ddd}
\createlinenumber{3813}{8261}
\createlinenumber{3814}{95cf}
\createlinenumber{3815}{4476}
\createlinenumber{3816}{cc0b}
\createlinenumber{3817}{95cf}
\createlinenumber{3818}{427e}
\createlinenumber{3819}{3d85}
\createlinenumber{3820}{3ef0}
\createlinenumber{3821}{5839}
\createlinenumber{3822}{ccf8}
\createlinenumber{3823}{427e}
\createlinenumber{3824}{3309}
\createlinenumber{3825}{314c}
\createlinenumber{3826}{95cf}
\createlinenumber{3827}{e063}
\createlinenumber{3828}{fb5e}
\createlinenumber{3829}{4963}
\createlinenumber{3830}{7245}
\createlinenumber{3831}{c26a}
\createlinenumber{3832}{95cf}
\createlinenumber{3833}{244d}
\createlinenumber{3834}{95cf}
\createlinenumber{3835}{427e}
\createlinenumber{3836}{5357}
\createlinenumber{3837}{22d4}
\createlinenumber{3838}{fd0f}
\createlinenumber{3839}{bfe3}
\createlinenumber{3840}{ea2a}
\createlinenumber{3841}{43c6}
\createlinenumber{3842}{649a}
\createlinenumber{3843}{d51b}
\createlinenumber{3844}{95cf}
\createlinenumber{3845}{5a7d}
\createlinenumber{3846}{a213}
\createlinenumber{3847}{244d}
\createlinenumber{3848}{95cf}
\createlinenumber{3849}{329b}
\begin{lstlisting}[language=C++]
int qmi(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1)
            res = res * a % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}
struct linerbasis {
    static const int mxl = 30;
    int a[mxl + 1];
    int n = 0;        // 尝试插入次数
    int tot = 0;      // 线性基大小
    vector<int> tmp;  // 有效位集中

    linerbasis() {
        std::fill(a, a + mxl + 1, 0);
    }

    bool insert(int t) {
        n++;
        for (int j = mxl; j >= 0; j--) {
            int u = (t >> j) & 1;
            if (u == 0)
                continue;
            if (a[j])
                t ^= a[j];
            else {
                for (int k = 0; k < j; k++)
                    if ((t >> k) & 1)
                        t ^= a[k];
                for (int k = j + 1; k <= mxl; k++)
                    if ((a[k] >> j) & 1)
                        a[k] ^= t;
                a[j] = t;
                tot++;
                return true;
            }
        }
        return false;
    }

    int querymx(int x = 0) {  // 与x能异或出来的最大值，默认是x=0表示内部自己异或的最大值
        int ans = x;
        for (int i = mxl; i >= 0; i--) ans = max(ans, ans ^ a[i]);
        return ans;
    }
    int querymn(int x = 0) {  // 与x能异或出来的最小值，默认是x=0表示内部自己异或的最小值
        int ans = x;
        for (int i = mxl; i >= 0; i--) ans = min(ans, ans ^ a[i]);
        return ans;
    }

    void initkth() {
        static bool initialized = false;
        if (initialized)
            return;
        for (int i = 0; i <= mxl; i++) {
            if (a[i])
                tmp.push_back(a[i]);
        }
        deb(tmp);
        initialized = true;
    }
    // 第k小
    int querekthmin(int k, bool tkzo = false) {  // 第0小开始算
        initkth();
        int res = 0;
        if (tkzo == 0) {
            // 如果题目没有考虑空集，我们需要考虑能不能非空子集出现0
            if (tot == n)
                k++;
        }
        if (k >= (1LL << tot))
            return -1;
        for (int j = 0; j < tot; j++) {
            if ((k >> j) & 1)
                res ^= tmp[j];
        }
        return res;
    }
    // 值为x的下标
    int querypos(int x) {
        int l = 0, r = (1 << tot) - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (querekthmin(mid, true) >= x)
                r = mid;
            else
                l = mid + 1;
        }
        int res = qmi(2, n - tot) * l % mod + 1;
        res %= mod;
        return res;
    }
};
\end{lstlisting}
\subsection{matrix}
\createlinenumber{3850}{2c03}
\createlinenumber{3851}{5ee8}
\createlinenumber{3852}{b115}
\createlinenumber{3853}{a4bb}
\createlinenumber{3854}{427e}
\createlinenumber{3855}{427e}
\createlinenumber{3856}{427e}
\createlinenumber{3857}{427e}
\createlinenumber{3858}{fd5b}
\createlinenumber{3859}{427e}
\createlinenumber{3860}{427e}
\createlinenumber{3861}{427e}
\createlinenumber{3862}{da27}
\createlinenumber{3863}{1294}
\createlinenumber{3864}{7849}
\createlinenumber{3865}{95cf}
\createlinenumber{3866}{95cf}
\createlinenumber{3867}{427e}
\createlinenumber{3868}{5e28}
\createlinenumber{3869}{b063}
\createlinenumber{3870}{df71}
\createlinenumber{3871}{427e}
\createlinenumber{3872}{5289}
\createlinenumber{3873}{cecf}
\createlinenumber{3874}{ae59}
\createlinenumber{3875}{e148}
\createlinenumber{3876}{427e}
\createlinenumber{3877}{5279}
\createlinenumber{3878}{22d3}
\createlinenumber{3879}{a203}
\createlinenumber{3880}{8f74}
\createlinenumber{3881}{d619}
\createlinenumber{3882}{b333}
\createlinenumber{3883}{6fb1}
\createlinenumber{3884}{dbca}
\createlinenumber{3885}{5485}
\createlinenumber{3886}{95cf}
\createlinenumber{3887}{95cf}
\createlinenumber{3888}{95cf}
\createlinenumber{3889}{244d}
\createlinenumber{3890}{95cf}
\createlinenumber{3891}{427e}
\createlinenumber{3892}{41ef}
\createlinenumber{3893}{28b6}
\createlinenumber{3894}{9411}
\createlinenumber{3895}{544a}
\createlinenumber{3896}{484c}
\createlinenumber{3897}{2f2e}
\createlinenumber{3898}{95cf}
\createlinenumber{3899}{95cf}
\createlinenumber{3900}{244d}
\createlinenumber{3901}{95cf}
\createlinenumber{3902}{427e}
\createlinenumber{3903}{7e2e}
\createlinenumber{3904}{427e}
\createlinenumber{3905}{7484}
\createlinenumber{3906}{50d0}
\createlinenumber{3907}{544a}
\createlinenumber{3908}{484c}
\createlinenumber{3909}{3cba}
\createlinenumber{3910}{95cf}
\createlinenumber{3911}{95cf}
\createlinenumber{3912}{244d}
\createlinenumber{3913}{95cf}
\createlinenumber{3914}{427e}
\createlinenumber{3915}{0a95}
\createlinenumber{3916}{427e}
\createlinenumber{3917}{58e9}
\createlinenumber{3918}{0663}
\createlinenumber{3919}{bf1c}
\createlinenumber{3920}{1d6c}
\createlinenumber{3921}{e0f9}
\createlinenumber{3922}{a034}
\createlinenumber{3923}{adae}
\createlinenumber{3924}{e279}
\createlinenumber{3925}{95cf}
\createlinenumber{3926}{4206}
\createlinenumber{3927}{95cf}
\createlinenumber{3928}{427e}
\createlinenumber{3929}{bc19}
\createlinenumber{3930}{2ca8}
\createlinenumber{3931}{cba1}
\createlinenumber{3932}{2ad4}
\createlinenumber{3933}{22fd}
\createlinenumber{3934}{95cf}
\createlinenumber{3935}{95cf}
\createlinenumber{3936}{244d}
\createlinenumber{3937}{95cf}
\createlinenumber{3938}{329b}
\begin{lstlisting}[language=C++]
struct Matrix {
    using LL = long long;
    std::vector<std::vector<LL>> mat;
    Matrix() : mat{} {}

    /// @brief 生成n行m列空矩阵
    /// @param n 行数
    /// @param m 列数
    Matrix(int n, int m) : mat(n, std::vector<LL>(m)) {}

    /// @brief 生成单位矩阵 E
    /// @param n size
    Matrix(int n) : mat(n, std::vector<LL>(n)) {
        for (int i = 0; i < n; i++) {
            mat[i][i] = 1;
        }
    }

    int size() const { return mat.size(); }
    auto &operator[](int n) { return mat[n]; }
    auto &operator[](int n) const { return mat[n]; }

    auto begin() { return mat.begin(); }
    auto begin() const { return mat.begin(); }
    auto end() { return mat.end(); }
    auto end() const { return mat.end(); }

    Matrix operator*(const Matrix &o) const {
        Matrix res(mat.size(), o.size());
        for (size_t i = 0; i < res.size(); i++) {
            for (size_t k = 0; k < mat[0].size(); k++) {
                if (!mat[i][k])
                    continue;
                for (size_t j = 0; j < res[0].size(); j++) {
                    res[i][j] += mat[i][k] * o[k][j];
                    res[i][j] %= Mod;
                }
            }
        }
        return res;
    }

    Matrix operator*(const LL &a) const {
        Matrix res;
        res.mat = mat;
        for (int i = 0; i < res.size(); i++) {
            for (int j = 0; j < res[0].size(); j++) {
                res[i][j] *= a;
            }
        }
        return res;
    }

    friend Matrix operator*(const LL &a, const Matrix &o) { return o * a; }

    Matrix operator+(const Matrix &o) const {
        Matrix res = *this;
        for (int i = 0; i < res.size(); i++) {
            for (int j = 0; j < res[0].size(); j++) {
                res[i][j] = (mat[i][j] + o[i][j]) % Mod;
            }
        }
        return res;
    }

    Matrix operator-(const Matrix &o) const { return -1 * o + *this; }

    Matrix pow(LL k) const {
        Matrix a = *this;
        Matrix ans(this->size());
        while (k) {
            if (k & 1)
                ans = ans * a;
            a = a * a;
            k >>= 1;
        }
        return ans;
    }

    Matrix reverse() const {
        Matrix res(mat[0].size(), mat.size());
        for (int i = 0; i < mat[0].size(); i++) {
            for (int j = 0; j < mat.size(); j++) {
                res.mat[i][j] = mat[j][i];
            }
        }
        return res;
    }
};
\end{lstlisting}
\subsection{matrix\_tree}
\createlinenumber{3939}{b67a}
\createlinenumber{3940}{40f4}
\createlinenumber{3941}{427e}
\createlinenumber{3942}{172d}
\createlinenumber{3943}{4050}
\createlinenumber{3944}{fa2a}
\createlinenumber{3945}{ebe5}
\createlinenumber{3946}{a608}
\createlinenumber{3947}{400f}
\createlinenumber{3948}{af23}
\createlinenumber{3949}{16b6}
\createlinenumber{3950}{95cf}
\createlinenumber{3951}{af23}
\createlinenumber{3952}{16b6}
\createlinenumber{3953}{95cf}
\createlinenumber{3954}{95cf}
\createlinenumber{3955}{e4b7}
\createlinenumber{3956}{2ad4}
\createlinenumber{3957}{ec7f}
\createlinenumber{3958}{d3d0}
\createlinenumber{3959}{244d}
\createlinenumber{3960}{95cf}
\createlinenumber{3961}{9627}
\createlinenumber{3962}{35b8}
\createlinenumber{3963}{9af0}
\createlinenumber{3964}{3722}
\createlinenumber{3965}{e052}
\createlinenumber{3966}{54f1}
\createlinenumber{3967}{a02c}
\createlinenumber{3968}{4e49}
\createlinenumber{3969}{d62b}
\createlinenumber{3970}{c323}
\createlinenumber{3971}{39aa}
\createlinenumber{3972}{95cf}
\createlinenumber{3973}{c874}
\createlinenumber{3974}{d592}
\createlinenumber{3975}{95cf}
\begin{lstlisting}[language=C++]
int cal(vector<vector<int>>& a, int n) {//针对没有逆元
    ll flag = 1;
    // 转化成上三角矩阵
    for (int i = 1; i <= n; ++i) {  // 枚举行
        for (int k = i + 1; k <= n; ++k) {
            while (a[i][i]) {  // 辗转相除
                ll tim = a[k][i] / a[i][i];
                for (int j = i; j <= n; ++j)
                    a[k][j] = (a[k][j] - tim * a[i][j]);
                swap(a[k], a[i]);  // 把较小的放上去
                flag = -flag;
            }
            swap(a[k], a[i]);
            flag = -flag;
        }
    }
    ll res = 1;
    for (int i = 1; i <= n; ++i)
        res = res * a[i][i];
    res *= flag;
    return res;
}
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> b(n + 1, vector<int>(n + 1));
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        b[u][u]++;
        b[v][v]++;
        b[u][v]--;
        b[v][u]--;
    }
    int ans = cal(b, n - 1);
    cout << ans << endl;
}
\end{lstlisting}
\subsection{modint}
\createlinenumber{3976}{302f}
\createlinenumber{3977}{427e}
\createlinenumber{3978}{3c92}
\createlinenumber{3979}{0c7b}
\createlinenumber{3980}{a655}
\createlinenumber{3981}{613a}
\createlinenumber{3982}{5174}
\createlinenumber{3983}{c505}
\createlinenumber{3984}{1ad8}
\createlinenumber{3985}{95cf}
\createlinenumber{3986}{95cf}
\createlinenumber{3987}{244d}
\createlinenumber{3988}{95cf}
\createlinenumber{3989}{427e}
\createlinenumber{3990}{edcc}
\createlinenumber{3991}{7bfa}
\createlinenumber{3992}{3c9e}
\createlinenumber{3993}{951e}
\createlinenumber{3994}{3f47}
\createlinenumber{3995}{427e}
\createlinenumber{3996}{e788}
\createlinenumber{3997}{9e60}
\createlinenumber{3998}{dd2c}
\createlinenumber{3999}{9bd1}
\createlinenumber{4000}{8e2e}
\createlinenumber{4001}{6dd3}
\createlinenumber{4002}{95cf}
\createlinenumber{4003}{95cf}
\createlinenumber{4004}{edcd}
\createlinenumber{4005}{7881}
\createlinenumber{4006}{95cf}
\createlinenumber{4007}{87d4}
\createlinenumber{4008}{d078}
\createlinenumber{4009}{14c5}
\createlinenumber{4010}{95cf}
\createlinenumber{4011}{4695}
\createlinenumber{4012}{ed81}
\createlinenumber{4013}{95cf}
\createlinenumber{4014}{d074}
\createlinenumber{4015}{95cf}
\createlinenumber{4016}{e729}
\createlinenumber{4017}{d074}
\createlinenumber{4018}{95cf}
\createlinenumber{4019}{f297}
\createlinenumber{4020}{d074}
\createlinenumber{4021}{95cf}
\createlinenumber{4022}{3ac1}
\createlinenumber{4023}{b454}
\createlinenumber{4024}{d740}
\createlinenumber{4025}{244d}
\createlinenumber{4026}{95cf}
\createlinenumber{4027}{0f70}
\createlinenumber{4028}{c22c}
\createlinenumber{4029}{8721}
\createlinenumber{4030}{95cf}
\createlinenumber{4031}{ffc7}
\createlinenumber{4032}{6e72}
\createlinenumber{4033}{a09f}
\createlinenumber{4034}{95cf}
\createlinenumber{4035}{0fed}
\createlinenumber{4036}{3b58}
\createlinenumber{4037}{a09f}
\createlinenumber{4038}{95cf}
\createlinenumber{4039}{da19}
\createlinenumber{4040}{3b8f}
\createlinenumber{4041}{a09f}
\createlinenumber{4042}{95cf}
\createlinenumber{4043}{d77e}
\createlinenumber{4044}{c4f6}
\createlinenumber{4045}{95cf}
\createlinenumber{4046}{ca54}
\createlinenumber{4047}{84a5}
\createlinenumber{4048}{453c}
\createlinenumber{4049}{244d}
\createlinenumber{4050}{95cf}
\createlinenumber{4051}{73f1}
\createlinenumber{4052}{84a5}
\createlinenumber{4053}{b63a}
\createlinenumber{4054}{244d}
\createlinenumber{4055}{95cf}
\createlinenumber{4056}{6442}
\createlinenumber{4057}{84a5}
\createlinenumber{4058}{f317}
\createlinenumber{4059}{244d}
\createlinenumber{4060}{95cf}
\createlinenumber{4061}{9324}
\createlinenumber{4062}{84a5}
\createlinenumber{4063}{16d6}
\createlinenumber{4064}{244d}
\createlinenumber{4065}{95cf}
\createlinenumber{4066}{91d5}
\createlinenumber{4067}{9f9c}
\createlinenumber{4068}{04ea}
\createlinenumber{4069}{989e}
\createlinenumber{4070}{338d}
\createlinenumber{4071}{95cf}
\createlinenumber{4072}{a2b5}
\createlinenumber{4073}{b4ab}
\createlinenumber{4074}{95cf}
\createlinenumber{4075}{0688}
\createlinenumber{4076}{0998}
\createlinenumber{4077}{95cf}
\createlinenumber{4078}{3448}
\createlinenumber{4079}{c049}
\createlinenumber{4080}{95cf}
\createlinenumber{4081}{329b}
\createlinenumber{4082}{427e}
\createlinenumber{4083}{3625}
\createlinenumber{4084}{adfa}
\createlinenumber{4085}{427e}
\createlinenumber{4086}{92cb}
\createlinenumber{4087}{4d89}
\createlinenumber{4088}{427e}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>

using i64 = long long;
template <class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
//---------------------------------------------//
template <int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};

template <>
int MInt<0>::Mod = 998244353;
//------------------------------------//
constexpr int P = 998244353;
using Z = MInt<P>;
 //constexpr Z CInv = Z(n).inv();
\end{lstlisting}
\subsection{modll}
\createlinenumber{4089}{3c92}
\createlinenumber{4090}{0c7b}
\createlinenumber{4091}{a655}
\createlinenumber{4092}{613a}
\createlinenumber{4093}{5174}
\createlinenumber{4094}{c505}
\createlinenumber{4095}{1ad8}
\createlinenumber{4096}{95cf}
\createlinenumber{4097}{95cf}
\createlinenumber{4098}{244d}
\createlinenumber{4099}{95cf}
\createlinenumber{4100}{9121}
\createlinenumber{4101}{1deb}
\createlinenumber{4102}{1860}
\createlinenumber{4103}{4c95}
\createlinenumber{4104}{a800}
\createlinenumber{4105}{95cf}
\createlinenumber{4106}{244d}
\createlinenumber{4107}{95cf}
\createlinenumber{4108}{88ca}
\createlinenumber{4109}{3f97}
\createlinenumber{4110}{e85a}
\createlinenumber{4111}{6a32}
\createlinenumber{4112}{c624}
\createlinenumber{4113}{427e}
\createlinenumber{4114}{5e59}
\createlinenumber{4115}{e4ad}
\createlinenumber{4116}{dd2c}
\createlinenumber{4117}{9bd1}
\createlinenumber{4118}{8e2e}
\createlinenumber{4119}{6dd3}
\createlinenumber{4120}{95cf}
\createlinenumber{4121}{95cf}
\createlinenumber{4122}{546e}
\createlinenumber{4123}{7881}
\createlinenumber{4124}{95cf}
\createlinenumber{4125}{1d29}
\createlinenumber{4126}{d078}
\createlinenumber{4127}{14c5}
\createlinenumber{4128}{95cf}
\createlinenumber{4129}{4695}
\createlinenumber{4130}{ed81}
\createlinenumber{4131}{95cf}
\createlinenumber{4132}{d074}
\createlinenumber{4133}{95cf}
\createlinenumber{4134}{a1f5}
\createlinenumber{4135}{d074}
\createlinenumber{4136}{95cf}
\createlinenumber{4137}{bf5f}
\createlinenumber{4138}{d074}
\createlinenumber{4139}{95cf}
\createlinenumber{4140}{952c}
\createlinenumber{4141}{71e3}
\createlinenumber{4142}{d740}
\createlinenumber{4143}{244d}
\createlinenumber{4144}{95cf}
\createlinenumber{4145}{67df}
\createlinenumber{4146}{c22c}
\createlinenumber{4147}{8721}
\createlinenumber{4148}{95cf}
\createlinenumber{4149}{9f12}
\createlinenumber{4150}{532d}
\createlinenumber{4151}{a09f}
\createlinenumber{4152}{95cf}
\createlinenumber{4153}{ad46}
\createlinenumber{4154}{3b58}
\createlinenumber{4155}{a09f}
\createlinenumber{4156}{95cf}
\createlinenumber{4157}{7cac}
\createlinenumber{4158}{3b8f}
\createlinenumber{4159}{a09f}
\createlinenumber{4160}{95cf}
\createlinenumber{4161}{4129}
\createlinenumber{4162}{c4f6}
\createlinenumber{4163}{95cf}
\createlinenumber{4164}{cbd6}
\createlinenumber{4165}{8e0d}
\createlinenumber{4166}{453c}
\createlinenumber{4167}{244d}
\createlinenumber{4168}{95cf}
\createlinenumber{4169}{4f04}
\createlinenumber{4170}{8e0d}
\createlinenumber{4171}{b63a}
\createlinenumber{4172}{244d}
\createlinenumber{4173}{95cf}
\createlinenumber{4174}{8751}
\createlinenumber{4175}{8e0d}
\createlinenumber{4176}{f317}
\createlinenumber{4177}{244d}
\createlinenumber{4178}{95cf}
\createlinenumber{4179}{52ed}
\createlinenumber{4180}{8e0d}
\createlinenumber{4181}{16d6}
\createlinenumber{4182}{244d}
\createlinenumber{4183}{95cf}
\createlinenumber{4184}{0e9e}
\createlinenumber{4185}{9f9c}
\createlinenumber{4186}{04ea}
\createlinenumber{4187}{3f2b}
\createlinenumber{4188}{338d}
\createlinenumber{4189}{95cf}
\createlinenumber{4190}{7038}
\createlinenumber{4191}{b4ab}
\createlinenumber{4192}{95cf}
\createlinenumber{4193}{d8e7}
\createlinenumber{4194}{0998}
\createlinenumber{4195}{95cf}
\createlinenumber{4196}{d908}
\createlinenumber{4197}{c049}
\createlinenumber{4198}{95cf}
\createlinenumber{4199}{329b}
\createlinenumber{4200}{3625}
\createlinenumber{4201}{28b6}
\createlinenumber{4202}{427e}
\createlinenumber{4203}{5141}
\createlinenumber{4204}{2a92}
\begin{lstlisting}[language=C++]
using i64 = long long;
template <class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template <i64 P>
struct MLong {
    i64 x;
    constexpr MLong() : x{} {}
    constexpr MLong(i64 x) : x{norm(x % getMod())} {}

    static i64 Mod;
    constexpr static i64 getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_) {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const {
        return x;
    }
    explicit constexpr operator i64() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        i64 v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};
template <>
i64 MLong<0LL>::Mod = i64(1E18) + 9;
//--------------------------------//
constexpr int P = i64(1E18) + 9;
using Z = MLong<P>;
\end{lstlisting}
\subsection{pre\_linerbasis}
\createlinenumber{4205}{73e7}
\createlinenumber{4206}{f1ae}
\createlinenumber{4207}{1e0b}
\createlinenumber{4208}{d159}
\createlinenumber{4209}{e547}
\createlinenumber{4210}{890f}
\createlinenumber{4211}{d34f}
\createlinenumber{4212}{ecb5}
\createlinenumber{4213}{ce89}
\createlinenumber{4214}{95cf}
\createlinenumber{4215}{8f90}
\createlinenumber{4216}{1a17}
\createlinenumber{4217}{21bc}
\createlinenumber{4218}{ebd7}
\createlinenumber{4219}{95cf}
\createlinenumber{4220}{797b}
\createlinenumber{4221}{388d}
\createlinenumber{4222}{11a5}
\createlinenumber{4223}{785a}
\createlinenumber{4224}{239a}
\createlinenumber{4225}{89be}
\createlinenumber{4226}{6173}
\createlinenumber{4227}{95cf}
\createlinenumber{4228}{427e}
\createlinenumber{4229}{023a}
\createlinenumber{4230}{7e9c}
\createlinenumber{4231}{55dc}
\createlinenumber{4232}{95cf}
\createlinenumber{4233}{95cf}
\createlinenumber{4234}{95cf}
\createlinenumber{4235}{1bf1}
\createlinenumber{4236}{7cb9}
\createlinenumber{4237}{53dd}
\createlinenumber{4238}{6a10}
\createlinenumber{4239}{fa0c}
\createlinenumber{4240}{4206}
\createlinenumber{4241}{95cf}
\createlinenumber{4242}{329b}
\createlinenumber{4243}{427e}
\createlinenumber{4244}{9627}
\createlinenumber{4245}{5c83}
\createlinenumber{4246}{e1b6}
\createlinenumber{4247}{2524}
\createlinenumber{4248}{d535}
\createlinenumber{4249}{fbee}
\createlinenumber{4250}{86d6}
\createlinenumber{4251}{9bbd}
\createlinenumber{4252}{c998}
\createlinenumber{4253}{949d}
\createlinenumber{4254}{9f6b}
\createlinenumber{4255}{ad6f}
\createlinenumber{4256}{8afe}
\createlinenumber{4257}{95cf}
\createlinenumber{4258}{95cf}
\begin{lstlisting}[language=C++]
struct prelinerbasis {
    static const int mxl = 20;
    vector<array<int, mxl + 1>> p;    // p[id][i]表示前id个数，第i位的线性基
    vector<array<int, mxl + 1>> pos;  // pos[id][i]表示构造基p[id][i]的元素的下标最大值
    prelinerbasis() {}
    prelinerbasis(int n) { init(n); }
    void init(int n) {
        p.resize(n + 1);
        pos.resize(n + 1);
    }
    void insert(int x, int id) {
        for (int i = 0; i <= mxl; i++) {  // 复制前一版
            p[id][i] = p[id - 1][i];
            pos[id][i] = pos[id - 1][i];
        }
        int cur = id;
        for (int i = mxl; i >= 0; i--) {
            if (x >> i & 1) {
                if (!p[id][i]) {  // 不存在则加入
                    p[id][i] = x;
                    pos[id][i] = cur;
                    break;
                }
                // 存在则先交换，后异或
                if (pos[id][i] < cur)
                    swap(p[id][i], x), swap(pos[id][i], cur);
                x ^= p[id][i];
            }
        }
    }
    int query(int l, int r, int x = 0) {  //[l,r]的线性基与x异或的最大值
        int ans = x;
        for (int i = mxl; i >= 0; i--)
            if (pos[r][i] >= l)
                ans = max(ans, ans ^ p[r][i]);
        return ans;
    }
};

void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    prelinerbasis plb(n);
    for (int i = 1; i <= n; i++) plb.insert(a[i], i);
    int q;
    cin >> q;
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        cout << plb.query(l, r) << endl;
    }
}
\end{lstlisting}
\subsection{prelinerbasis\_tree}
\createlinenumber{4259}{bcf8}
\createlinenumber{4260}{7a26}
\createlinenumber{4261}{329b}
\createlinenumber{4262}{617f}
\createlinenumber{4263}{5c83}
\createlinenumber{4264}{782b}
\createlinenumber{4265}{d454}
\createlinenumber{4266}{aad0}
\createlinenumber{4267}{427e}
\createlinenumber{4268}{afe0}
\createlinenumber{4269}{c4d2}
\createlinenumber{4270}{752d}
\createlinenumber{4271}{217c}
\createlinenumber{4272}{95cf}
\createlinenumber{4273}{d34f}
\createlinenumber{4274}{b985}
\createlinenumber{4275}{fce3}
\createlinenumber{4276}{43f8}
\createlinenumber{4277}{0bc6}
\createlinenumber{4278}{7871}
\createlinenumber{4279}{a9db}
\createlinenumber{4280}{427e}
\createlinenumber{4281}{246a}
\createlinenumber{4282}{95cf}
\createlinenumber{4283}{5953}
\createlinenumber{4284}{77d1}
\createlinenumber{4285}{95cf}
\createlinenumber{4286}{fe6d}
\createlinenumber{4287}{200c}
\createlinenumber{4288}{1a33}
\createlinenumber{4289}{7965}
\createlinenumber{4290}{1c88}
\createlinenumber{4291}{95cf}
\createlinenumber{4292}{07be}
\createlinenumber{4293}{e380}
\createlinenumber{4294}{1090}
\createlinenumber{4295}{f95d}
\createlinenumber{4296}{7861}
\createlinenumber{4297}{b333}
\createlinenumber{4298}{19a5}
\createlinenumber{4299}{bbda}
\createlinenumber{4300}{53f1}
\createlinenumber{4301}{1b6f}
\createlinenumber{4302}{0ee8}
\createlinenumber{4303}{c326}
\createlinenumber{4304}{95cf}
\createlinenumber{4305}{95cf}
\createlinenumber{4306}{60ec}
\createlinenumber{4307}{643e}
\createlinenumber{4308}{a577}
\createlinenumber{4309}{1a26}
\createlinenumber{4310}{80cd}
\createlinenumber{4311}{4f2d}
\createlinenumber{4312}{95cf}
\createlinenumber{4313}{12f1}
\createlinenumber{4314}{f95d}
\createlinenumber{4315}{7593}
\createlinenumber{4316}{b333}
\createlinenumber{4317}{8064}
\createlinenumber{4318}{95cf}
\createlinenumber{4319}{80cd}
\createlinenumber{4320}{95cf}
\createlinenumber{4321}{0f0b}
\createlinenumber{4322}{03a1}
\createlinenumber{4323}{5c7d}
\createlinenumber{4324}{23a2}
\createlinenumber{4325}{8e2e}
\createlinenumber{4326}{560a}
\createlinenumber{4327}{95cf}
\createlinenumber{4328}{95cf}
\createlinenumber{4329}{d9e4}
\createlinenumber{4330}{95cf}
\createlinenumber{4331}{c0f6}
\createlinenumber{4332}{3505}
\createlinenumber{4333}{95cf}
\createlinenumber{4334}{329b}
\createlinenumber{4335}{9b3b}
\createlinenumber{4336}{129e}
\createlinenumber{4337}{1e0b}
\createlinenumber{4338}{d159}
\createlinenumber{4339}{2878}
\createlinenumber{4340}{eccc}
\createlinenumber{4341}{d34f}
\createlinenumber{4342}{ecb5}
\createlinenumber{4343}{ce89}
\createlinenumber{4344}{95cf}
\createlinenumber{4345}{a594}
\createlinenumber{4346}{c0f3}
\createlinenumber{4347}{6cab}
\createlinenumber{4348}{e348}
\createlinenumber{4349}{c5d2}
\createlinenumber{4350}{d524}
\createlinenumber{4351}{040f}
\createlinenumber{4352}{357b}
\createlinenumber{4353}{4fc5}
\createlinenumber{4354}{0ab3}
\createlinenumber{4355}{3a4b}
\createlinenumber{4356}{6173}
\createlinenumber{4357}{95cf}
\createlinenumber{4358}{427e}
\createlinenumber{4359}{4d53}
\createlinenumber{4360}{543b}
\createlinenumber{4361}{a3f3}
\createlinenumber{4362}{95cf}
\createlinenumber{4363}{95cf}
\createlinenumber{4364}{95cf}
\createlinenumber{4365}{0fb0}
\createlinenumber{4366}{b7c4}
\createlinenumber{4367}{4696}
\createlinenumber{4368}{244d}
\createlinenumber{4369}{95cf}
\createlinenumber{4370}{439f}
\createlinenumber{4371}{e2dc}
\createlinenumber{4372}{00e9}
\createlinenumber{4373}{1c9a}
\createlinenumber{4374}{d524}
\createlinenumber{4375}{adfd}
\createlinenumber{4376}{8c6e}
\createlinenumber{4377}{95cf}
\createlinenumber{4378}{d524}
\createlinenumber{4379}{c0c0}
\createlinenumber{4380}{b333}
\createlinenumber{4381}{361a}
\createlinenumber{4382}{8e8d}
\createlinenumber{4383}{305f}
\createlinenumber{4384}{23ac}
\createlinenumber{4385}{b41d}
\createlinenumber{4386}{6173}
\createlinenumber{4387}{95cf}
\createlinenumber{4388}{e60f}
\createlinenumber{4389}{95cf}
\createlinenumber{4390}{95cf}
\createlinenumber{4391}{95cf}
\createlinenumber{4392}{0ea1}
\createlinenumber{4393}{95cf}
\createlinenumber{4394}{329b}
\createlinenumber{4395}{427e}
\createlinenumber{4396}{9627}
\createlinenumber{4397}{1ed7}
\createlinenumber{4398}{9c97}
\createlinenumber{4399}{2524}
\createlinenumber{4400}{81b6}
\createlinenumber{4401}{2c4b}
\createlinenumber{4402}{6a71}
\createlinenumber{4403}{7300}
\createlinenumber{4404}{54f1}
\createlinenumber{4405}{a02c}
\createlinenumber{4406}{7a36}
\createlinenumber{4407}{10c8}
\createlinenumber{4408}{95cf}
\createlinenumber{4409}{969c}
\createlinenumber{4410}{acd4}
\createlinenumber{4411}{949d}
\createlinenumber{4412}{54f1}
\createlinenumber{4413}{a02c}
\createlinenumber{4414}{6c1d}
\createlinenumber{4415}{a498}
\createlinenumber{4416}{c88b}
\createlinenumber{4417}{95cf}
\createlinenumber{4418}{95cf}
\begin{lstlisting}[language=C++]
struct edge {
    int v, w;
};
struct HLD {
    int n;
    vector<int> siz, top, parent, l, r, hson, dep;
    vector<vector<edge>> adj;
    int idx;
    // 加数据结构
    vector<int> a;
    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n + 1), hson.resize(n + 1), top.resize(n + 1);
        parent.resize(n + 1);
        l.resize(n + 1), r.resize(n + 1);
        idx = 0;
        adj.resize(n + 1), dep.resize(n + 1);
        // 根据题目要求加数据结构
        a.resize(n + 1);
    }
    void addEdge(int u, int v, int w) {
        adj[u].push_back({v, w});
    }
    void work(auto& plb, int root = 1) {
        top[root] = root;
        dep[root] = 1;
        dfs1(root, 0, plb);
        dfs2(root, root);
    }
    void dfs1(int u, int f, auto& plb) {  // 搞fa,dep,son
        siz[u] = 1;
        plb.insert(a[u], u, f, *this);  // 继承父节点，插入当前节点
        for (auto [v, w] : adj[u]) {
            if (v == f)
                continue;
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v, u, plb);
            siz[u] += siz[v];
            if (siz[hson[u]] < siz[v])
                hson[u] = v;
        }
    }
    void dfs2(int u, int t) {  // 搞top
        top[u] = t;            // 记录链头
        l[u] = ++idx;
        if (!hson[u]) {
            r[u] = idx;
            return;
        }  // 无重儿子
        dfs2(hson[u], t);  // 搜重儿子
        for (auto [v, w] : adj[u]) {
            if (v == parent[u] || v == hson[u])
                continue;
            dfs2(v, v);  // 搜轻儿子
        }
        r[u] = idx;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    bool isAncester(int u, int v) {  // 判断u是不是v的祖先
        return l[u] <= l[v] && r[v] <= r[u];
    }
};
struct prelinerbasis_tree {
    static const int mxl = 60;
    vector<array<int, mxl + 1>> p;    // p[id][i]表示前id个数，第i位的线性基
    vector<array<int, mxl + 1>> pos;  // pos[id][i]表示构造基p[id][i]的元素的下标最大值
    prelinerbasis_tree() {}
    prelinerbasis_tree(int n) { init(n); }
    void init(int n) {
        p.resize(n + 1);
        pos.resize(n + 1);
    }
    void insert(int x, int u, int f, auto& hld) {
        deb(x, u, f);
        for (int i = 0; i <= mxl; i++)  // 复制父版
            p[u][i] = p[f][i], pos[u][i] = pos[f][i];
        int cur = u;
        for (int i = mxl; i >= 0; --i) {
            if ((x >> i) & 1) {
                deb(x, i);
                if (!p[u][i]) {  // 不存在则加入
                    p[u][i] = x;
                    pos[u][i] = cur;
                    break;
                }
                // 存在则先交换，后异或
                if (hld.dep[pos[u][i]] < hld.dep[cur])
                    swap(x, p[u][i]), swap(pos[u][i], cur);
                x ^= p[u][i];
            }
        }
    }
    int querymx(const vector<int>& b, int x = 0) {
        int res = x;
        for (int i = mxl; i >= 0; i--) res = max(res, res ^ b[i]);
        return res;
    }
    vector<int> query(int x, int y, auto& hld) {  // 查询x到y简单路径构造的线性基
        int tmplca = hld.lca(x, y);
        deb(x, y, tmplca);
        vector<int> b(mxl + 1);
        for (int i = mxl; i >= 0; --i) {  // 从x到根的链中提取出x~lca的线性基
            if (hld.dep[pos[x][i]] >= hld.dep[tmplca])
                b[i] = p[x][i];
        }
        for (int i = mxl; i >= 0; --i) {  // 暴力合并y-lca的基
            if (hld.dep[pos[y][i]] < hld.dep[tmplca])
                continue;
            int x = p[y][i];  // 提取y~lca链的基
            for (int j = i; j >= 0; --j) {
                if (x >> j & 1) {
                    if (!b[j]) {
                        b[j] = x;
                        break;
                    }
                    x ^= b[j];
                }
            }
        }
        return b;
    }
};

void solve() {
    int n, q;
    cin >> n >> q;
    vector<int> a(n + 1);
    HLD hld(n);
    prelinerbasis_tree plb(n);
    for (int i = 1; i <= n; i++) cin >> hld.a[i];
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        hld.addEdge(u, v, 1);
        hld.addEdge(v, u, 1);
    }
    hld.work(plb, 1);
    for (int i = 1; i <= n; i++) deb(i, hld.dep[i]);
    for (int i = 1; i <= q; i++) {
        int u, v;
        cin >> u >> v;
        auto b = plb.query(u, v, hld);
        deb(b);
        cout << plb.querymx(b) << endl;
    }
}
\end{lstlisting}
\subsection{simpson}
\createlinenumber{4419}{0b64}
\createlinenumber{4420}{a4c7}
\createlinenumber{4421}{427e}
\createlinenumber{4422}{427e}
\createlinenumber{4423}{427e}
\createlinenumber{4424}{427e}
\createlinenumber{4425}{427e}
\createlinenumber{4426}{427e}
\createlinenumber{4427}{427e}
\createlinenumber{4428}{0d55}
\createlinenumber{4429}{7b2b}
\createlinenumber{4430}{95cf}
\createlinenumber{4431}{31b3}
\createlinenumber{4432}{cdfd}
\createlinenumber{4433}{95cf}
\createlinenumber{4434}{427e}
\createlinenumber{4435}{74b6}
\createlinenumber{4436}{427e}
\createlinenumber{4437}{91b8}
\createlinenumber{4438}{f4e7}
\createlinenumber{4439}{4206}
\createlinenumber{4440}{1aa6}
\createlinenumber{4441}{95cf}
\createlinenumber{4442}{3117}
\createlinenumber{4443}{8e70}
\createlinenumber{4444}{1120}
\createlinenumber{4445}{7021}
\createlinenumber{4446}{95cf}
\begin{lstlisting}[language=C++]
const double eps = 1e-10;
double a, b, c, d, l, r;
//时间复杂度：O(log(n/eps))
// tips:要注意保证给的初始区间的积分是收敛的并且不要出现无定义点
// 反常积分的发散部分特判
// 1.对于初始区间，有时候显然不能直接赋值0和无穷大，
// 2.左端点复制成eps。
// 3.考虑右端点，根据题目条件的取值，
//当x=20（一个具体值）的时候代入发现已经远小于eps了故右端点设计为20.
double f(double x) {  // 积分函数
    return (c * x + d) / (a * x + b);
}
double simpson(double l, double r) {  // 辛普森公式
    return (r - l) * (f(l) + f(r) + 4 * f((l + r) / 2)) / 6;
}  // 二次函数特性

double asr(double l, double r, double ans) {  // 自适应
    // 分段simpson，如果划分足够小，低于误差就可以
    auto m = (l + r) / 2, a = simpson(l, m), b = simpson(m, r);
    if (fabs(a + b - ans) < eps)
        return ans;
    return asr(l, m, a) + asr(m, r, b);
}
int main() {
    scanf("%lf%lf%lf%lf%lf%lf", &a, &b, &c, &d, &l, &r);
    printf("%.6lf", asr(l, r, simpson(l, r)));
    return 0;
}
\end{lstlisting}
\section{Misc}
\subsection{坐标转换}
\createlinenumber{4447}{7274}
\createlinenumber{4448}{427e}
\createlinenumber{4449}{607e}
\createlinenumber{4450}{95cf}
\createlinenumber{4451}{f20b}
\createlinenumber{4452}{1a80}
\createlinenumber{4453}{7305}
\createlinenumber{4454}{ba7b}
\createlinenumber{4455}{95cf}
\createlinenumber{4456}{427e}
\begin{lstlisting}[language=C++]
int id(int x,int y,int m){
	//m列
	return m*(x-1)+y;
}
pii rid(int u,int m){
	int x=(u+m-1)/m;//m列
	int y=u%m;if(y==0)y+=m;
	return make_pair(x,y);
}

\end{lstlisting}
\subsection{小数保留问题}
\createlinenumber{4457}{e0a5}
\createlinenumber{4458}{427e}
\createlinenumber{4459}{421c}
\createlinenumber{4460}{0d2d}
\createlinenumber{4461}{427e}
\createlinenumber{4462}{55ae}
\createlinenumber{4463}{4506}
\createlinenumber{4464}{427e}
\createlinenumber{4465}{67b3}
\createlinenumber{4466}{7d7c}
\createlinenumber{4467}{649a}
\createlinenumber{4468}{3c9c}
\createlinenumber{4469}{95cf}
\createlinenumber{4470}{427e}
\createlinenumber{4471}{299c}
\createlinenumber{4472}{4506}
\createlinenumber{4473}{23ec}
\createlinenumber{4474}{7d13}
\createlinenumber{4475}{bdc3}
\createlinenumber{4476}{7635}
\createlinenumber{4477}{427e}
\createlinenumber{4478}{9af0}
\createlinenumber{4479}{3e8d}
\createlinenumber{4480}{6dff}
\createlinenumber{4481}{a04a}
\createlinenumber{4482}{427e}
\createlinenumber{4483}{253d}
\createlinenumber{4484}{7349}
\createlinenumber{4485}{f2c3}
\createlinenumber{4486}{37a1}
\createlinenumber{4487}{7021}
\createlinenumber{4488}{95cf}
\begin{lstlisting}[language=C++]
#include <iostream>
 
using namespace std;
要得到四舍五入小数点后的结果，我们可以将小数转换为整数来处理，然后再转换为小数。
// 用于四舍五入
int round_0 (double n)
{
  // 若为负数，则先化为正数再进行四舍五入
  if (n > 0)
    return n - int(n) >= 0.5 ? int(n)+1 : int(n);
  else
    return -n - int(-n) >= 0.5 ? -(int(-n) + 1) : -int(-n);
}
 
int main()
{
  double a = 1.2345;
  double b = 1.2355;
  double n_a = -1.2345;
  double n_b = -1.2355;
 
  a = round_0(a * 100.0) / 100.0;
  b = round_0(b * 100.0) / 100.0;
  n_a = round_0(n_a * 100.0) / 100.0;
  n_b = round_0(n_b * 100.0) / 100.0;
 
  cout << a << endl;  // 1.23
  cout << b << endl;  // 1.24
  cout << n_a << endl;  //-1.23
  cout << n_b << endl;  // -1.24
  return 0;
}
\end{lstlisting}
\subsection{日期问题}
\createlinenumber{4489}{427e}
\createlinenumber{4490}{427e}
\createlinenumber{4491}{427e}
\createlinenumber{4492}{0177}
\createlinenumber{4493}{aaf6}
\createlinenumber{4494}{85fe}
\createlinenumber{4495}{0074}
\createlinenumber{4496}{95cf}
\createlinenumber{4497}{427e}
\createlinenumber{4498}{1837}
\createlinenumber{4499}{e5b8}
\createlinenumber{4500}{e67e}
\createlinenumber{4501}{a04e}
\createlinenumber{4502}{473d}
\createlinenumber{4503}{e0ee}
\createlinenumber{4504}{7789}
\createlinenumber{4505}{afcc}
\createlinenumber{4506}{95cf}
\createlinenumber{4507}{427e}
\createlinenumber{4508}{fb0f}
\createlinenumber{4509}{bb73}
\createlinenumber{4510}{b3c7}
\createlinenumber{4511}{3bea}
\createlinenumber{4512}{95cf}
\createlinenumber{4513}{427e}
\createlinenumber{4514}{427e}
\createlinenumber{4515}{0169}
\createlinenumber{4516}{e050}
\createlinenumber{4517}{329b}
\createlinenumber{4518}{427e}
\createlinenumber{4519}{1e30}
\createlinenumber{4520}{4506}
\createlinenumber{4521}{d1ac}
\createlinenumber{4522}{7459}
\createlinenumber{4523}{7021}
\createlinenumber{4524}{95cf}
\createlinenumber{4525}{427e}
\createlinenumber{4526}{333e}
\createlinenumber{4527}{4506}
\createlinenumber{4528}{e1bf}
\createlinenumber{4529}{e4d4}
\createlinenumber{4530}{fe09}
\createlinenumber{4531}{95cf}
\begin{lstlisting}[language=C++]
// Mon = 0, ... % 7
// days since 1/1/1
// 从公元1年1月1日到给定日期（年 y、月 m、日 d）的天数
int getday(int y, int m, int d) {
    if (m < 3)
        --y, m += 12;
    return (365 * y + y / 4 - y / 100 + y / 400 + (153 * (m - 3) + 2) / 5 + d - 307);
}
// 自（公元1年1月1日）以来的n天数转换为y年m月d号
void date(int n, int& y, int& m, int& d) {
    n += 429 + ((4 * n + 1227) / 146097 + 1) * 3 / 4;
    y = (4 * n - 489) / 1461;
    n -= y * 1461 / 4;
    m = (5 * n - 1) / 153;
    d = n - m * 153 / 5;
    if (--m > 12)
        m -= 12, ++y;
}
// 已知年月日，求星期数。
int week(int y, int m, int d) {
    if (m <= 2)
        m += 12, y--;
    return (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7 + 1;
}
//-----------------------------------------------
//记忆版本
int months[13] = {
    0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

int is_leap(int year)//闰年判断
{
    if (year % 4 == 0 && year % 100 || year % 400 == 0)
        return 1;
    return 0;
}

int get_days(int y, int m)//给年月，输出日
{
    int s = months[m];
    if (m == 2) return s + is_leap(y);
    return s;
}
\end{lstlisting}
\subsection{表达式求值}
\createlinenumber{4532}{b58f}
\createlinenumber{4533}{8a4c}
\createlinenumber{4534}{7c0e}
\createlinenumber{4535}{af7e}
\createlinenumber{4536}{c478}
\createlinenumber{4537}{592c}
\createlinenumber{4538}{60f8}
\createlinenumber{4539}{1880}
\createlinenumber{4540}{427e}
\createlinenumber{4541}{956c}
\createlinenumber{4542}{4506}
\createlinenumber{4543}{ee66}
\createlinenumber{4544}{8f9c}
\createlinenumber{4545}{c772}
\createlinenumber{4546}{3c9e}
\createlinenumber{4547}{0ce5}
\createlinenumber{4548}{532b}
\createlinenumber{4549}{2c2c}
\createlinenumber{4550}{9201}
\createlinenumber{4551}{80ef}
\createlinenumber{4552}{95cf}
\createlinenumber{4553}{427e}
\createlinenumber{4554}{299c}
\createlinenumber{4555}{4506}
\createlinenumber{4556}{0959}
\createlinenumber{4557}{6363}
\createlinenumber{4558}{2593}
\createlinenumber{4559}{c282}
\createlinenumber{4560}{4506}
\createlinenumber{4561}{0451}
\createlinenumber{4562}{fd4c}
\createlinenumber{4563}{4506}
\createlinenumber{4564}{7fda}
\createlinenumber{4565}{5518}
\createlinenumber{4566}{26ed}
\createlinenumber{4567}{6e55}
\createlinenumber{4568}{80ef}
\createlinenumber{4569}{95cf}
\createlinenumber{4570}{1ed3}
\createlinenumber{4571}{9ac1}
\createlinenumber{4572}{4506}
\createlinenumber{4573}{bd15}
\createlinenumber{4574}{2df4}
\createlinenumber{4575}{95cf}
\createlinenumber{4576}{649a}
\createlinenumber{4577}{4506}
\createlinenumber{4578}{f027}
\createlinenumber{4579}{5e2b}
\createlinenumber{4580}{95cf}
\createlinenumber{4581}{95cf}
\createlinenumber{4582}{c07f}
\createlinenumber{4583}{2462}
\createlinenumber{4584}{7021}
\createlinenumber{4585}{95cf}
\begin{lstlisting}[language=C++]
给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。
数据保证给定的表达式合法。
题目保证符号 - 只作为减号出现，不会作为负号出现，例如，-1+2,(2+2)*(-(1+1)+2) 之类表达式均不会出现。
题目保证表达式中所有数字均为正整数。
题目保证表达式在中间计算过程以及结果中，均不超过 int
题目中的整除是指向 0取整,也就是说对于大于的结果向下取整，例如 5/3=1对于小于 0的结果向上取整,例如 5/(1-4)=-1
stack<int> num;
stack<char> op;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();
    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    string str;
    cin >> str;
    for (int i = 0; i < str.size(); i ++ )
    {
        auto c = str[i];
        if (isdigit(c))
        {
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j ++ ] - '0';
            i = j - 1;
            num.push(x);
        }
        else if (c == '(') op.push(c);
        else if (c == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[c]) eval();
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << num.top() << endl;
    return 0;
}
\end{lstlisting}
\subsection{魔方}
\createlinenumber{4586}{305c}
\createlinenumber{4587}{bfe0}
\createlinenumber{4588}{8a01}
\createlinenumber{4589}{1450}
\createlinenumber{4590}{b799}
\createlinenumber{4591}{6629}
\createlinenumber{4592}{afcc}
\createlinenumber{4593}{c888}
\createlinenumber{4594}{cf66}
\createlinenumber{4595}{dfbc}
\createlinenumber{4596}{9ea1}
\createlinenumber{4597}{427e}
\createlinenumber{4598}{63de}
\createlinenumber{4599}{1093}
\createlinenumber{4600}{b569}
\createlinenumber{4601}{4cf3}
\createlinenumber{4602}{3d88}
\createlinenumber{4603}{3d88}
\createlinenumber{4604}{6990}
\createlinenumber{4605}{6990}
\createlinenumber{4606}{6990}
\createlinenumber{4607}{eb99}
\createlinenumber{4608}{eb99}
\createlinenumber{4609}{eb99}
\createlinenumber{4610}{302f}
\createlinenumber{4611}{958b}
\createlinenumber{4612}{421c}
\createlinenumber{4613}{55e4}
\createlinenumber{4614}{427e}
\createlinenumber{4615}{c613}
\createlinenumber{4616}{4506}
\createlinenumber{4617}{dd38}
\createlinenumber{4618}{427e}
\createlinenumber{4619}{6d9f}
\createlinenumber{4620}{7dd1}
\createlinenumber{4621}{95cf}
\createlinenumber{4622}{427e}
\createlinenumber{4623}{7232}
\createlinenumber{4624}{4506}
\createlinenumber{4625}{fde1}
\createlinenumber{4626}{95cf}
\createlinenumber{4627}{427e}
\createlinenumber{4628}{0ac5}
\createlinenumber{4629}{4506}
\createlinenumber{4630}{bd64}
\createlinenumber{4631}{8eec}
\createlinenumber{4632}{438e}
\createlinenumber{4633}{95cf}
\createlinenumber{4634}{3361}
\createlinenumber{4635}{95cf}
\createlinenumber{4636}{427e}
\createlinenumber{4637}{09c2}
\createlinenumber{4638}{4506}
\createlinenumber{4639}{f529}
\createlinenumber{4640}{a5bd}
\createlinenumber{4641}{749f}
\createlinenumber{4642}{8808}
\createlinenumber{4643}{988f}
\createlinenumber{4644}{427e}
\createlinenumber{4645}{4fbb}
\createlinenumber{4646}{cd13}
\createlinenumber{4647}{482e}
\createlinenumber{4648}{f408}
\createlinenumber{4649}{39f9}
\createlinenumber{4650}{95cf}
\createlinenumber{4651}{427e}
\createlinenumber{4652}{2e11}
\createlinenumber{4653}{4506}
\createlinenumber{4654}{f529}
\createlinenumber{4655}{e2e1}
\createlinenumber{4656}{34d2}
\createlinenumber{4657}{b2cf}
\createlinenumber{4658}{f0d7}
\createlinenumber{4659}{427e}
\createlinenumber{4660}{4fbb}
\createlinenumber{4661}{62f3}
\createlinenumber{4662}{bc82}
\createlinenumber{4663}{7ebc}
\createlinenumber{4664}{7297}
\createlinenumber{4665}{95cf}
\createlinenumber{4666}{329b}
\createlinenumber{4667}{427e}
\createlinenumber{4668}{75ed}
\createlinenumber{4669}{4506}
\createlinenumber{4670}{d5ec}
\createlinenumber{4671}{427e}
\createlinenumber{4672}{c3ec}
\createlinenumber{4673}{07e2}
\createlinenumber{4674}{95cf}
\createlinenumber{4675}{427e}
\createlinenumber{4676}{88f1}
\createlinenumber{4677}{4506}
\createlinenumber{4678}{5baf}
\createlinenumber{4679}{1afd}
\createlinenumber{4680}{25b4}
\createlinenumber{4681}{1bd9}
\createlinenumber{4682}{19a2}
\createlinenumber{4683}{9ea1}
\createlinenumber{4684}{95cf}
\createlinenumber{4685}{427e}
\createlinenumber{4686}{0ac5}
\createlinenumber{4687}{4506}
\createlinenumber{4688}{94f5}
\createlinenumber{4689}{bfa1}
\createlinenumber{4690}{438e}
\createlinenumber{4691}{95cf}
\createlinenumber{4692}{3361}
\createlinenumber{4693}{95cf}
\createlinenumber{4694}{427e}
\createlinenumber{4695}{053c}
\createlinenumber{4696}{4506}
\createlinenumber{4697}{02d4}
\createlinenumber{4698}{0127}
\createlinenumber{4699}{07ac}
\createlinenumber{4700}{db65}
\createlinenumber{4701}{cdaa}
\createlinenumber{4702}{8d31}
\createlinenumber{4703}{a9b8}
\createlinenumber{4704}{86b5}
\createlinenumber{4705}{a0e3}
\createlinenumber{4706}{81e1}
\createlinenumber{4707}{8f63}
\createlinenumber{4708}{6127}
\createlinenumber{4709}{95cf}
\createlinenumber{4710}{427e}
\createlinenumber{4711}{b300}
\createlinenumber{4712}{4506}
\createlinenumber{4713}{02d4}
\createlinenumber{4714}{db65}
\createlinenumber{4715}{07ac}
\createlinenumber{4716}{0127}
\createlinenumber{4717}{cdaa}
\createlinenumber{4718}{86b5}
\createlinenumber{4719}{a9b8}
\createlinenumber{4720}{8d31}
\createlinenumber{4721}{a0e3}
\createlinenumber{4722}{6127}
\createlinenumber{4723}{8f63}
\createlinenumber{4724}{81e1}
\createlinenumber{4725}{95cf}
\createlinenumber{4726}{427e}
\createlinenumber{4727}{dc60}
\createlinenumber{4728}{8535}
\createlinenumber{4729}{427e}
\createlinenumber{4730}{0b39}
\createlinenumber{4731}{6441}
\createlinenumber{4732}{658c}
\createlinenumber{4733}{ec10}
\createlinenumber{4734}{8346}
\createlinenumber{4735}{427e}
\createlinenumber{4736}{519d}
\createlinenumber{4737}{95cf}
\createlinenumber{4738}{06d4}
\createlinenumber{4739}{c218}
\createlinenumber{4740}{427e}
\createlinenumber{4741}{1af3}
\createlinenumber{4742}{6441}
\createlinenumber{4743}{ec10}
\createlinenumber{4744}{ec10}
\createlinenumber{4745}{cc7f}
\createlinenumber{4746}{427e}
\createlinenumber{4747}{519d}
\createlinenumber{4748}{95cf}
\createlinenumber{4749}{427e}
\createlinenumber{4750}{3a6b}
\createlinenumber{4751}{7102}
\createlinenumber{4752}{427e}
\createlinenumber{4753}{4176}
\createlinenumber{4754}{fecc}
\createlinenumber{4755}{658c}
\createlinenumber{4756}{75d6}
\createlinenumber{4757}{8346}
\createlinenumber{4758}{427e}
\createlinenumber{4759}{519d}
\createlinenumber{4760}{95cf}
\createlinenumber{4761}{7cff}
\createlinenumber{4762}{30e0}
\createlinenumber{4763}{427e}
\createlinenumber{4764}{f05f}
\createlinenumber{4765}{fecc}
\createlinenumber{4766}{ec10}
\createlinenumber{4767}{75d6}
\createlinenumber{4768}{cc7f}
\createlinenumber{4769}{427e}
\createlinenumber{4770}{519d}
\createlinenumber{4771}{95cf}
\createlinenumber{4772}{427e}
\createlinenumber{4773}{d517}
\createlinenumber{4774}{03d5}
\createlinenumber{4775}{427e}
\createlinenumber{4776}{5ea2}
\createlinenumber{4777}{e866}
\createlinenumber{4778}{5fd5}
\createlinenumber{4779}{5fd5}
\createlinenumber{4780}{a368}
\createlinenumber{4781}{427e}
\createlinenumber{4782}{519d}
\createlinenumber{4783}{95cf}
\createlinenumber{4784}{e530}
\createlinenumber{4785}{01fb}
\createlinenumber{4786}{427e}
\createlinenumber{4787}{8058}
\createlinenumber{4788}{e866}
\createlinenumber{4789}{5fd5}
\createlinenumber{4790}{5fd5}
\createlinenumber{4791}{a368}
\createlinenumber{4792}{427e}
\createlinenumber{4793}{519d}
\createlinenumber{4794}{95cf}
\createlinenumber{4795}{427e}
\createlinenumber{4796}{f4ee}
\createlinenumber{4797}{4506}
\createlinenumber{4798}{4f48}
\createlinenumber{4799}{de66}
\createlinenumber{4800}{3374}
\createlinenumber{4801}{427e}
\createlinenumber{4802}{03c4}
\createlinenumber{4803}{2e84}
\createlinenumber{4804}{bb6d}
\createlinenumber{4805}{95cf}
\createlinenumber{4806}{427e}
\createlinenumber{4807}{75a0}
\createlinenumber{4808}{4f70}
\createlinenumber{4809}{44bf}
\createlinenumber{4810}{95cf}
\createlinenumber{4811}{427e}
\createlinenumber{4812}{23ee}
\createlinenumber{4813}{4506}
\createlinenumber{4814}{e18f}
\createlinenumber{4815}{427e}
\createlinenumber{4816}{0b39}
\createlinenumber{4817}{92af}
\createlinenumber{4818}{55e9}
\createlinenumber{4819}{9835}
\createlinenumber{4820}{95cf}
\createlinenumber{4821}{95cf}
\createlinenumber{4822}{427e}
\createlinenumber{4823}{0b39}
\createlinenumber{4824}{92af}
\createlinenumber{4825}{55e9}
\createlinenumber{4826}{cb77}
\createlinenumber{4827}{95cf}
\createlinenumber{4828}{92af}
\createlinenumber{4829}{55e9}
\createlinenumber{4830}{ab00}
\createlinenumber{4831}{95cf}
\createlinenumber{4832}{92af}
\createlinenumber{4833}{55e9}
\createlinenumber{4834}{bba5}
\createlinenumber{4835}{95cf}
\createlinenumber{4836}{92af}
\createlinenumber{4837}{55e9}
\createlinenumber{4838}{b8f3}
\createlinenumber{4839}{95cf}
\createlinenumber{4840}{95cf}
\createlinenumber{4841}{427e}
\createlinenumber{4842}{0b39}
\createlinenumber{4843}{92af}
\createlinenumber{4844}{55e9}
\createlinenumber{4845}{8920}
\createlinenumber{4846}{95cf}
\createlinenumber{4847}{95cf}
\createlinenumber{4848}{427e}
\createlinenumber{4849}{d224}
\createlinenumber{4850}{95cf}
\createlinenumber{4851}{427e}
\createlinenumber{4852}{4906}
\createlinenumber{4853}{4506}
\createlinenumber{4854}{0b39}
\createlinenumber{4855}{3bf1}
\createlinenumber{4856}{92af}
\createlinenumber{4857}{81a6}
\createlinenumber{4858}{7519}
\createlinenumber{4859}{74a5}
\createlinenumber{4860}{95cf}
\createlinenumber{4861}{b183}
\createlinenumber{4862}{95cf}
\createlinenumber{4863}{427e}
\createlinenumber{4864}{0b39}
\createlinenumber{4865}{92af}
\createlinenumber{4866}{fa54}
\createlinenumber{4867}{95cf}
\createlinenumber{4868}{92af}
\createlinenumber{4869}{5f14}
\createlinenumber{4870}{95cf}
\createlinenumber{4871}{92af}
\createlinenumber{4872}{cea4}
\createlinenumber{4873}{95cf}
\createlinenumber{4874}{92af}
\createlinenumber{4875}{97cf}
\createlinenumber{4876}{7519}
\createlinenumber{4877}{74a5}
\createlinenumber{4878}{95cf}
\createlinenumber{4879}{b183}
\createlinenumber{4880}{95cf}
\createlinenumber{4881}{427e}
\createlinenumber{4882}{0b39}
\createlinenumber{4883}{3bf1}
\createlinenumber{4884}{92af}
\createlinenumber{4885}{f2a0}
\createlinenumber{4886}{7519}
\createlinenumber{4887}{74a5}
\createlinenumber{4888}{95cf}
\createlinenumber{4889}{b183}
\createlinenumber{4890}{95cf}
\createlinenumber{4891}{427e}
\createlinenumber{4892}{d224}
\createlinenumber{4893}{95cf}
\createlinenumber{4894}{329b}
\createlinenumber{4895}{427e}
\createlinenumber{4896}{427e}
\createlinenumber{4897}{427e}
\createlinenumber{4898}{a41b}
\createlinenumber{4899}{4506}
\createlinenumber{4900}{633f}
\createlinenumber{4901}{4f2d}
\createlinenumber{4902}{427e}
\createlinenumber{4903}{9452}
\createlinenumber{4904}{e277}
\createlinenumber{4905}{b2d7}
\createlinenumber{4906}{c3eb}
\createlinenumber{4907}{7329}
\createlinenumber{4908}{649a}
\createlinenumber{4909}{61d9}
\createlinenumber{4910}{95cf}
\createlinenumber{4911}{427e}
\createlinenumber{4912}{4e56}
\createlinenumber{4913}{5fd5}
\createlinenumber{4914}{b333}
\createlinenumber{4915}{427e}
\createlinenumber{4916}{11c5}
\createlinenumber{4917}{b884}
\createlinenumber{4918}{427e}
\createlinenumber{4919}{18bc}
\createlinenumber{4920}{feea}
\createlinenumber{4921}{4f2d}
\createlinenumber{4922}{95cf}
\createlinenumber{4923}{427e}
\createlinenumber{4924}{0192}
\createlinenumber{4925}{427e}
\createlinenumber{4926}{fbd4}
\createlinenumber{4927}{4f2d}
\createlinenumber{4928}{427e}
\createlinenumber{4929}{85ee}
\createlinenumber{4930}{faf7}
\createlinenumber{4931}{95cf}
\createlinenumber{4932}{95cf}
\createlinenumber{4933}{427e}
\createlinenumber{4934}{7a09}
\createlinenumber{4935}{4506}
\createlinenumber{4936}{cf30}
\createlinenumber{4937}{427e}
\createlinenumber{4938}{95d5}
\createlinenumber{4939}{3742}
\createlinenumber{4940}{7b51}
\createlinenumber{4941}{bcd0}
\createlinenumber{4942}{427e}
\createlinenumber{4943}{a59d}
\createlinenumber{4944}{427e}
\createlinenumber{4945}{cc78}
\createlinenumber{4946}{4a08}
\createlinenumber{4947}{15dd}
\createlinenumber{4948}{9452}
\createlinenumber{4949}{fd28}
\createlinenumber{4950}{7f77}
\createlinenumber{4951}{c3eb}
\createlinenumber{4952}{7329}
\createlinenumber{4953}{649a}
\createlinenumber{4954}{61d9}
\createlinenumber{4955}{95cf}
\createlinenumber{4956}{427e}
\createlinenumber{4957}{4e56}
\createlinenumber{4958}{5fd5}
\createlinenumber{4959}{b333}
\createlinenumber{4960}{427e}
\createlinenumber{4961}{591c}
\createlinenumber{4962}{7ee3}
\createlinenumber{4963}{5c23}
\createlinenumber{4964}{427e}
\createlinenumber{4965}{5dd5}
\createlinenumber{4966}{1e66}
\createlinenumber{4967}{4206}
\createlinenumber{4968}{95cf}
\createlinenumber{4969}{427e}
\createlinenumber{4970}{e1fe}
\createlinenumber{4971}{95cf}
\createlinenumber{4972}{95cf}
\createlinenumber{4973}{427e}
\createlinenumber{4974}{4206}
\createlinenumber{4975}{95cf}
\createlinenumber{4976}{427e}
\createlinenumber{4977}{9627}
\createlinenumber{4978}{11b7}
\createlinenumber{4979}{2977}
\createlinenumber{4980}{427e}
\createlinenumber{4981}{18bc}
\createlinenumber{4982}{1abe}
\createlinenumber{4983}{4f2d}
\createlinenumber{4984}{95cf}
\createlinenumber{4985}{427e}
\createlinenumber{4986}{a59d}
\createlinenumber{4987}{427e}
\createlinenumber{4988}{427e}
\createlinenumber{4989}{427e}
\createlinenumber{4990}{e552}
\createlinenumber{4991}{a33b}
\createlinenumber{4992}{427e}
\createlinenumber{4993}{fd35}
\createlinenumber{4994}{427e}
\createlinenumber{4995}{ce82}
\createlinenumber{4996}{903f}
\createlinenumber{4997}{e8f6}
\createlinenumber{4998}{7eb5}
\createlinenumber{4999}{95cf}
\createlinenumber{5000}{95cf}
\createlinenumber{5001}{427e}
\createlinenumber{5002}{3117}
\createlinenumber{5003}{5411}
\createlinenumber{5004}{6ac0}
\createlinenumber{5005}{427e}
\createlinenumber{5006}{96ff}
\createlinenumber{5007}{ccd1}
\createlinenumber{5008}{7021}
\createlinenumber{5009}{95cf}
\createlinenumber{5010}{427e}
\createlinenumber{5011}{427e}
\createlinenumber{5012}{427e}
\begin{lstlisting}[language=C++]
本题的输入是一个魔方的展开图，我们以黄色为中心块的面作为顶面，红色为中心块的面作为前面，绿色为中心块的面作为右面。
定义六种魔方转动操作类型，分别如下：
1. "R1"：右面顺时针旋转90度
2. "R2"：右面逆时针旋转90度
3. "U1"：顶面顺时针旋转90度
4. "U2"：顶面逆时针旋转90度
5. "F1"：前面顺时针旋转90度
6. "F2"：前面逆时针旋转90度
Sol：
特殊限制：存在 6 种不同操作，且一定存在步数小于等于 8 的正解
直接暴力 dfs 或 bfs 搜索答案即可。

考虑魔方在转动某一面时，转动面的 9 个颜色会进行顺时针或逆时针移位，与转动面相邻的 4 个侧面中，直接
与转动面相邻的 3 个颜色也会按顺时针或逆时针顺序循环移位。故可使用 struct Plane 定义一个面按顺序排列的九种
颜色，结构体内部实现单面的顺时针或逆时针移位。使用 struct Cube 定义整个魔方的状态，每次操作先转动单面，
再按顺序移位相邻 4 个侧面中的 3 个相邻颜色即可。
      O O O
      O O O
B B B Y Y Y G G G W W W
B B B Y Y Y G G G W W W
B B B Y Y Y G G G W W W
      R R R
      R R R
      R R R 
#include <bits/stdc++.h>
#define Buff ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr)
using namespace std;
typedef vector<char> vchar;

struct Plane  // 面
{
    char c[9];

    Plane() {
        memset(c, 0, sizeof(c));
    }

    void set(char x)  // 设置颜色，本题非必要
    {
        memset(c, x, sizeof(c));
    }

    bool check() const  // 判断此面颜色是否相同
    {
        for (int i = 1; i < 9; i++) {
            if (c[i] != c[0])
                return false;
        }
        return true;
    }

    void CRotate()  // 此面顺时针旋转90度
    {
        char b = c[0];
        c[0] = c[6];
        c[6] = c[8];
        c[8] = c[2];
        c[2] = b;

        b = c[1];
        c[1] = c[3];
        c[3] = c[7];
        c[7] = c[5];
        c[5] = b;
    }

    void CCRotate()  // 此面逆时针旋转90度
    {
        char b = c[0];
        c[0] = c[2];
        c[2] = c[8];
        c[8] = c[6];
        c[6] = b;

        b = c[1];
        c[1] = c[5];
        c[5] = c[7];
        c[7] = c[3];
        c[3] = b;
    }
};

struct Cube  // 魔方
{
    Plane p[6];

    Cube() {
        init();
    }

    void init()  // 初始化颜色，本题非必要
    {
        p[0].set('R');
        p[1].set('G');
        p[2].set('Y');
        p[3].set('O');
        p[4].set('B');
        p[5].set('W');
    }

    bool check() const  // 判断是否已还原
    {
        for (int i = 0; i < 6; i++) {
            if (!p[i].check())
                return false;
        }
        return true;
    }

    void operate(int opid)  // 操作
    {
        if (opid == 1)
            R1();
        else if (opid == 2)
            R2();
        else if (opid == 3)
            U1();
        else if (opid == 4)
            U2();
        else if (opid == 5)
            F1();
        else if (opid == 6)
            F2();
    }

    void roperate(int opid)  // 逆操作
    {
        if (opid == 1)
            R2();
        else if (opid == 2)
            R1();
        else if (opid == 3)
            U2();
        else if (opid == 4)
            U1();
        else if (opid == 5)
            F2();
        else if (opid == 6)
            F1();
    }

    void R1() {
        p[1].CRotate();  // 旋转面

        int updateplane[4] = {0, 5, 3, 2};  // 需要按顺序移位的相邻面
        int updateid[4][3] = {{2, 5, 8},    // 每面需要移位的颜色下标
                              {6, 3, 0},
                              {2, 5, 8},
                              {2, 5, 8}};

        update(updateid, updateplane);
    }
    void R2() {
        p[1].CCRotate();

        int updateplane[4] = {0, 2, 3, 5};
        int updateid[4][3] = {{2, 5, 8},
                              {2, 5, 8},
                              {2, 5, 8},
                              {6, 3, 0}};

        update(updateid, updateplane);
    }

    void U1() {
        p[2].CRotate();

        int updateplane[4] = {0, 1, 3, 4};
        int updateid[4][3] = {{0, 1, 2},
                              {6, 3, 0},
                              {8, 7, 6},
                              {2, 5, 8}};

        update(updateid, updateplane);
    }
    void U2() {
        p[2].CCRotate();

        int updateplane[4] = {0, 4, 3, 1};
        int updateid[4][3] = {{0, 1, 2},
                              {2, 5, 8},
                              {8, 7, 6},
                              {6, 3, 0}};

        update(updateid, updateplane);
    }

    void F1() {
        p[0].CRotate();

        int updateplane[4] = {1, 2, 4, 5};
        int updateid[4][3] = {{6, 7, 8},
                              {6, 7, 8},
                              {6, 7, 8},
                              {6, 7, 8}};

        update(updateid, updateplane);
    }
    void F2() {
        p[0].CCRotate();

        int updateplane[4] = {1, 5, 4, 2};
        int updateid[4][3] = {{6, 7, 8},
                              {6, 7, 8},
                              {6, 7, 8},
                              {6, 7, 8}};

        update(updateid, updateplane);
    }

    void update(int uid[4][3], int uplane[4])  // 循环移位相邻面颜色
    {
        char buffer[3] = {p[uplane[0]].c[uid[0][0]],
                          p[uplane[0]].c[uid[0][1]],
                          p[uplane[0]].c[uid[0][2]]};

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++)
                p[uplane[i]].c[uid[i][j]] = p[uplane[i + 1]].c[uid[i + 1][j]];
        }

        p[uplane[3]].c[uid[3][0]] = buffer[0];
        p[uplane[3]].c[uid[3][1]] = buffer[1];
        p[uplane[3]].c[uid[3][2]] = buffer[2];
    }

    friend std::istream& operator>>(std::istream& os, Cube& cube)  // 输入
    {
        std::string buffer;

        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[3].c[i + j] = buffer[0];
            }
        }

        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[4].c[i + j] = buffer[0];
            }
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[2].c[i + j] = buffer[0];
            }
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[1].c[i + j] = buffer[0];
            }
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[5].c[i + j] = buffer[0];
            }
        }

        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 3; j++) {
                os >> buffer;
                cube.p[0].c[i + j] = buffer[0];
            }
        }

        return os;
    }

    friend std::ostream& operator<<(std::ostream& os, const Cube& cube)  // 输出，本题非必要
    {
        for (int i = 0; i < 9; i += 3) {
            os << "      ";
            for (int j = 0; j < 3; j++) {
                os << cube.p[3].c[i + j];
                if (j < 2)
                    os << ' ';
            }
            os << '\n';
        }

        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 3; j++) {
                os << cube.p[4].c[i + j] << ' ';
            }
            for (int j = 0; j < 3; j++) {
                os << cube.p[2].c[i + j] << ' ';
            }
            for (int j = 0; j < 3; j++) {
                os << cube.p[1].c[i + j] << ' ';
            }
            for (int j = 0; j < 3; j++) {
                os << cube.p[5].c[i + j];
                if (j < 2)
                    os << ' ';
            }
            os << '\n';
        }

        for (int i = 0; i < 9; i += 3) {
            os << "      ";
            for (int j = 0; j < 3; j++) {
                os << cube.p[0].c[i + j];
                if (j < 2)
                    os << ' ';
            }
            os << '\n';
        }

        return os;
    }
};

/////////////////////////////////////////////////////////////////////////////////

void dfs(Cube& cube, vchar& way, bool& flag, size_t stop)  // dfs深搜
{
    if (way.size() >= stop)
        return;

    char ref = -1;  // 上次操作的逆操作序号
    if (!way.empty()) {
        ref = *(way.rbegin());
        if (ref & 1)
            ref++;
        else
            ref--;
    }

    for (char i = 1; i <= 6; i++) {
        if (i == ref)  // 剪枝
            continue;

        cube.operate(i);
        way.emplace_back(i);

        if (cube.check()) {
            flag = true;
            return;
        }

        dfs(cube, way, flag, stop);

        if (flag)
            return;

        cube.roperate(i);  // 回溯
        way.pop_back();
    }
}

vchar bfs(Cube icube)  // bfs宽搜
{
    using pcv = pair<Cube, vchar>;  // 保存的魔方状态以及操作顺序

    pcv ib;
    ib.first = icube;
    queue<pcv> q;
    q.push(ib);

    vchar ans;

    while (!q.empty()) {
        pcv b = q.front();
        q.pop();
        char ref = -1;  // 上次操作的逆操作序号
        if (!b.second.empty()) {
            ref = *(b.second.rbegin());
            if (ref & 1)
                ref++;
            else
                ref--;
        }

        for (char i = 1; i <= 6; i++) {
            if (i == ref)
                continue;

            pcv x = b;
            x.first.operate(i);
            x.second.emplace_back(i);

            if (x.first.check()) {
                ans = x.second;
                return ans;
            }

            q.push(x);
        }
    }

    return ans;
}

void solve() {
    Cube cube;
    cin >> cube;

    if (cube.check()) {
        cout << "0\n";
        return;
    }

    vchar ans;

    // ans = bfs(cube); // bfs调用

    bool flag = false;
    dfs(cube, ans, flag, 8);  // dfs调用

    cout << ans.size() << '\n';

    vector<string> map_op{"", "R1", "R2", "U1", "U2", "F1", "F2"};  // 操作映射
    for (char i : ans) {
        if (i >= 1 && i <= 6)
            cout << map_op[i] << '\n';
    }
}

int main() {
    Buff;
    int _N = 1;
    // cin >> _N;
    while (_N--)
        solve();
    return 0;
}



\end{lstlisting}
\section{STL}
\subsection{\_\_int128\_RW}
\createlinenumber{5013}{427e}
\createlinenumber{5014}{fa58}
\createlinenumber{5015}{0f1b}
\createlinenumber{5016}{9087}
\createlinenumber{5017}{88b9}
\createlinenumber{5018}{a815}
\createlinenumber{5019}{c707}
\createlinenumber{5020}{1521}
\createlinenumber{5021}{75d5}
\createlinenumber{5022}{95cf}
\createlinenumber{5023}{76bb}
\createlinenumber{5024}{c7d7}
\createlinenumber{5025}{fa9e}
\createlinenumber{5026}{5b4e}
\createlinenumber{5027}{a5a2}
\createlinenumber{5028}{7044}
\createlinenumber{5029}{95cf}
\begin{lstlisting}[language=C++]
// 需要开同步流！！！
__int128 read() {
    __int128 X = 0, f = 1;
    char c = getchar();
    while (!isdigit(c) && c != '-') c = getchar();
    if (c == '-')
        c = getchar(), f = -1;
    while (isdigit(c)) X = X * 10 + (c ^ 48), c = getchar();
    return X * f;
}
void write(__int128 x) {
    if (x < 0)
        x = -x, putchar('-');
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
\end{lstlisting}
\subsection{\_\_int128\_gcd}
\createlinenumber{5030}{dca2}
\createlinenumber{5031}{510a}
\createlinenumber{5032}{5fd6}
\createlinenumber{5033}{95cf}
\begin{lstlisting}[language=C++]
using i128 = __int128;
i128 gcd(i128 a, i128 b) {
    return b ? gcd(b, a % b) : a;
}
\end{lstlisting}
\subsection{\_\_int128\_iostream}
\createlinenumber{5034}{a5f4}
\createlinenumber{5035}{1f7d}
\createlinenumber{5036}{c851}
\createlinenumber{5037}{6505}
\createlinenumber{5038}{959a}
\createlinenumber{5039}{cd48}
\createlinenumber{5040}{a815}
\createlinenumber{5041}{5d16}
\createlinenumber{5042}{e5af}
\createlinenumber{5043}{57e0}
\createlinenumber{5044}{959a}
\createlinenumber{5045}{95cf}
\createlinenumber{5046}{4b1e}
\createlinenumber{5047}{338d}
\createlinenumber{5048}{95cf}
\createlinenumber{5049}{26bb}
\createlinenumber{5050}{6c3f}
\createlinenumber{5051}{e290}
\createlinenumber{5052}{de1b}
\createlinenumber{5053}{cdbf}
\createlinenumber{5054}{95cf}
\createlinenumber{5055}{343a}
\createlinenumber{5056}{4389}
\createlinenumber{5057}{95cf}
\begin{lstlisting}[language=C++]
istream &operator>>(istream &is, __int128 &T) {
    char c;
    int f = 1;
    T = 0;
    c = is.get();
    while (c != '-' && !isdigit(c)) c = is.get();
    if (c == '-')
        f = -1, c = is.get();
    while (isdigit(c)) {
        T = T * 10 + (c - '0');
        c = is.get();
    }
    T = f * T;
    return is;
}
std::ostream &operator<<(std::ostream &os, __int128 &n) {
    std::string s;
    while (n) {
        s += '0' + n % 10;
        n /= 10;
    }
    std::reverse(s.begin(), s.end());
    return os << s;
}
\end{lstlisting}
\subsection{chmax}
\createlinenumber{5058}{0c7b}
\createlinenumber{5059}{4160}
\createlinenumber{5060}{9e10}
\createlinenumber{5061}{bcb8}
\createlinenumber{5062}{95cf}
\createlinenumber{5063}{95cf}
\begin{lstlisting}[language=C++]
template<class T>
void chmax(T &a, T b) {
    if (a < b) {
        a = b;
    }
}
\end{lstlisting}
\subsection{custom\_hash}
\createlinenumber{5064}{6e0a}
\createlinenumber{5065}{b1ca}
\createlinenumber{5066}{c577}
\createlinenumber{5067}{08c1}
\createlinenumber{5068}{993c}
\createlinenumber{5069}{5a0b}
\createlinenumber{5070}{95cf}
\createlinenumber{5071}{427e}
\createlinenumber{5072}{09e4}
\createlinenumber{5073}{b4b1}
\createlinenumber{5074}{e3f7}
\createlinenumber{5075}{95cf}
\createlinenumber{5076}{329b}
\createlinenumber{5077}{427e}
\begin{lstlisting}[language=C++]
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
//unordered_map<int,int,custom_hash>mp;
\end{lstlisting}
\subsection{div}
\createlinenumber{5078}{3c92}
\createlinenumber{5079}{354b}
\createlinenumber{5080}{4928}
\createlinenumber{5081}{0e94}
\createlinenumber{5082}{8e2e}
\createlinenumber{5083}{259f}
\createlinenumber{5084}{95cf}
\createlinenumber{5085}{95cf}
\createlinenumber{5086}{427e}
\createlinenumber{5087}{72c1}
\createlinenumber{5088}{4928}
\createlinenumber{5089}{259f}
\createlinenumber{5090}{8e2e}
\createlinenumber{5091}{cc2e}
\createlinenumber{5092}{95cf}
\createlinenumber{5093}{95cf}
\createlinenumber{5094}{427e}
\begin{lstlisting}[language=C++]
using i64 = long long;
i64 ceilDiv(i64 n, i64 m) {
    if (n >= 0) {
        return (n + m - 1) / m;
    } else {
        return n / m;
    }
}
 
i64 floorDiv(i64 n, i64 m) {
    if (n >= 0) {
        return n / m;
    } else {
        return (n - m + 1) / m;
    }
}

\end{lstlisting}
\subsection{pair\_hash}
\createlinenumber{5095}{4ca1}
\createlinenumber{5096}{6732}
\createlinenumber{5097}{65da}
\createlinenumber{5098}{460c}
\createlinenumber{5099}{b99c}
\createlinenumber{5100}{1e72}
\createlinenumber{5101}{95cf}
\createlinenumber{5102}{329b}
\createlinenumber{5103}{427e}
\createlinenumber{5104}{427e}
\begin{lstlisting}[language=C++]
struct pair_hash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2> &p) const {
        auto hash1 = std::hash<T1>{}(p.first);
        auto hash2 = std::hash<T2>{}(p.second);
        return hash1 ^ (hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2));
    }
};
// std::unordered_map<std::pair<int, int>, int, pair_hash> mp;

\end{lstlisting}
\subsection{sqrt}
\createlinenumber{5105}{aa32}
\createlinenumber{5106}{2ca8}
\createlinenumber{5107}{1b5a}
\createlinenumber{5108}{4dfd}
\createlinenumber{5109}{95cf}
\createlinenumber{5110}{f12c}
\createlinenumber{5111}{85be}
\createlinenumber{5112}{95cf}
\createlinenumber{5113}{fe09}
\createlinenumber{5114}{95cf}
\createlinenumber{5115}{427e}
\begin{lstlisting}[language=C++]
long long mysqrt(long long n) {
    long long s = std::sqrt(n);
    while (s * s > n) {
        s--;
    }
    while ((s + 1) * (s + 1) <= n) {
        s++;
    }
    return s;
}

\end{lstlisting}
\section{String}
\subsection{AC}
\createlinenumber{5116}{7ba6}
\createlinenumber{5117}{44a1}
\createlinenumber{5118}{80b8}
\createlinenumber{5119}{57b7}
\createlinenumber{5120}{21c8}
\createlinenumber{5121}{2a6e}
\createlinenumber{5122}{427e}
\createlinenumber{5123}{7b7c}
\createlinenumber{5124}{329b}
\createlinenumber{5125}{427e}
\createlinenumber{5126}{2eb3}
\createlinenumber{5127}{427e}
\createlinenumber{5128}{6d9f}
\createlinenumber{5129}{07e2}
\createlinenumber{5130}{95cf}
\createlinenumber{5131}{427e}
\createlinenumber{5132}{5d53}
\createlinenumber{5133}{e343}
\createlinenumber{5134}{0291}
\createlinenumber{5135}{7409}
\createlinenumber{5136}{95cf}
\createlinenumber{5137}{427e}
\createlinenumber{5138}{05c4}
\createlinenumber{5139}{35c2}
\createlinenumber{5140}{c105}
\createlinenumber{5141}{95cf}
\createlinenumber{5142}{427e}
\createlinenumber{5143}{5624}
\createlinenumber{5144}{76f1}
\createlinenumber{5145}{d54b}
\createlinenumber{5146}{96ef}
\createlinenumber{5147}{07ab}
\createlinenumber{5148}{2e52}
\createlinenumber{5149}{b602}
\createlinenumber{5150}{95cf}
\createlinenumber{5151}{3486}
\createlinenumber{5152}{95cf}
\createlinenumber{5153}{e149}
\createlinenumber{5154}{95cf}
\createlinenumber{5155}{427e}
\createlinenumber{5156}{ec07}
\createlinenumber{5157}{93d2}
\createlinenumber{5158}{0618}
\createlinenumber{5159}{427e}
\createlinenumber{5160}{cc78}
\createlinenumber{5161}{a45e}
\createlinenumber{5162}{15dd}
\createlinenumber{5163}{427e}
\createlinenumber{5164}{0d82}
\createlinenumber{5165}{869d}
\createlinenumber{5166}{872b}
\createlinenumber{5167}{8e2e}
\createlinenumber{5168}{610f}
\createlinenumber{5169}{6926}
\createlinenumber{5170}{95cf}
\createlinenumber{5171}{95cf}
\createlinenumber{5172}{95cf}
\createlinenumber{5173}{95cf}
\createlinenumber{5174}{427e}
\createlinenumber{5175}{3ef7}
\createlinenumber{5176}{2de7}
\createlinenumber{5177}{95cf}
\createlinenumber{5178}{427e}
\createlinenumber{5179}{a000}
\createlinenumber{5180}{2b18}
\createlinenumber{5181}{95cf}
\createlinenumber{5182}{427e}
\createlinenumber{5183}{aad1}
\createlinenumber{5184}{9f38}
\createlinenumber{5185}{95cf}
\createlinenumber{5186}{427e}
\createlinenumber{5187}{6bba}
\createlinenumber{5188}{1031}
\createlinenumber{5189}{95cf}
\createlinenumber{5190}{329b}
\createlinenumber{5191}{427e}
\createlinenumber{5192}{9627}
\createlinenumber{5193}{1f21}
\createlinenumber{5194}{e1b6}
\createlinenumber{5195}{c1c9}
\createlinenumber{5196}{6dbf}
\createlinenumber{5197}{b301}
\createlinenumber{5198}{d694}
\createlinenumber{5199}{ef28}
\createlinenumber{5200}{95cf}
\createlinenumber{5201}{427e}
\createlinenumber{5202}{cd81}
\createlinenumber{5203}{5c5d}
\createlinenumber{5204}{76f1}
\createlinenumber{5205}{fabd}
\createlinenumber{5206}{2c41}
\createlinenumber{5207}{a259}
\createlinenumber{5208}{427e}
\createlinenumber{5209}{9246}
\createlinenumber{5210}{356f}
\createlinenumber{5211}{0820}
\createlinenumber{5212}{211e}
\createlinenumber{5213}{3f09}
\createlinenumber{5214}{7793}
\createlinenumber{5215}{95cf}
\createlinenumber{5216}{15fb}
\createlinenumber{5217}{1785}
\createlinenumber{5218}{95f1}
\createlinenumber{5219}{a6f0}
\createlinenumber{5220}{95cf}
\createlinenumber{5221}{a623}
\createlinenumber{5222}{2aa8}
\createlinenumber{5223}{0479}
\createlinenumber{5224}{8449}
\createlinenumber{5225}{95cf}
\createlinenumber{5226}{329b}
\createlinenumber{5227}{d2ce}
\createlinenumber{5228}{bbed}
\createlinenumber{5229}{95cf}
\begin{lstlisting}[language=C++]
struct AC {                         // 定义了AhoCorasick结构体，用于实现Aho-Corasick字符串匹配算法
    static constexpr int asz = 26;  // 定义常量ALPHABET为26，表示字母表的大小（26个小写字母）
    struct Node {                   // 定义了内部结构体Node，表示Trie树的一个节点
        int len;                    // 节点对应的字符串的长度
        int fail;                   // 节点的后缀链接，指向最长的可以匹配的后缀节点
        array<int, asz> next;
        // 表示从当前节点到下一个节点的转换，数组大小为字母表大小
        Node() : len{0}, fail{0}, next{} {}  // 构造函数，初始化len为0，link为0，next数组全为0
    };

    vector<Node> t;  // 定义一个Node类型的向量，存储Trie树中的所有节点

    AC() {  // 构造函数，调用init函数初始化Trie树
        init();
    }

    void init() {             // 初始化Trie树，创建根节点和伪根节点
        t.assign(2, Node());  // 创建两个节点，分别是根节点和伪根节点
        t[0].next.fill(1);    // 将根节点的所有next指向伪根节点
        t[0].len = -1;        // 设置根节点的len为-1
    }

    int newNode() {           // 创建一个新节点，并返回其索引
        t.emplace_back();     // 向向量t中添加一个新的Node节点
        return t.size() - 1;  // 返回新节点的索引
    }

    int add(const string &a) {                       // 向Trie树中添加字符串，并返回最后一个字符对应的节点索引
        int p = 1;                                   // 从伪根节点开始
        for (auto c : a) {                           // 遍历字符串中的每个字符
            int x = c - 'a';                         // 计算字符在字母表中的索引
            if (t[p].next[x] == 0) {                 // 如果当前字符的路径不存在
                t[p].next[x] = newNode();            // 创建新节点，并更新next数组
                t[t[p].next[x]].len = t[p].len + 1;  // 设置新节点的len为当前节点len加1
            }
            p = t[p].next[x];  // 移动到下一个节点
        }
        return p;  // 返回最后一个字符对应的节点索引
    }

    void work() {      // 构建Aho-Corasick自动机的后缀链接
        queue<int> q;  // 创建队列，用于广度优先搜索
        q.push(1);     // 将伪根节点加入队列

        while (!q.empty()) {    // 当队列不为空时，进行循环
            int x = q.front();  // 取出队列头部的节点
            q.pop();            // 移除队列头部的节点

            for (int i = 0; i < asz; i++) {                       // 遍历所有可能的字符
                if (t[x].next[i] == 0) {                          // 如果当前节点没有对应字符的转移
                    t[x].next[i] = t[t[x].fail].next[i];          // 设置为后缀链接节点的对应转移
                } else {                                          // 如果有对应字符的转移
                    t[t[x].next[i]].fail = t[t[x].fail].next[i];  // 设置新节点的后缀链接
                    q.push(t[x].next[i]);                         // 将新节点加入队列
                }
            }
        }
    }

    int next(int p, int x) {  // 获取节点p的字符x的转移
        return t[p].next[x];
    }

    int fail(int p) {  // 获取节点p的后缀链接
        return t[p].fail;
    }

    int len(int p) {  // 获取节点p对应的字符串长度
        return t[p].len;
    }

    int size() {  // 获取Trie树的节点总数
        return t.size();
    }
};

void solve() {
    AC ac;
    cin >> n;
    vector<int> id(n + 1);
    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        id[i] = ac.add(s);
    }

    ac.work();
    string tt;
    int p = 1;
    cin >> tt;
    int tot = ac.size();
    vector<int> sz(tot);

    m = tt.size();
    for (int i = 0; i < m; i++) {
        int ch = tt[i] - 'a';
        p = ac.next(p, ch);
        sz[p] += 1;
        deb(p);
    }
    vector<vector<int>> e(tot);
    for (int i = 2; i < tot; i++) {
        deb(i, ac.fail(i));
        e[ac.fail(i)].push_back(i);
    }
    auto dfs = [&](auto self, int u) -> void {
        for (auto v : e[u]) {
            self(self, v);
            sz[u] += sz[v];
        }
    };
    dfs(dfs, 1);
    for (int i = 1; i <= n; i++) cout << sz[id[i]] << endl;
}
\end{lstlisting}
\subsection{EXKMP}
\createlinenumber{5230}{414c}
\createlinenumber{5231}{3e99}
\createlinenumber{5232}{e7a9}
\createlinenumber{5233}{cc33}
\createlinenumber{5234}{427e}
\createlinenumber{5235}{c6cb}
\createlinenumber{5236}{8a92}
\createlinenumber{5237}{ca76}
\createlinenumber{5238}{d5dc}
\createlinenumber{5239}{037f}
\createlinenumber{5240}{0520}
\createlinenumber{5241}{89b3}
\createlinenumber{5242}{95cf}
\createlinenumber{5243}{8d06}
\createlinenumber{5244}{1bf2}
\createlinenumber{5245}{b85b}
\createlinenumber{5246}{95cf}
\createlinenumber{5247}{95cf}
\createlinenumber{5248}{6101}
\createlinenumber{5249}{95cf}
\begin{lstlisting}[language=C++]
vector<int> exkmp(string s){
	int len=s.size();
	s=" "+s;
	vector<int>z(len+1);
	
	z[1]=0;
	int l=1,r=0;
	for(int i=2;i<=len;i++){
		if(i>r)z[i]=0;
		else {//利用之前的信息
			int k=i-l+1;
			z[i]=min(z[k],r-i+1);
		}
		while(i+z[i]<=len&&s[z[i]+1]==s[i+z[i]])z[i]++;
		if(i+z[i]-1>r){
			l=i;r=i+z[i]-1;
		}
	}
	return z;
}
\end{lstlisting}
\subsection{Hash}
\createlinenumber{5250}{fbc9}
\createlinenumber{5251}{2202}
\createlinenumber{5252}{b51c}
\createlinenumber{5253}{e7a7}
\createlinenumber{5254}{427e}
\createlinenumber{5255}{f235}
\createlinenumber{5256}{6d32}
\createlinenumber{5257}{c93c}
\createlinenumber{5258}{1026}
\createlinenumber{5259}{34be}
\createlinenumber{5260}{ce56}
\createlinenumber{5261}{1270}
\createlinenumber{5262}{563d}
\createlinenumber{5263}{f563}
\createlinenumber{5264}{6173}
\createlinenumber{5265}{95cf}
\createlinenumber{5266}{95cf}
\createlinenumber{5267}{28cf}
\createlinenumber{5268}{c757}
\createlinenumber{5269}{95cf}
\createlinenumber{5270}{95cf}
\createlinenumber{5271}{427e}
\createlinenumber{5272}{db11}
\createlinenumber{5273}{2243}
\createlinenumber{5274}{a976}
\createlinenumber{5275}{7f5d}
\createlinenumber{5276}{7d96}
\createlinenumber{5277}{b301}
\createlinenumber{5278}{babf}
\createlinenumber{5279}{05dc}
\createlinenumber{5280}{5ee8}
\createlinenumber{5281}{427e}
\createlinenumber{5282}{caaa}
\createlinenumber{5283}{c9c6}
\createlinenumber{5284}{31ee}
\createlinenumber{5285}{95cf}
\createlinenumber{5286}{427e}
\createlinenumber{5287}{9942}
\createlinenumber{5288}{cf0d}
\createlinenumber{5289}{7ef4}
\createlinenumber{5290}{0d71}
\createlinenumber{5291}{0e88}
\createlinenumber{5292}{0c6a}
\createlinenumber{5293}{9f1d}
\createlinenumber{5294}{1d9c}
\createlinenumber{5295}{b5ae}
\createlinenumber{5296}{77ef}
\createlinenumber{5297}{95cf}
\createlinenumber{5298}{95cf}
\createlinenumber{5299}{7812}
\createlinenumber{5300}{2974}
\createlinenumber{5301}{b893}
\createlinenumber{5302}{850d}
\createlinenumber{5303}{649a}
\createlinenumber{5304}{d96a}
\createlinenumber{5305}{95cf}
\createlinenumber{5306}{427e}
\createlinenumber{5307}{427e}
\createlinenumber{5308}{8a45}
\createlinenumber{5309}{3912}
\createlinenumber{5310}{1425}
\createlinenumber{5311}{a065}
\createlinenumber{5312}{95cf}
\createlinenumber{5313}{a549}
\createlinenumber{5314}{ee5e}
\createlinenumber{5315}{7ad1}
\createlinenumber{5316}{a065}
\createlinenumber{5317}{95cf}
\createlinenumber{5318}{427e}
\createlinenumber{5319}{5aec}
\createlinenumber{5320}{f5b0}
\createlinenumber{5321}{aa7c}
\createlinenumber{5322}{a5b9}
\createlinenumber{5323}{95cf}
\createlinenumber{5324}{95cf}
\createlinenumber{5325}{427e}
\createlinenumber{5326}{2473}
\createlinenumber{5327}{fefb}
\createlinenumber{5328}{3d6e}
\createlinenumber{5329}{e78d}
\createlinenumber{5330}{95cf}
\createlinenumber{5331}{95cf}
\createlinenumber{5332}{427e}
\createlinenumber{5333}{1126}
\createlinenumber{5334}{7e0b}
\createlinenumber{5335}{41e6}
\createlinenumber{5336}{95cf}
\createlinenumber{5337}{329b}
\createlinenumber{5338}{8f40}
\createlinenumber{5339}{ad87}
\createlinenumber{5340}{1efb}
\begin{lstlisting}[language=C++]
struct Hash {
    static int findprime() {
        random_device rd;
        mt19937 gen(rd());

        int n = gen() % 900000000 + 100000000;
        if (n % 2 == 0)
            n++;
        while (true) {
            bool ok = 1;
            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    ok = 0;
                    n += 2;
                    break;
                }
            }
            if (ok)
                return n;
        }
    }

    static const int Mod;
    static vector<int> pow1;
    static vector<int> pow2;
    const int B1 = 131;
    const int B2 = 13331;
    string s;
    int len = 0;
    vector<int> f1, f2;
    using LL = long long;

    Hash() {}
    Hash(const string &t, bool rfg = 0) {
        init(t, rfg);
    }
    // 默认前缀哈希
    void init(const string &t, bool rfg = 0) {
        s = " " + t;
        len = t.size();
        int cur = pow1.size();
        if (cur - 1 <= len) {
            pow1.resize(len + 1, 1);
            pow2.resize(len + 1, 1);
            for (int i = cur; i <= len; i++) {
                pow1[i] = (LL)pow1[i - 1] * B1 % Mod;
                pow2[i] = (LL)pow2[i - 1] * B2 % Mod;
            }
        }
        f1.resize(len + 2, 0);
        f2.resize(len + 2, 0);
        if (rfg == 0)
            insert1(s);
        else
            insert2(s);
    }

    // 1-base
    pair<int, int> getpre(int l, int r) const {
        int res1 = (f1[r] - (LL)f1[l - 1] * pow1[r - l + 1] % Mod + Mod) % Mod;
        int res2 = (f2[r] - (LL)f2[l - 1] * pow2[r - l + 1] % Mod + Mod) % Mod;
        return make_pair(res1, res2);
    }
    pair<int, int> getsuf(int l, int r) const {
        int res1 = (f1[l] - (LL)f1[r + 1] * pow1[r - l + 1] % Mod + Mod) % Mod;
        int res2 = (f2[l] - (LL)f2[r + 1] * pow2[r - l + 1] % Mod + Mod) % Mod;
        return make_pair(res1, res2);
    }
    // 前缀哈希
    void insert1(const string &t) {
        for (int i = 1; i <= len; i++) {
            f1[i] = ((LL)f1[i - 1] * B1 + t[i]) % Mod;
            f2[i] = ((LL)f2[i - 1] * B2 + t[i]) % Mod;
        }
    }
    // 后缀哈希
    void insert2(const string &t) {
        for (int i = len; i >= 1; i--) {
            f1[i] = ((LL)f1[i + 1] * B1 + t[i]) % Mod;
            f2[i] = ((LL)f2[i + 1] * B2 + t[i]) % Mod;
        }
    }

    void clear() {
        f1.resize(1);
        f2.resize(1);
    }
};
const int Hash::Mod = Hash::findprime();
vector<int> Hash::pow1(1, 1);
vector<int> Hash::pow2(1, 1);
\end{lstlisting}
\subsection{KMP}
\createlinenumber{5341}{f5ca}
\createlinenumber{5342}{4506}
\createlinenumber{5343}{eea3}
\createlinenumber{5344}{5c5d}
\createlinenumber{5345}{57b7}
\createlinenumber{5346}{2e4a}
\createlinenumber{5347}{8bf8}
\createlinenumber{5348}{4506}
\createlinenumber{5349}{7ef4}
\createlinenumber{5350}{dd33}
\createlinenumber{5351}{2429}
\createlinenumber{5352}{dc6f}
\createlinenumber{5353}{e881}
\createlinenumber{5354}{c590}
\createlinenumber{5355}{95cf}
\createlinenumber{5356}{427e}
\createlinenumber{5357}{ecd1}
\createlinenumber{5358}{4506}
\createlinenumber{5359}{bba1}
\createlinenumber{5360}{4506}
\createlinenumber{5361}{362a}
\createlinenumber{5362}{7551}
\createlinenumber{5363}{2711}
\createlinenumber{5364}{95cf}
\createlinenumber{5365}{95cf}
\createlinenumber{5366}{808b}
\createlinenumber{5367}{4506}
\createlinenumber{5368}{d049}
\createlinenumber{5369}{95cf}
\createlinenumber{5370}{3a1d}
\createlinenumber{5371}{4506}
\createlinenumber{5372}{a199}
\createlinenumber{5373}{e7a9}
\createlinenumber{5374}{9867}
\createlinenumber{5375}{8fd0}
\createlinenumber{5376}{e1b7}
\createlinenumber{5377}{4506}
\createlinenumber{5378}{d3dd}
\createlinenumber{5379}{1471}
\createlinenumber{5380}{fe9d}
\createlinenumber{5381}{95cf}
\createlinenumber{5382}{c3e2}
\createlinenumber{5383}{95cf}
\createlinenumber{5384}{329b}
\begin{lstlisting}[language=C++]
struct KMP
{
    vector<int> nxt;
    string tt;
    int len;
    KMP() {}
    KMP(string t)
    {
        len = t.size();
        t = " " + t;
        tt = t;
        nxt.resize(len + 1);
        nxt[1] = nxt[0] = 0;
        init(tt);
    }

    void init(string t)
    {
        for (int i = 2; i <= len; i++)
        {
            nxt[i] = nxt[i - 1];
            while (nxt[i] && t[i] != t[nxt[i] + 1])nxt[i] = nxt[nxt[i]];
            nxt[i] += (t[i] == t[nxt[i] + 1]);
        }
    }
    vector<int> getnxt()
    {
        return nxt;
    }
    vector<int> match(string &s, bool oneonly = 0)
    {
        int lens = s.size();
        s = " " + s;
        vector<int> stpos;
        int j = 0;
        for (int i = 1; i <= lens; i++)
        {
            while (j == len || (j && s[i] != tt[j + 1])) j = nxt[j];
            if (s[i] == tt[j + 1])j++;
            if (j == len)stpos.push_back(i - len + 1);
        }
        return stpos;
    }
};
\end{lstlisting}
\subsection{MINSHOW}
\createlinenumber{5385}{2dcf}
\createlinenumber{5386}{3e99}
\createlinenumber{5387}{13af}
\createlinenumber{5388}{e7a9}
\createlinenumber{5389}{5904}
\createlinenumber{5390}{f05d}
\createlinenumber{5391}{c41f}
\createlinenumber{5392}{208d}
\createlinenumber{5393}{faef}
\createlinenumber{5394}{de2d}
\createlinenumber{5395}{95cf}
\createlinenumber{5396}{34b1}
\createlinenumber{5397}{d898}
\createlinenumber{5398}{1ef9}
\createlinenumber{5399}{95cf}
\createlinenumber{5400}{427e}
\createlinenumber{5401}{35c0}
\createlinenumber{5402}{95cf}
\begin{lstlisting}[language=C++]
string getmin(string s){
	int len=s.size();
	s+=s;
	s=" "+s;
	int i=1,j=2;//i,j表示以其位置开头的循环串
	while(j<=len){
		int k=0;//时间复杂度线性
		while(k<len&&s[i+k]==s[j+k])k++;
		if(s[i+k]>s[j+k]){
			i+=k+1;
		}
		else j+=k+1;
		if(i==j)j++;
		if(i>j)swap(i,j);
	}
    //最终字典序最小的是以i开头的
	return s.substr(i,len);
}
\end{lstlisting}
\subsection{Manacher}
\createlinenumber{5403}{5899}
\createlinenumber{5404}{e436}
\createlinenumber{5405}{d419}
\createlinenumber{5406}{7521}
\createlinenumber{5407}{427e}
\createlinenumber{5408}{4447}
\createlinenumber{5409}{d3c2}
\createlinenumber{5410}{8143}
\createlinenumber{5411}{a355}
\createlinenumber{5412}{4979}
\createlinenumber{5413}{8923}
\createlinenumber{5414}{95cf}
\createlinenumber{5415}{e7a9}
\createlinenumber{5416}{c408}
\createlinenumber{5417}{4bfe}
\createlinenumber{5418}{95cf}
\createlinenumber{5419}{a4f6}
\createlinenumber{5420}{69e2}
\createlinenumber{5421}{f5b0}
\createlinenumber{5422}{368d}
\createlinenumber{5423}{0d63}
\createlinenumber{5424}{649a}
\createlinenumber{5425}{d73e}
\createlinenumber{5426}{e890}
\createlinenumber{5427}{4ec5}
\createlinenumber{5428}{427e}
\createlinenumber{5429}{427e}
\createlinenumber{5430}{427e}
\createlinenumber{5431}{427e}
\createlinenumber{5432}{427e}
\createlinenumber{5433}{427e}
\createlinenumber{5434}{427e}
\createlinenumber{5435}{427e}
\createlinenumber{5436}{427e}
\createlinenumber{5437}{427e}
\createlinenumber{5438}{95cf}
\createlinenumber{5439}{adee}
\createlinenumber{5440}{a8aa}
\createlinenumber{5441}{95cf}
\createlinenumber{5442}{e149}
\createlinenumber{5443}{95cf}
\createlinenumber{5444}{37d4}
\createlinenumber{5445}{3b0f}
\createlinenumber{5446}{f5b0}
\createlinenumber{5447}{9cd6}
\createlinenumber{5448}{95cf}
\createlinenumber{5449}{adce}
\createlinenumber{5450}{95cf}
\createlinenumber{5451}{329b}
\begin{lstlisting}[language=C++]
struct PAS {
    string s = "#";
    int len = 1;
    vector<int> p;
   // vector<pair<int, int>> all;
    PAS() {}
    PAS(string t) {
        for (auto c : t) {
            s += c;
            s += '#';
            len += 2;
        }
        s = " " + s;
        p.resize(len + 1);
        getp(s);
    }
    vector<int> getp(string t) {
        int mid = 0, r = 0;
        for (int i = 1; i <= len; i++) {
            if (i > r)
                p[i] = 1;
            else
                p[i] = min(p[2 * mid - i], r - i + 1);
            while (i - p[i] > 0 && i + p[i] <= len && t[i - p[i]] == t[i + p[i]]) {
                p[i] += 1;
                // int ql, qr;
                // if ((i - p[i] + 1) % 2 == 0)
                //     ql = (i - p[i] + 1) / 2;
                // else
                //     ql = (i - p[i] + 2) / 2;
                // if ((i + p[i] - 1) % 2 == 0)
                //     qr = (i + p[i] - 1) / 2;
                // else
                //     qr = (i + p[i] - 2) / 2;
                // all.emplace_back(ql, qr);
            }
            if (i + p[i] - 1 > r)
                mid = i, r = i + p[i] - 1;
        }
        return p;
    }
    int getmax() {
        int ans = 0;
        for (int i = 1; i <= len; i++) {
            ans = max(ans, p[i]);
        }
        return (ans - 1);
    }
};
\end{lstlisting}
\subsection{PAM}
\createlinenumber{5452}{ee62}
\createlinenumber{5453}{d1f3}
\createlinenumber{5454}{80b8}
\createlinenumber{5455}{57b7}
\createlinenumber{5456}{21c8}
\createlinenumber{5457}{0b88}
\createlinenumber{5458}{8abb}
\createlinenumber{5459}{2a6e}
\createlinenumber{5460}{427e}
\createlinenumber{5461}{a7c5}
\createlinenumber{5462}{329b}
\createlinenumber{5463}{2eb3}
\createlinenumber{5464}{18ec}
\createlinenumber{5465}{b817}
\createlinenumber{5466}{b301}
\createlinenumber{5467}{6027}
\createlinenumber{5468}{07e2}
\createlinenumber{5469}{95cf}
\createlinenumber{5470}{5d53}
\createlinenumber{5471}{e343}
\createlinenumber{5472}{7409}
\createlinenumber{5473}{4861}
\createlinenumber{5474}{06cb}
\createlinenumber{5475}{0910}
\createlinenumber{5476}{95cf}
\createlinenumber{5477}{05c4}
\createlinenumber{5478}{35c2}
\createlinenumber{5479}{c105}
\createlinenumber{5480}{95cf}
\createlinenumber{5481}{427e}
\createlinenumber{5482}{1a0e}
\createlinenumber{5483}{4ec3}
\createlinenumber{5484}{a355}
\createlinenumber{5485}{523c}
\createlinenumber{5486}{c113}
\createlinenumber{5487}{427e}
\createlinenumber{5488}{1026}
\createlinenumber{5489}{6d21}
\createlinenumber{5490}{d74e}
\createlinenumber{5491}{6173}
\createlinenumber{5492}{9427}
\createlinenumber{5493}{95cf}
\createlinenumber{5494}{3bd7}
\createlinenumber{5495}{6cd3}
\createlinenumber{5496}{61e7}
\createlinenumber{5497}{26a8}
\createlinenumber{5498}{438e}
\createlinenumber{5499}{95cf}
\createlinenumber{5500}{427e}
\createlinenumber{5501}{9a42}
\createlinenumber{5502}{965c}
\createlinenumber{5503}{61e7}
\createlinenumber{5504}{0e7a}
\createlinenumber{5505}{427e}
\createlinenumber{5506}{427e}
\createlinenumber{5507}{427e}
\createlinenumber{5508}{325d}
\createlinenumber{5509}{427e}
\createlinenumber{5510}{c450}
\createlinenumber{5511}{b229}
\createlinenumber{5512}{a390}
\createlinenumber{5513}{72ce}
\createlinenumber{5514}{3361}
\createlinenumber{5515}{95cf}
\createlinenumber{5516}{427e}
\createlinenumber{5517}{1026}
\createlinenumber{5518}{9427}
\createlinenumber{5519}{6d21}
\createlinenumber{5520}{d238}
\createlinenumber{5521}{de85}
\createlinenumber{5522}{6173}
\createlinenumber{5523}{95cf}
\createlinenumber{5524}{95cf}
\createlinenumber{5525}{72ce}
\createlinenumber{5526}{6cef}
\createlinenumber{5527}{427e}
\createlinenumber{5528}{3361}
\createlinenumber{5529}{95cf}
\createlinenumber{5530}{1a30}
\createlinenumber{5531}{ac48}
\createlinenumber{5532}{10ef}
\createlinenumber{5533}{699b}
\createlinenumber{5534}{5fb4}
\createlinenumber{5535}{1358}
\createlinenumber{5536}{48ae}
\createlinenumber{5537}{95cf}
\createlinenumber{5538}{95cf}
\createlinenumber{5539}{a000}
\createlinenumber{5540}{2b18}
\createlinenumber{5541}{95cf}
\createlinenumber{5542}{aad1}
\createlinenumber{5543}{9f38}
\createlinenumber{5544}{95cf}
\createlinenumber{5545}{6bba}
\createlinenumber{5546}{1031}
\createlinenumber{5547}{95cf}
\createlinenumber{5548}{654e}
\createlinenumber{5549}{7a29}
\createlinenumber{5550}{95cf}
\createlinenumber{5551}{329b}
\begin{lstlisting}[language=C++]
struct PAM {
    static constexpr int asz = 28;
    struct Node {
        int len;
        int fail;
        int dep;      // 以这个节点结尾的回文子串的数量(回文fail树的深度)
        int cnt = 0;  // 同样的回文结构出现次数
        array<int, asz> next;
        // int mask = 0;用了多少种字母
        Node() : len{}, fail{}, dep{}, next{} {}
    };
    vector<Node> t;
    vector<int> idpos;  // idpos表示字符串字符位置到后缀自动机节点编号
    int last;
    string s;
    PAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].len = -1;  // 0：奇根
        last = 1;       // 1：偶根
        s.clear();
        idpos.assign(1, 0);
    }
    int newNode() {
        t.emplace_back();  // Node()
        return t.size() - 1;
    }

    bool add(char c, char offset = 'a') {
        int pos = s.size();
        s += c;
        int ch = c - offset;
        int cur = last, curlen = 0;

        while (true) {
            curlen = t[cur].len;
            if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos])
                break;
            cur = t[cur].fail;
        }  // 找到在哪个节点后面建新点
        if (t[cur].next[ch]) {
            last = t[cur].next[ch];
            idpos.push_back(last);
            t[last].cnt += 1;
            return false;
        }

        int num = newNode();
        last = num;
        idpos.push_back(last);
        t[num].len = t[cur].len + 2;
        // 在这里加入题目需要维护的值
        // t[num].mask = t[cur].mask;
        // t[num].mask |= 1 << ch;
        t[cur].next[ch] = num;

        if (t[num].len == 1) {  // 如果为单字符，指向偶根
            t[num].fail = 1;
            t[num].dep = 1;
            t[num].cnt = 1;
            return true;
        }

        while (true) {  // 为新节点找fail，从父亲的fail开始找
            cur = t[cur].fail;
            curlen = t[cur].len;
            if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) {
                t[num].fail = t[cur].next[ch];
                break;
            }
        }
        t[num].cnt = 1;
        t[num].dep = 1 + t[t[num].fail].dep;

        return true;
    }
    int tot = 0;
    void work(string tt) {
        for (auto x : tt) add(x);
        tot = t.size() - 1;
        for (int i = tot; i >= 0; i--) {
            int fa = t[i].fail;
            t[fa].cnt += t[i].cnt;
        }
    }
    int fail(int p) {
        return t[p].fail;
    }
    int len(int p) {
        return t[p].len;
    }
    int size() {
        return t.size();
    }
    int cnt(int p) {
        return t[p].cnt;
    }
};
\end{lstlisting}
\subsection{SA}
\createlinenumber{5552}{3b88}
\createlinenumber{5553}{5c83}
\createlinenumber{5554}{c792}
\createlinenumber{5555}{427e}
\createlinenumber{5556}{71b1}
\createlinenumber{5557}{f0cd}
\createlinenumber{5558}{ecbb}
\createlinenumber{5559}{b71f}
\createlinenumber{5560}{9a6d}
\createlinenumber{5561}{e7a9}
\createlinenumber{5562}{ae68}
\createlinenumber{5563}{43e8}
\createlinenumber{5564}{f629}
\createlinenumber{5565}{b251}
\createlinenumber{5566}{427e}
\createlinenumber{5567}{427e}
\createlinenumber{5568}{2e8f}
\createlinenumber{5569}{f0f6}
\createlinenumber{5570}{14b0}
\createlinenumber{5571}{427e}
\createlinenumber{5572}{6bef}
\createlinenumber{5573}{0c40}
\createlinenumber{5574}{9c9b}
\createlinenumber{5575}{427e}
\createlinenumber{5576}{94ec}
\createlinenumber{5577}{7d2c}
\createlinenumber{5578}{230d}
\createlinenumber{5579}{427e}
\createlinenumber{5580}{c7a5}
\createlinenumber{5581}{206d}
\createlinenumber{5582}{427e}
\createlinenumber{5583}{673d}
\createlinenumber{5584}{080a}
\createlinenumber{5585}{1f58}
\createlinenumber{5586}{427e}
\createlinenumber{5587}{c9ea}
\createlinenumber{5588}{2ad4}
\createlinenumber{5589}{d162}
\createlinenumber{5590}{427e}
\createlinenumber{5591}{2ad4}
\createlinenumber{5592}{c0d7}
\createlinenumber{5593}{427e}
\createlinenumber{5594}{ea0b}
\createlinenumber{5595}{20f5}
\createlinenumber{5596}{c26b}
\createlinenumber{5597}{ab2d}
\createlinenumber{5598}{95cf}
\createlinenumber{5599}{427e}
\createlinenumber{5600}{eba4}
\createlinenumber{5601}{2e8f}
\createlinenumber{5602}{427e}
\createlinenumber{5603}{f0f6}
\createlinenumber{5604}{fe55}
\createlinenumber{5605}{2055}
\createlinenumber{5606}{a93e}
\createlinenumber{5607}{95cf}
\createlinenumber{5608}{427e}
\createlinenumber{5609}{38f9}
\createlinenumber{5610}{aadf}
\createlinenumber{5611}{27ef}
\createlinenumber{5612}{8e2e}
\createlinenumber{5613}{5d16}
\createlinenumber{5614}{db0c}
\createlinenumber{5615}{917f}
\createlinenumber{5616}{7676}
\createlinenumber{5617}{95cf}
\createlinenumber{5618}{95cf}
\createlinenumber{5619}{95cf}
\createlinenumber{5620}{329b}
\begin{lstlisting}[language=C++]
struct SA {
    int n;                   // 存储字符串的长度
    vector<int> sa, rk, lc;  // sa: 后缀数组, rk: 排名数组, lc: 最长公共前缀数组 (LCP)

    SA(string &s) {
        n = s.length();    // 初始化字符串的长度
        sa.resize(n + 1);  // 调整 sa 的大小为 n + 1
        lc.resize(n + 1);  // 调整 lc 的大小为 n
        rk.resize(n + 1);  // 调整 rk 的大小为 n + 1
        s = " " + s;
        iota(sa.begin(), sa.end(), 0);  // 初始化 sa 为 [1, 2, ..., n]
        sort(sa.begin() + 1, sa.end(), [&](int a, int b) {
            return s[a] < s[b];  // 按照首字符对索引进行排序
        });

        // 初始化 rk 数组
        rk[sa[1]] = 1;
        for (int i = 2; i <= n; ++i)
            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);

        int k = 1;                    // 初始化 k 为 1，表示当前使用的字符串长度
        vector<int> tmp, cnt(n + 1);  // tmp: 临时数组, cnt: 计数排序的频率数组
        tmp.reserve(n + 1);           // 为 tmp 预留 n + 1 个元素的空间

        while (rk[sa[n]] < n) {  // 当排名最高的后缀排名小于 n时继续循环
            tmp.clear();
            tmp.push_back(0);  // 清空 tmp 数组

            for (int i = 1; i <= k; ++i)
                tmp.push_back(n - k + i);  // 越界部分默认为空字符

            for (auto i : sa)
                if (i >= k + 1)
                    tmp.push_back(i - k);  // 按第二关键字排序

            fill(cnt.begin(), cnt.end(), 0);  // 清空 cnt 数组
            for (int i = 1; i <= n; ++i)
                ++cnt[rk[i]];  // 统计每个排名出现的频率

            for (int i = 1; i <= n; ++i)
                cnt[i] += cnt[i - 1];  // 计算计数排序中的前缀和

            for (int i = n; i >= 1; --i) {
                int tmprk = cnt[rk[tmp[i]]];
                sa[tmprk] = tmp[i];
                cnt[rk[tmp[i]]] -= 1;
            }  // 根据 tmp 中的排名重建后缀数组

            std::swap(rk, tmp);  // tmp的功能变为之前的rk桶数组
            rk[sa[1]] = 1;       // 重新初始化排名数组，首先将 sa[1] 的排名设为 1

            for (int i = 2; i <= n; ++i)
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] ||
                                             sa[i - 1] + k > n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);  // 基于前后部分进行比较
            k *= 2;                                                                                      // 将 k 翻倍，以便在下一个循环中比较更长的前缀
        }

        for (int i = 1, j = 0; i <= n; ++i) {
            if (rk[i] == 1) {  // 如果当前后缀是字典序最小的，不需要计算 LCP
                j = 0;
            } else {
                for (j -= j > 0; i + j <= n && sa[rk[i] - 1] + j <= n &&
                                 s[i + j] == s[sa[rk[i] - 1] + j];)
                    ++j;        // 计算与前一个后缀的最长公共前缀长度
                lc[rk[i]] = j;  // 排名为 i 的后缀与排名为 i-1 的 LCP
            }
        }
    }
};
\end{lstlisting}
\subsection{SAM}
\createlinenumber{5621}{c62c}
\createlinenumber{5622}{44a1}
\createlinenumber{5623}{80b8}
\createlinenumber{5624}{57b7}
\createlinenumber{5625}{21c8}
\createlinenumber{5626}{8abb}
\createlinenumber{5627}{2a6e}
\createlinenumber{5628}{3fe8}
\createlinenumber{5629}{329b}
\createlinenumber{5630}{2eb3}
\createlinenumber{5631}{1a30}
\createlinenumber{5632}{3a0a}
\createlinenumber{5633}{07e2}
\createlinenumber{5634}{95cf}
\createlinenumber{5635}{5d53}
\createlinenumber{5636}{e343}
\createlinenumber{5637}{0291}
\createlinenumber{5638}{7409}
\createlinenumber{5639}{95cf}
\createlinenumber{5640}{05c4}
\createlinenumber{5641}{35c2}
\createlinenumber{5642}{c105}
\createlinenumber{5643}{95cf}
\createlinenumber{5644}{6d7d}
\createlinenumber{5645}{2745}
\createlinenumber{5646}{0f1c}
\createlinenumber{5647}{a37a}
\createlinenumber{5648}{4cb6}
\createlinenumber{5649}{95cf}
\createlinenumber{5650}{548e}
\createlinenumber{5651}{a02f}
\createlinenumber{5652}{2040}
\createlinenumber{5653}{8f0a}
\createlinenumber{5654}{1d53}
\createlinenumber{5655}{85d9}
\createlinenumber{5656}{17b8}
\createlinenumber{5657}{7c82}
\createlinenumber{5658}{95cf}
\createlinenumber{5659}{38ca}
\createlinenumber{5660}{95cf}
\createlinenumber{5661}{67b0}
\createlinenumber{5662}{df51}
\createlinenumber{5663}{9ba2}
\createlinenumber{5664}{d665}
\createlinenumber{5665}{7c82}
\createlinenumber{5666}{95cf}
\createlinenumber{5667}{17d8}
\createlinenumber{5668}{828d}
\createlinenumber{5669}{597e}
\createlinenumber{5670}{95cf}
\createlinenumber{5671}{8b0a}
\createlinenumber{5672}{6bd4}
\createlinenumber{5673}{95cf}
\createlinenumber{5674}{427e}
\createlinenumber{5675}{3ef7}
\createlinenumber{5676}{2de7}
\createlinenumber{5677}{95cf}
\createlinenumber{5678}{427e}
\createlinenumber{5679}{3acb}
\createlinenumber{5680}{9275}
\createlinenumber{5681}{95cf}
\createlinenumber{5682}{427e}
\createlinenumber{5683}{a000}
\createlinenumber{5684}{2b18}
\createlinenumber{5685}{95cf}
\createlinenumber{5686}{427e}
\createlinenumber{5687}{aad1}
\createlinenumber{5688}{9f38}
\createlinenumber{5689}{95cf}
\createlinenumber{5690}{6bba}
\createlinenumber{5691}{1031}
\createlinenumber{5692}{95cf}
\createlinenumber{5693}{aa80}
\createlinenumber{5694}{7a29}
\createlinenumber{5695}{95cf}
\createlinenumber{5696}{110a}
\createlinenumber{5697}{76f1}
\createlinenumber{5698}{427e}
\createlinenumber{5699}{151a}
\createlinenumber{5700}{81cf}
\createlinenumber{5701}{427e}
\createlinenumber{5702}{95cf}
\createlinenumber{5703}{699b}
\createlinenumber{5704}{427e}
\createlinenumber{5705}{95cf}
\createlinenumber{5706}{24cc}
\createlinenumber{5707}{f6c4}
\createlinenumber{5708}{ff61}
\createlinenumber{5709}{627d}
\createlinenumber{5710}{427e}
\createlinenumber{5711}{b05b}
\createlinenumber{5712}{2da4}
\createlinenumber{5713}{2a09}
\createlinenumber{5714}{af02}
\createlinenumber{5715}{6025}
\createlinenumber{5716}{95cf}
\createlinenumber{5717}{427e}
\createlinenumber{5718}{95cf}
\createlinenumber{5719}{329b}
\begin{lstlisting}[language=C++]
struct SAM {
    static constexpr int asz = 26;
    struct Node {
        int len;
        int fail;
        int cnt = 0;
        array<int, asz> next;
        Node() : len{}, fail{}, next{} {}
    };
    vector<Node> t;
    int tot = 0;
    SAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int extend(int p, int c) {
        if (t[p].next[c]) {
            int q = t[p].next[c];
            if (t[q].len == t[p].len + 1) {
                return q;
            }
            int nq = newNode();
            t[nq].len = t[p].len + 1;
            t[nq].fail = t[q].fail;
            t[nq].next = t[q].next;
            t[q].fail = nq;
            while (t[p].next[c] == q) {
                t[p].next[c] = nq;
                p = t[p].fail;
            }
            return nq;
        }
        int np = newNode();
        t[np].len = t[p].len + 1;
        while (!t[p].next[c]) {
            t[p].next[c] = np;
            p = t[p].fail;
        }
        t[np].fail = extend(p, c);
        t[np].cnt += 1;
        return np;
    }
    int extend(int p, char c, char offset = 'a') {
        return extend(p, c - offset);
    }

    int next(int p, int x) {
        return t[p].next[x];
    }

    int next(int p, char c, char offset = 'a') {
        return next(p, c - 'a');
    }

    int fail(int p) {
        return t[p].fail;
    }

    int len(int p) {
        return t[p].len;
    }
    int size() {
        return t.size();
    }
    int &cnt(int p) {
        return t[p].cnt;
    }
    void work(string s) {
        int p = 1;
        // vector<int> pos(1, 0);
        for (auto x : s) {
            p = extend(p, x);
            // pos.push_back(p);
        }
        tot = t.size() - 1;
        // return pos;
    }
    void getcnt(int len) {
        vector<int> tong(len + 1);
        vector<int> id(tot + 1);
        for (int i = 1; i <= tot; i++) tong[t[i].len]++;
        // 按照len[x]从小到大基数排序，相当于对SAM图进行拓扑排序
        for (int i = 1; i <= n; i++) tong[i] += tong[i - 1];
        for (int i = 1; i <= tot; i++) id[tong[t[i].len]--] = i;  // 排名为j的节点是状态i
        for (int i = tot; i >= 1; i--) {
            auto cur = t[id[i]];
            t[cur.fail].cnt += cur.cnt;
        }
        // 从后往前for,自底向上更新parent的right大小
    }
};
\end{lstlisting}
\subsection{Trie\_01}
\createlinenumber{5720}{49ac}
\createlinenumber{5721}{5652}
\createlinenumber{5722}{4c7f}
\createlinenumber{5723}{80b8}
\createlinenumber{5724}{8abb}
\createlinenumber{5725}{75a6}
\createlinenumber{5726}{3bc6}
\createlinenumber{5727}{329b}
\createlinenumber{5728}{2eb3}
\createlinenumber{5729}{d3c3}
\createlinenumber{5730}{5d53}
\createlinenumber{5731}{acab}
\createlinenumber{5732}{95cf}
\createlinenumber{5733}{05c4}
\createlinenumber{5734}{35c2}
\createlinenumber{5735}{c105}
\createlinenumber{5736}{95cf}
\createlinenumber{5737}{427e}
\createlinenumber{5738}{bc3b}
\createlinenumber{5739}{76f1}
\createlinenumber{5740}{2f03}
\createlinenumber{5741}{07ab}
\createlinenumber{5742}{2e52}
\createlinenumber{5743}{95cf}
\createlinenumber{5744}{3486}
\createlinenumber{5745}{6e33}
\createlinenumber{5746}{95cf}
\createlinenumber{5747}{e149}
\createlinenumber{5748}{95cf}
\createlinenumber{5749}{427e}
\createlinenumber{5750}{d7c7}
\createlinenumber{5751}{afe0}
\createlinenumber{5752}{b2a0}
\createlinenumber{5753}{bcd7}
\createlinenumber{5754}{95cf}
\createlinenumber{5755}{220b}
\createlinenumber{5756}{95cf}
\createlinenumber{5757}{c572}
\createlinenumber{5758}{c3a0}
\createlinenumber{5759}{b2a0}
\createlinenumber{5760}{40f0}
\createlinenumber{5761}{4c62}
\createlinenumber{5762}{df25}
\createlinenumber{5763}{432e}
\createlinenumber{5764}{ab23}
\createlinenumber{5765}{95cf}
\createlinenumber{5766}{d221}
\createlinenumber{5767}{95cf}
\createlinenumber{5768}{244d}
\createlinenumber{5769}{95cf}
\createlinenumber{5770}{41d0}
\createlinenumber{5771}{b33a}
\createlinenumber{5772}{654e}
\createlinenumber{5773}{7a29}
\createlinenumber{5774}{95cf}
\createlinenumber{5775}{329b}
\createlinenumber{5776}{08ab}
\begin{lstlisting}[language=C++]
struct Trie_bin {  // 保证第一次一定是先插入，查询不能先做
    static constexpr int ALPHA = 2;
    static constexpr int width = 21;  // 值域必须小于2的width次方
    struct Node {
        int cnt = 0;
        array<int, ALPHA> next;
        Node() : next{} {}
    };
    vector<Node> t;
    Trie_bin() { init(); }
    void init() {
        t.assign(2, {});
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    // 增加flag标志便于删除
    int add(const vector<int> &a, int flag) {
        int p = 1;
        for (auto x : a) {
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
            }
            p = t[p].next[x];
            t[p].cnt += flag;
        }
        return p;
    }
    // 数字转01串vector
    int add(int x, int flag = 1) {  // x必须小于2的width次方
        vector<int> a;
        for (int i = width - 1; i >= 0; i--) {
            a.push_back((x >> i) & 1);
        }
        return add(a, flag);
    }
    int querymx(int x) {
        int res = 0, p = 1;
        for (int i = width - 1; i >= 0; i--) {
            int u = (x >> i) & 1;
            int nxp = t[p].next[u ^ 1];
            if (nxp && t[nxp].cnt) {
                res |= 1 << i;
                u ^= 1;
            }
            p = t[p].next[u];
        }
        return res;
    }
    int next(int p, int x) { return t[p].next[x]; }
    int size() { return t.size(); }
    int cnt(int p) {
        return t[p].cnt;
    }
};
Trie_bin tr;
\end{lstlisting}
\subsection{Trie\_per}
\createlinenumber{5777}{4691}
\createlinenumber{5778}{2044}
\createlinenumber{5779}{6af1}
\createlinenumber{5780}{80b8}
\createlinenumber{5781}{9f58}
\createlinenumber{5782}{be2e}
\createlinenumber{5783}{7395}
\createlinenumber{5784}{329b}
\createlinenumber{5785}{2eb3}
\createlinenumber{5786}{3dcc}
\createlinenumber{5787}{547e}
\createlinenumber{5788}{5d53}
\createlinenumber{5789}{acab}
\createlinenumber{5790}{e43d}
\createlinenumber{5791}{95cf}
\createlinenumber{5792}{05c4}
\createlinenumber{5793}{35c2}
\createlinenumber{5794}{c105}
\createlinenumber{5795}{95cf}
\createlinenumber{5796}{8a6a}
\createlinenumber{5797}{b335}
\createlinenumber{5798}{c5b3}
\createlinenumber{5799}{4d68}
\createlinenumber{5800}{2f03}
\createlinenumber{5801}{7452}
\createlinenumber{5802}{e458}
\createlinenumber{5803}{7947}
\createlinenumber{5804}{4d68}
\createlinenumber{5805}{8e4a}
\createlinenumber{5806}{95cf}
\createlinenumber{5807}{2a75}
\createlinenumber{5808}{95cf}
\createlinenumber{5809}{8455}
\createlinenumber{5810}{afe0}
\createlinenumber{5811}{b2a0}
\createlinenumber{5812}{bcd7}
\createlinenumber{5813}{95cf}
\createlinenumber{5814}{8035}
\createlinenumber{5815}{95cf}
\createlinenumber{5816}{59c4}
\createlinenumber{5817}{e043}
\createlinenumber{5818}{4376}
\createlinenumber{5819}{95cf}
\createlinenumber{5820}{427e}
\createlinenumber{5821}{e494}
\createlinenumber{5822}{5839}
\createlinenumber{5823}{2871}
\createlinenumber{5824}{b2a0}
\createlinenumber{5825}{40f0}
\createlinenumber{5826}{3cb5}
\createlinenumber{5827}{ced5}
\createlinenumber{5828}{432e}
\createlinenumber{5829}{ab23}
\createlinenumber{5830}{95cf}
\createlinenumber{5831}{d221}
\createlinenumber{5832}{f614}
\createlinenumber{5833}{95cf}
\createlinenumber{5834}{244d}
\createlinenumber{5835}{95cf}
\createlinenumber{5836}{b33a}
\createlinenumber{5837}{8e54}
\createlinenumber{5838}{41d0}
\createlinenumber{5839}{329b}
\begin{lstlisting}[language=C++]
struct Trie_per {
    static constexpr int SIZE = 2;
    static constexpr int width = 24;  // 值域小于2的width次方
    struct Node {
        int cnt;
        array<int, SIZE> next;
        Node() : cnt{0}, next{} {}
    };
    vector<Node> t;
    vector<int> ver;
    Trie_per() { init(); }
    void init() {
        t.assign(2, {});
        ver.resize(1);
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int add(int pre, const vector<int> &a) {
        int cur = newNode();
        int p = pre, q = cur;
        t[q] = t[p];
        for (auto x : a) {
            t[q].next[x] = newNode();
            p = next(p, x);
            q = next(q, x);
            t[q] = t[p];
            t[q].cnt++;
        }
        return cur;
    }
    int add(int pre, int x) {  // 转成01vector
        vector<int> a;
        for (int i = width - 1; i >= 0; i--) {
            a.push_back((x >> i) & 1);
        }
        return add(pre, a);
    }
    void add(int x) {  // 外部接口，加入一个数生成一个新版本
        int pos = add(ver.back(), x);
        ver.push_back(pos);
    }
    // 查询x在版本(l,r]中和哪个数异或最大
    int querymx(int l, int r, int x) {  // 传l-1进来
        int res = 0;
        int p = ver[l], q = ver[r];
        for (int i = width - 1; i >= 0; i--) {
            int u = (x >> i) & 1;
            int nxp = t[p].next[u ^ 1], nxq = t[q].next[u ^ 1];
            if (t[nxq].cnt - t[nxp].cnt > 0) {
                res |= 1 << i;
                u ^= 1;
            }
            p = t[p].next[u];
            q = t[q].next[u];
        }
        return res;
    }
    int size() { return t.size(); }
    int cnt(int p) { return t[p].cnt; }
    int next(int p, int x) { return t[p].next[x]; }
};
\end{lstlisting}
\subsection{Trie\_string}
\createlinenumber{5840}{8b2c}
\createlinenumber{5841}{94e0}
\createlinenumber{5842}{8ea3}
\createlinenumber{5843}{274f}
\createlinenumber{5844}{773c}
\createlinenumber{5845}{649a}
\createlinenumber{5846}{d622}
\createlinenumber{5847}{95cf}
\createlinenumber{5848}{a281}
\createlinenumber{5849}{ddd6}
\createlinenumber{5850}{80b8}
\createlinenumber{5851}{9f58}
\createlinenumber{5852}{81cb}
\createlinenumber{5853}{75a6}
\createlinenumber{5854}{5bcd}
\createlinenumber{5855}{329b}
\createlinenumber{5856}{2eb3}
\createlinenumber{5857}{d9e4}
\createlinenumber{5858}{5d53}
\createlinenumber{5859}{acab}
\createlinenumber{5860}{95cf}
\createlinenumber{5861}{05c4}
\createlinenumber{5862}{35c2}
\createlinenumber{5863}{c105}
\createlinenumber{5864}{95cf}
\createlinenumber{5865}{9895}
\createlinenumber{5866}{76f1}
\createlinenumber{5867}{2f03}
\createlinenumber{5868}{07ab}
\createlinenumber{5869}{2e52}
\createlinenumber{5870}{95cf}
\createlinenumber{5871}{3486}
\createlinenumber{5872}{46b7}
\createlinenumber{5873}{95cf}
\createlinenumber{5874}{45db}
\createlinenumber{5875}{e149}
\createlinenumber{5876}{95cf}
\createlinenumber{5877}{0679}
\createlinenumber{5878}{afe0}
\createlinenumber{5879}{0074}
\createlinenumber{5880}{5bb4}
\createlinenumber{5881}{95cf}
\createlinenumber{5882}{0d1f}
\createlinenumber{5883}{95cf}
\createlinenumber{5884}{8e54}
\createlinenumber{5885}{9b82}
\createlinenumber{5886}{41d0}
\createlinenumber{5887}{ab82}
\createlinenumber{5888}{b33a}
\createlinenumber{5889}{329b}
\createlinenumber{5890}{3bcb}
\begin{lstlisting}[language=C++]
int id(char c) {  // 给出现的字符集编码，记得改offset部分
    if (c >= 'a' && c <= 'z')
        return c - 'a';
    else if (c >= 'A' && c <= 'Z')
        return c - 'A' + 26;
    else
        return c - '0' + 52;
}
struct Trie {  // 正常字母字符串trie
    static constexpr int ALPHA = 26;
    struct Node {
        int cnt;
        bool ended;
        array<int, ALPHA> next;
        Node() : cnt{0}, ended{false}, next{} {}
    };
    vector<Node> t;
    Trie() { init(); }
    void init() {
        t.assign(2, {});
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int add(const vector<int> &a) {
        int p = 1;
        for (auto x : a) {
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
            }
            p = t[p].next[x];
            t[p].cnt++;
        }
        t[p].ended = true;
        return p;
    }
    int add(const string &s, char offset = 'a') {
        vector<int> a;
        for (auto c : s) {
            a.push_back(c - offset);
        }
        return add(a);
    }
    int cnt(int p) { return t[p].cnt; }
    bool ended(int p) { return t[p].ended; }
    int next(int p, int x) { return t[p].next[x]; }
    int next(int p, char c, char offset = 'a') { return next(p, c - offset); }
    int size() { return t.size(); }
};
Trie tr;
\end{lstlisting}
\section{geom}
\subsection{dls}
\createlinenumber{5891}{f7dc}
\createlinenumber{5892}{72fd}
\createlinenumber{5893}{427e}
\createlinenumber{5894}{1baa}
\createlinenumber{5895}{427e}
\createlinenumber{5896}{bf34}
\createlinenumber{5897}{427e}
\createlinenumber{5898}{427e}
\createlinenumber{5899}{427e}
\createlinenumber{5900}{9cec}
\createlinenumber{5901}{4506}
\createlinenumber{5902}{ba04}
\createlinenumber{5903}{427e}
\createlinenumber{5904}{598f}
\createlinenumber{5905}{01fd}
\createlinenumber{5906}{427e}
\createlinenumber{5907}{153d}
\createlinenumber{5908}{1ad9}
\createlinenumber{5909}{7e47}
\createlinenumber{5910}{21ea}
\createlinenumber{5911}{427e}
\createlinenumber{5912}{8fb9}
\createlinenumber{5913}{4506}
\createlinenumber{5914}{34c0}
\createlinenumber{5915}{6854}
\createlinenumber{5916}{4dc7}
\createlinenumber{5917}{c142}
\createlinenumber{5918}{95cf}
\createlinenumber{5919}{a063}
\createlinenumber{5920}{4506}
\createlinenumber{5921}{b38e}
\createlinenumber{5922}{95cf}
\createlinenumber{5923}{427e}
\createlinenumber{5924}{cea2}
\createlinenumber{5925}{427e}
\createlinenumber{5926}{74d8}
\createlinenumber{5927}{427e}
\createlinenumber{5928}{8f4b}
\createlinenumber{5929}{427e}
\createlinenumber{5930}{c314}
\createlinenumber{5931}{401d}
\createlinenumber{5932}{243c}
\createlinenumber{5933}{f6f5}
\createlinenumber{5934}{a060}
\createlinenumber{5935}{c612}
\createlinenumber{5936}{de56}
\createlinenumber{5937}{e6df}
\createlinenumber{5938}{427e}
\createlinenumber{5939}{dc03}
\createlinenumber{5940}{427e}
\createlinenumber{5941}{329b}
\createlinenumber{5942}{427e}
\createlinenumber{5943}{fc00}
\createlinenumber{5944}{4506}
\createlinenumber{5945}{edc3}
\createlinenumber{5946}{ca8f}
\createlinenumber{5947}{001c}
\createlinenumber{5948}{0d6f}
\createlinenumber{5949}{4506}
\createlinenumber{5950}{2660}
\createlinenumber{5951}{5489}
\createlinenumber{5952}{95cf}
\createlinenumber{5953}{09b5}
\createlinenumber{5954}{ab63}
\createlinenumber{5955}{4506}
\createlinenumber{5956}{ab7b}
\createlinenumber{5957}{2b60}
\createlinenumber{5958}{12a1}
\createlinenumber{5959}{95cf}
\createlinenumber{5960}{329b}
\createlinenumber{5961}{427e}
\createlinenumber{5962}{843d}
\createlinenumber{5963}{6c16}
\createlinenumber{5964}{427e}
\createlinenumber{5965}{364b}
\createlinenumber{5966}{4506}
\createlinenumber{5967}{e9ac}
\createlinenumber{5968}{cb5a}
\createlinenumber{5969}{95cf}
\createlinenumber{5970}{427e}
\createlinenumber{5971}{a194}
\createlinenumber{5972}{4506}
\createlinenumber{5973}{e9ac}
\createlinenumber{5974}{c3f4}
\createlinenumber{5975}{95cf}
\createlinenumber{5976}{a39d}
\createlinenumber{5977}{427e}
\createlinenumber{5978}{d240}
\createlinenumber{5979}{4506}
\createlinenumber{5980}{8049}
\createlinenumber{5981}{b917}
\createlinenumber{5982}{5e6d}
\createlinenumber{5983}{ccc4}
\createlinenumber{5984}{b741}
\createlinenumber{5985}{95cf}
\createlinenumber{5986}{62fa}
\createlinenumber{5987}{4506}
\createlinenumber{5988}{e935}
\createlinenumber{5989}{b0be}
\createlinenumber{5990}{95cf}
\createlinenumber{5991}{427e}
\createlinenumber{5992}{1567}
\createlinenumber{5993}{4506}
\createlinenumber{5994}{d118}
\createlinenumber{5995}{95cf}
\createlinenumber{5996}{427e}
\createlinenumber{5997}{28e0}
\createlinenumber{5998}{4506}
\createlinenumber{5999}{21a1}
\createlinenumber{6000}{95cf}
\createlinenumber{6001}{4560}
\createlinenumber{6002}{4506}
\createlinenumber{6003}{de80}
\createlinenumber{6004}{95cf}
\createlinenumber{6005}{9f81}
\createlinenumber{6006}{4506}
\createlinenumber{6007}{22d6}
\createlinenumber{6008}{95cf}
\createlinenumber{6009}{1324}
\createlinenumber{6010}{4506}
\createlinenumber{6011}{2947}
\createlinenumber{6012}{95cf}
\createlinenumber{6013}{427e}
\createlinenumber{6014}{4fdb}
\createlinenumber{6015}{4506}
\createlinenumber{6016}{d4fe}
\createlinenumber{6017}{2117}
\createlinenumber{6018}{95cf}
\createlinenumber{6019}{4971}
\createlinenumber{6020}{4506}
\createlinenumber{6021}{c8f0}
\createlinenumber{6022}{95cf}
\createlinenumber{6023}{8ebf}
\createlinenumber{6024}{4506}
\createlinenumber{6025}{c58c}
\createlinenumber{6026}{7b6b}
\createlinenumber{6027}{bb3a}
\createlinenumber{6028}{af02}
\createlinenumber{6029}{5c8f}
\createlinenumber{6030}{bdef}
\createlinenumber{6031}{95cf}
\createlinenumber{6032}{427e}
\createlinenumber{6033}{427e}
\createlinenumber{6034}{94d9}
\createlinenumber{6035}{4506}
\createlinenumber{6036}{77ee}
\createlinenumber{6037}{7021}
\createlinenumber{6038}{1cf4}
\createlinenumber{6039}{95cf}
\createlinenumber{6040}{427e}
\createlinenumber{6041}{fc4b}
\createlinenumber{6042}{4506}
\createlinenumber{6043}{cf73}
\createlinenumber{6044}{95cf}
\createlinenumber{6045}{427e}
\createlinenumber{6046}{a806}
\createlinenumber{6047}{4506}
\createlinenumber{6048}{48a3}
\createlinenumber{6049}{3877}
\createlinenumber{6050}{a80a}
\createlinenumber{6051}{6040}
\createlinenumber{6052}{95cf}
\createlinenumber{6053}{427e}
\createlinenumber{6054}{427e}
\createlinenumber{6055}{427e}
\createlinenumber{6056}{e12c}
\createlinenumber{6057}{4506}
\createlinenumber{6058}{73e0}
\createlinenumber{6059}{2225}
\createlinenumber{6060}{9776}
\createlinenumber{6061}{4722}
\createlinenumber{6062}{95cf}
\createlinenumber{6063}{427e}
\createlinenumber{6064}{fe77}
\createlinenumber{6065}{4506}
\createlinenumber{6066}{d372}
\createlinenumber{6067}{b8a7}
\createlinenumber{6068}{4506}
\createlinenumber{6069}{738c}
\createlinenumber{6070}{4058}
\createlinenumber{6071}{7459}
\createlinenumber{6072}{8a57}
\createlinenumber{6073}{4309}
\createlinenumber{6074}{2df4}
\createlinenumber{6075}{b333}
\createlinenumber{6076}{95be}
\createlinenumber{6077}{95cf}
\createlinenumber{6078}{984a}
\createlinenumber{6079}{95cf}
\createlinenumber{6080}{427e}
\createlinenumber{6081}{eb0b}
\createlinenumber{6082}{4506}
\createlinenumber{6083}{3c0c}
\createlinenumber{6084}{7f7f}
\createlinenumber{6085}{34e3}
\createlinenumber{6086}{9cfd}
\createlinenumber{6087}{0bd6}
\createlinenumber{6088}{c41f}
\createlinenumber{6089}{a7ce}
\createlinenumber{6090}{8b19}
\createlinenumber{6091}{def2}
\createlinenumber{6092}{cb3f}
\createlinenumber{6093}{480e}
\createlinenumber{6094}{def2}
\createlinenumber{6095}{2386}
\createlinenumber{6096}{2cb3}
\createlinenumber{6097}{95cf}
\createlinenumber{6098}{97fd}
\createlinenumber{6099}{4506}
\createlinenumber{6100}{427e}
\createlinenumber{6101}{3c0c}
\createlinenumber{6102}{7f7f}
\createlinenumber{6103}{34e3}
\createlinenumber{6104}{9cfd}
\createlinenumber{6105}{0bd6}
\createlinenumber{6106}{c41f}
\createlinenumber{6107}{a7ce}
\createlinenumber{6108}{585e}
\createlinenumber{6109}{def2}
\createlinenumber{6110}{cb3f}
\createlinenumber{6111}{8ff0}
\createlinenumber{6112}{def2}
\createlinenumber{6113}{2386}
\createlinenumber{6114}{2cb3}
\createlinenumber{6115}{95cf}
\createlinenumber{6116}{427e}
\createlinenumber{6117}{427e}
\createlinenumber{6118}{93db}
\createlinenumber{6119}{4506}
\createlinenumber{6120}{3c0c}
\createlinenumber{6121}{7f7f}
\createlinenumber{6122}{7021}
\createlinenumber{6123}{5a25}
\createlinenumber{6124}{686f}
\createlinenumber{6125}{730b}
\createlinenumber{6126}{a226}
\createlinenumber{6127}{bcbf}
\createlinenumber{6128}{4506}
\createlinenumber{6129}{0b80}
\createlinenumber{6130}{97ea}
\createlinenumber{6131}{649a}
\createlinenumber{6132}{7ee5}
\createlinenumber{6133}{0988}
\createlinenumber{6134}{cbcb}
\createlinenumber{6135}{ee0f}
\createlinenumber{6136}{95cf}
\createlinenumber{6137}{427e}
\createlinenumber{6138}{27a3}
\createlinenumber{6139}{4506}
\createlinenumber{6140}{4180}
\createlinenumber{6141}{3c0c}
\createlinenumber{6142}{b8a7}
\createlinenumber{6143}{4506}
\createlinenumber{6144}{8494}
\createlinenumber{6145}{b541}
\createlinenumber{6146}{dd12}
\createlinenumber{6147}{a01e}
\createlinenumber{6148}{644b}
\createlinenumber{6149}{fcce}
\createlinenumber{6150}{95cf}
\createlinenumber{6151}{2cb3}
\createlinenumber{6152}{95cf}
\createlinenumber{6153}{427e}
\createlinenumber{6154}{4fc1}
\createlinenumber{6155}{4506}
\createlinenumber{6156}{b658}
\createlinenumber{6157}{4506}
\createlinenumber{6158}{d266}
\createlinenumber{6159}{52b2}
\createlinenumber{6160}{de34}
\createlinenumber{6161}{ae56}
\createlinenumber{6162}{ee0f}
\createlinenumber{6163}{95cf}
\createlinenumber{6164}{764a}
\createlinenumber{6165}{8a75}
\createlinenumber{6166}{4180}
\createlinenumber{6167}{52b2}
\createlinenumber{6168}{d5f4}
\createlinenumber{6169}{d7d4}
\createlinenumber{6170}{94b4}
\createlinenumber{6171}{983a}
\createlinenumber{6172}{80bd}
\createlinenumber{6173}{0ff3}
\createlinenumber{6174}{c451}
\createlinenumber{6175}{ee0f}
\createlinenumber{6176}{95cf}
\createlinenumber{6177}{427e}
\createlinenumber{6178}{c619}
\createlinenumber{6179}{4506}
\createlinenumber{6180}{14e2}
\createlinenumber{6181}{00cd}
\createlinenumber{6182}{e10a}
\createlinenumber{6183}{b826}
\createlinenumber{6184}{05ab}
\createlinenumber{6185}{27df}
\createlinenumber{6186}{ca92}
\createlinenumber{6187}{3cfc}
\createlinenumber{6188}{7459}
\createlinenumber{6189}{7021}
\createlinenumber{6190}{95cf}
\createlinenumber{6191}{427e}
\createlinenumber{6192}{fac4}
\createlinenumber{6193}{4506}
\createlinenumber{6194}{79d6}
\createlinenumber{6195}{7814}
\createlinenumber{6196}{5bc9}
\createlinenumber{6197}{ce5d}
\createlinenumber{6198}{25fa}
\createlinenumber{6199}{5951}
\createlinenumber{6200}{95cf}
\createlinenumber{6201}{427e}
\createlinenumber{6202}{534e}
\createlinenumber{6203}{4506}
\createlinenumber{6204}{14e2}
\createlinenumber{6205}{00cd}
\createlinenumber{6206}{7814}
\createlinenumber{6207}{1695}
\createlinenumber{6208}{7814}
\createlinenumber{6209}{049f}
\createlinenumber{6210}{6802}
\createlinenumber{6211}{070b}
\createlinenumber{6212}{e325}
\createlinenumber{6213}{ef6e}
\createlinenumber{6214}{95cf}
\createlinenumber{6215}{427e}
\createlinenumber{6216}{6780}
\createlinenumber{6217}{4506}
\createlinenumber{6218}{644f}
\createlinenumber{6219}{381d}
\createlinenumber{6220}{7814}
\createlinenumber{6221}{a991}
\createlinenumber{6222}{6227}
\createlinenumber{6223}{ef6e}
\createlinenumber{6224}{95cf}
\createlinenumber{6225}{427e}
\createlinenumber{6226}{f045}
\createlinenumber{6227}{4506}
\createlinenumber{6228}{eacc}
\createlinenumber{6229}{8e5d}
\createlinenumber{6230}{4506}
\createlinenumber{6231}{2c8e}
\createlinenumber{6232}{9795}
\createlinenumber{6233}{95cf}
\createlinenumber{6234}{649a}
\createlinenumber{6235}{4506}
\createlinenumber{6236}{bbc3}
\createlinenumber{6237}{0e51}
\createlinenumber{6238}{28e2}
\createlinenumber{6239}{95cf}
\createlinenumber{6240}{ee0f}
\createlinenumber{6241}{95cf}
\createlinenumber{6242}{427e}
\createlinenumber{6243}{385b}
\createlinenumber{6244}{4506}
\createlinenumber{6245}{eacc}
\createlinenumber{6246}{0447}
\createlinenumber{6247}{0e51}
\createlinenumber{6248}{28e2}
\createlinenumber{6249}{ee0f}
\createlinenumber{6250}{95cf}
\createlinenumber{6251}{427e}
\createlinenumber{6252}{a006}
\createlinenumber{6253}{4506}
\createlinenumber{6254}{c5a3}
\createlinenumber{6255}{c9e8}
\createlinenumber{6256}{db62}
\createlinenumber{6257}{d4ab}
\createlinenumber{6258}{f6a1}
\createlinenumber{6259}{4506}
\createlinenumber{6260}{a39d}
\createlinenumber{6261}{2dd9}
\createlinenumber{6262}{9f03}
\createlinenumber{6263}{649a}
\createlinenumber{6264}{db62}
\createlinenumber{6265}{95cf}
\createlinenumber{6266}{d6cf}
\createlinenumber{6267}{4a25}
\createlinenumber{6268}{1aa5}
\createlinenumber{6269}{e9ef}
\createlinenumber{6270}{0dd2}
\createlinenumber{6271}{95cf}
\createlinenumber{6272}{427e}
\createlinenumber{6273}{9469}
\createlinenumber{6274}{a5c5}
\createlinenumber{6275}{4506}
\createlinenumber{6276}{f828}
\createlinenumber{6277}{4506}
\createlinenumber{6278}{e4b6}
\createlinenumber{6279}{95cf}
\createlinenumber{6280}{649a}
\createlinenumber{6281}{4506}
\createlinenumber{6282}{d6d6}
\createlinenumber{6283}{95cf}
\createlinenumber{6284}{95cf}
\createlinenumber{6285}{427e}
\createlinenumber{6286}{32b6}
\createlinenumber{6287}{5dfa}
\createlinenumber{6288}{4506}
\createlinenumber{6289}{fc76}
\createlinenumber{6290}{4506}
\createlinenumber{6291}{f477}
\createlinenumber{6292}{95cf}
\createlinenumber{6293}{649a}
\createlinenumber{6294}{4506}
\createlinenumber{6295}{98fc}
\createlinenumber{6296}{95cf}
\createlinenumber{6297}{95cf}
\createlinenumber{6298}{673d}
\createlinenumber{6299}{4506}
\createlinenumber{6300}{5946}
\createlinenumber{6301}{95cf}
\createlinenumber{6302}{a9be}
\createlinenumber{6303}{4506}
\createlinenumber{6304}{85aa}
\createlinenumber{6305}{2440}
\createlinenumber{6306}{4aa2}
\createlinenumber{6307}{4506}
\createlinenumber{6308}{e2bf}
\createlinenumber{6309}{b333}
\createlinenumber{6310}{1972}
\createlinenumber{6311}{6820}
\createlinenumber{6312}{b218}
\createlinenumber{6313}{8c75}
\createlinenumber{6314}{d48b}
\createlinenumber{6315}{95cf}
\createlinenumber{6316}{e805}
\createlinenumber{6317}{6820}
\createlinenumber{6318}{7670}
\createlinenumber{6319}{8c75}
\createlinenumber{6320}{8e9c}
\createlinenumber{6321}{8154}
\createlinenumber{6322}{588a}
\createlinenumber{6323}{ee0f}
\createlinenumber{6324}{95cf}
\createlinenumber{6325}{427e}
\createlinenumber{6326}{cb4d}
\createlinenumber{6327}{4506}
\createlinenumber{6328}{2657}
\createlinenumber{6329}{a887}
\createlinenumber{6330}{95cf}
\createlinenumber{6331}{427e}
\createlinenumber{6332}{be87}
\createlinenumber{6333}{4506}
\createlinenumber{6334}{383a}
\createlinenumber{6335}{fdc8}
\createlinenumber{6336}{8e8f}
\createlinenumber{6337}{95cf}
\createlinenumber{6338}{427e}
\createlinenumber{6339}{6b0b}
\createlinenumber{6340}{4506}
\createlinenumber{6341}{d18b}
\createlinenumber{6342}{9a76}
\createlinenumber{6343}{5c9b}
\createlinenumber{6344}{8d8a}
\createlinenumber{6345}{7caf}
\createlinenumber{6346}{8836}
\createlinenumber{6347}{95cf}
\createlinenumber{6348}{427e}
\createlinenumber{6349}{427e}
\begin{lstlisting}[language=C++]
typedef double db;
const db EPS = 1e-9;
//由于硬件限制，浮点数运算有误差，eps用来消除误差
inline int sign(db a) { return a < -EPS ? -1 : a > EPS; }
//判断数符号，负数返回-1，0返回0，正数返回1
inline int cmp(db a, db b) { return sign(a - b); }
//比较两数大小
//点类，向量类
//因为有许多操作相似，所以并在一起
struct P
{
    db x, y;
    //点表示坐标，向量表示向量
    P() {}
    P(db _x, db _y) : x(_x), y(_y) {}
    //构造函数
    P operator+(P p) { return {x + p.x, y + p.y}; }
    P operator-(P p) { return {x - p.x, y - p.y}; }
    P operator*(db d) { return {x * d, y * d}; }
    P operator/(db d) { return {x / d, y / d}; }
    //向量加减乘除
    bool operator<(P p) const
    {
        int c = cmp(x, p.x);
        if (c)
            return c == -1;
        return cmp(y, p.y) == -1;
    }
    bool operator==(P o) const
    {
        return cmp(x, o.x) == 0 && cmp(y, o.y) == 0;
    }
    //比较字典序
    db dot(P p) { return x * p.x + y * p.y; }
    //点积
    db det(P p) { return x * p.y - y * p.x; }
    //叉积
    db distTo(P p) { return (*this - p).abs(); }
    //点距离
    db alpha() { return atan2(y, x); }
    void read() { cin >> x >> y; }
    void write() { cout << "(" << x << "," << y << ")" << endl; }
    db abs() { return sqrt(abs2()); }
    db abs2() { return x * x + y * y; }
    P rot90() { return P(-y, x); }
    P unit() { return *this / abs(); }
    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }
    //判断点在极角坐标系上半边还是下半边，极点和极轴也算上半边
    P rot(db an) { return {x * cos(an) - y * sin(an), x * sin(an) + y * cos(an)}; }
    //向量旋转
};
//线类，半平面类
struct L
{ // ps[0] -> ps[1]
    P ps[2];
    P &operator[](int i) { return ps[i]; }
    P dir() { return ps[1] - ps[0]; }
    L(P a, P b)
    {
        ps[0] = a;
        ps[1] = b;
    }
    bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) > 0; }
    L push()
    { // push eps outward
        const double eps = 1e-8;
        P delta = (ps[1] - ps[0]).rot90().unit() * eps;
        return {ps[0] + delta, ps[1] + delta};
    }
};

#define cross(p1, p2, p3) ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y))
#define crossOp(p1, p2, p3) sign(cross(p1, p2, p3))
//叉积，可以用来求三角形面积（输入参数是三个点）
bool chkLL(P p1, P p2, P q1, P q2)
{
    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
    return sign(a1 + a2) != 0;
}
//判断向量平行
P isLL(P p1, P p2, P q1, P q2)
{
    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
    return (p1 * a2 + p2 * a1) / (a1 + a2);
}
P isLL(L l1, L l2) { return isLL(l1[0], l1[1], l2[0], l2[1]); }
//求直线交点
bool intersect(db l1, db r1, db l2, db r2)
{
    if (l1 > r1)
        swap(l1, r1);
    if (l2 > r2)
        swap(l2, r2);
    return !(cmp(r1, l2) == -1 || cmp(r2, l1) == -1);
}
bool isSS(P p1, P p2, P q1, P q2)
{
    return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y) &&
           crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <= 0;
}

bool isSS_strict(P p1, P p2, P q1, P q2)
{
    return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) < 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;
}
//判断线段相交，交在端点算不算分为严格不严格
bool isMiddle(db a, db m, db b)
{
    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);
}
bool isMiddle(P a, P m, P b)
{
    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);
}
bool onSeg(P p1, P p2, P q)
{
    return crossOp(p1, p2, q) == 0 && isMiddle(p1, q, p2);
}
bool onSeg_strict(P p1, P p2, P q)
{
    return crossOp(p1, p2, q) == 0 && sign((q - p1).dot(p1 - p2)) * sign((q - p2).dot(p1 - p2)) < 0;
}
//点在线段上判定
P proj(P p1, P p2, P q)
{
    P dir = p2 - p1;
    return p1 + dir * (dir.dot(q - p1) / dir.abs2());
}
P reflect(P p1, P p2, P q)
{
    return proj(p1, p2, q) * 2 - q;
}
db nearest(P p1, P p2, P q)
{
    if (p1 == p2)
        return p1.distTo(q);
    P h = proj(p1, p2, q);
    if (isMiddle(p1, h, p2))
        return q.distTo(h);
    return min(p1.distTo(q), p2.distTo(q));
}
//投影，反射，最近点
//最近点是线段外一点到线段上的点的最短距离
db disSS(P p1, P p2, P q1, P q2)
{
    if (isSS(p1, p2, q1, q2))
        return 0;
    return min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));
}
//线段距离
db rad(P p1, P p2)
{
    return atan2l(p1.det(p2), p1.dot(p2));
}

db incircle(P p1, P p2, P p3)
{
    db A = p1.distTo(p2);
    db B = p2.distTo(p3);
    db C = p3.distTo(p1);
    return sqrtl(A * B * C / (A + B + C));
}

// polygon
//简单多边形的问题只有判断点在多边形内，和多边形面积简单，其他只做凸多边形
db area(vector<P> ps)
{
    db ret = 0;
    for(int i=0;i<ps.size();++i) 
        ret += ps[i].det(ps[(i + 1) % ps.size()]);
    return ret / 2;
}
//多边形面积
int contain(vector<P> ps, P p)
{ // 2:inside,1:on_seg,0:outside
    int n = ps.size(), ret = 0;
    rep(i, 0, n)
    {
        P u = ps[i], v = ps[(i + 1) % n];
        if (onSeg(u, v, p))
            return 1;
        if (cmp(u.y, v.y) <= 0)
            swap(u, v);
        if (cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0)
            continue;
        ret ^= crossOp(p, u, v) > 0;
    }
    return ret * 2;
}
//判断点在多边形内
vector<P> convexHull(vector<P> ps)
{
    int n = ps.size();
    if (n <= 1)
        return ps;
    sort(ps.begin(), ps.end());
    vector<P> qs(n * 2);
    int k = 0;
    for (int i = 0; i < n; qs[k++] = ps[i++])
        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)
            --k;
    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)
            --k;
    qs.resize(k - 1);
    return qs;
}
vector<P> convexHullNonStrict(vector<P> ps)
{
    // caution: need to unique the Ps first
    int n = ps.size();
    if (n <= 1)
        return ps;
    sort(ps.begin(), ps.end());
    vector<P> qs(n * 2);
    int k = 0;
    for (int i = 0; i < n; qs[k++] = ps[i++])
        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0)
            --k;
    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0)
            --k;
    qs.resize(k - 1);
    return qs;
}
//凸包

db convexDiameter(vector<P> ps)
{
    int n = ps.size();
    if (n <= 1)
        return 0;
    int is = 0, js = 0;
    rep(k, 1, n) is = ps[k] < ps[is] ? k : is, js = ps[js] < ps[k] ? k : js;
    int i = is, j = js;
    db ret = ps[i].distTo(ps[j]);
    do
    {
        if ((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0)
            (++j) %= n;
        else
            (++i) %= n;
        ret = max(ret, ps[i].distTo(ps[j]));
    } while (i != is || j != js);
    return ret;
}
//凸包直径
vector<P> convexCut(const vector<P> &ps, P q1, P q2)
{
    vector<P> qs;
    int n = ps.size();
    rep(i, 0, n)
    {
        P p1 = ps[i], p2 = ps[(i + 1) % n];
        int d1 = crossOp(q1, q2, p1), d2 = crossOp(q1, q2, p2);
        if (d1 >= 0)
            qs.pb(p1);
        if (d1 * d2 < 0)
            qs.pb(isLL(p1, p2, q1, q2));
    }
    return qs;
}
//直线切割凸包，返回直线左边凸包的点
db min_dist(vector<P> &ps, int l, int r)
{
    if (r - l <= 5)
    {
        db ret = 1e18;
        for(int i=l;i<r;++i)
            for(int j=l;j<i;++j)
                ret = min(ret, ps[i].distTo(ps[j]));
        return ret;
    }
    int m = (l + r) >> 1;
    db ret = min(min_dist(ps, l, m), min_dist(ps, m, r));
    vector<P> qs;
    for(int i=l;i<r;++i)
        if (abs(ps[i].x - ps[m].x) <= ret)
            qs.push_back(ps[i]);
    sort(qs.begin(), qs.end(), [](P a, P b) -> bool
         { return a.y < b.y; });
    for(int i=1;i<qs.size();++i) 
        for (int j = i - 1; j >= 0 && qs[j].y >= qs[i].y - ret; --j)
            ret = min(ret, qs[i].distTo(qs[j]));
    return ret;
}
//平面最近点对,[l,r)，要求ps按x升序
int type(P o1, db r1, P o2, db r2)//圆与圆的位置关系
{
    db d = o1.distTo(o2);
    if (cmp(d, r1 + r2) == 1)
        return 4;
    if (cmp(d, r1 + r2) == 0)
        return 3;
    if (cmp(d, abs(r1 - r2)) == 1)
        return 2;
    if (cmp(d, abs(r1 - r2)) == 0)
        return 1;
    return 0;
}

vector<P> isCL(P o, db r, P p1, P p2)
{
    if (cmp(abs((o - p1).det(p2 - p1) / p1.distTo(p2)), r) > 0)
        return {};
    db x = (p1 - o).dot(p2 - p1), y = (p2 - p1).abs2(), d = x * x - y * ((p1 - o).abs2() - r * r);
    d = max(d, (db)0.0);
    P m = p1 - (p2 - p1) * (x / y), dr = (p2 - p1) * (sqrt(d) / y);
    return {m - dr, m + dr}; // along dir: p1->p2
}

vector<P> isCC(P o1, db r1, P o2, db r2)
{ // need to check whether two circles are the same
    db d = o1.distTo(o2);
    if (cmp(d, r1 + r2) == 1)
        return {};
    if (cmp(d, abs(r1 - r2)) == -1)
        return {};
    d = min(d, r1 + r2);
    db y = (r1 * r1 + d * d - r2 * r2) / (2 * d), x = sqrt(r1 * r1 - y * y);
    P dr = (o2 - o1).unit();
    P q1 = o1 + dr * y, q2 = dr.rot90() * x;
    return {q1 - q2, q1 + q2}; // along circle 1
}

vector<P> tanCP(P o, db r, P p)
{
    db x = (p - o).abs2(), d = x - r * r;
    if (sign(d) <= 0)
        return {}; // on circle => no tangent
    P q1 = o + (p - o) * (r * r / x);
    P q2 = (p - o).rot90() * (r * sqrt(d) / x);
    return {q1 - q2, q1 + q2}; // counter clock-wise
}

vector<L> extanCC(P o1, db r1, P o2, db r2)
{
    vector<L> ret;
    if (cmp(r1, r2) == 0)
    {
        P dr = (o2 - o1).unit().rot90() * r1;
        ret.pb(L(o1 + dr, o2 + dr)), ret.pb(L(o1 - dr, o2 - dr));
    }
    else
    {
        P p = (o2 * r1 - o1 * r2) / (r1 - r2);
        vector<P> ps = tanCP(o1, r1, p), qs = tanCP(o2, r2, p);
        rep(i, 0, min(ps.size(), qs.size())) ret.pb(L(ps[i], qs[i])); // c1 counter-clock wise
    }
    return ret;
}

vector<L> intanCC(P o1, db r1, P o2, db r2)
{
    vector<L> ret;
    P p = (o1 * r2 + o2 * r1) / (r1 + r2);
    vector<P> ps = tanCP(o1, r1, p), qs = tanCP(o2, r2, p);
    rep(i, 0, min(ps.size(), qs.size())) ret.pb(L(ps[i], qs[i])); // c1 counter-clock wise
    return ret;
}

db areaCT(db r, P p1, P p2)
{
    vector<P> is = isCL(P(0, 0), r, p1, p2);
    if (is.empty())
        return r * r * rad(p1, p2) / 2;
    bool b1 = cmp(p1.abs2(), r * r) == 1, b2 = cmp(p2.abs2(), r * r) == 1;
    if (b1 && b2)
    {
        if (sign((p1 - is[0]).dot(p2 - is[0])) <= 0 &&
            sign((p1 - is[0]).dot(p2 - is[0])) <= 0)
            return r * r * (rad(p1, is[0]) + rad(is[1], p2)) / 2 + is[0].det(is[1]) / 2;
        else
            return r * r * rad(p1, p2) / 2;
    }
    if (b1)
        return (r * r * rad(p1, is[0]) + is[0].det(p2)) / 2;
    if (b2)
        return (p1.det(is[1]) + r * r * rad(is[1], p2)) / 2;
    return p1.det(p2) / 2;
}

bool parallel(L l0, L l1) { return sign(l0.dir().det(l1.dir())) == 0; }
bool cmp(P a, P b)
{
    if (a.quad() != b.quad())
    {
        return a.quad() < b.quad();
    }
    else
    {
        return sign(a.det(b)) > 0;
    }
}
//极角排序
bool sameDir(L l0, L l1) { return parallel(l0, l1) && sign(l0.dir().dot(l1.dir())) == 1; }
bool operator<(L l0, L l1)
{
    if (sameDir(l0, l1))
    {
        return l1.include(l0[0]);
    }
    else
    {
        return cmp(l0.dir(), l1.dir());
    }
}
bool check(L u, L v, L w)
{
    return w.include(isLL(u, v));
}
vector<P> halfPlaneIS(vector<L> &l)
{
    sort(l.begin(), l.end());
    deque<L> q;
    for (int i = 0; i < (int)l.size(); ++i)
    {
        if (i && sameDir(l[i], l[i - 1]))
            continue;
        while (q.size() > 1 && !check(q[q.size() - 2], q[q.size() - 1], l[i]))
            q.pop_back();
        while (q.size() > 1 && !check(q[1], q[0], l[i]))
            q.pop_front();
        q.push_back(l[i]);
    }
    while (q.size() > 2 && !check(q[q.size() - 2], q[q.size() - 1], q[0]))
        q.pop_back();
    while (q.size() > 2 && !check(q[1], q[0], q[q.size() - 1]))
        q.pop_front();
    vector<P> ret;
    for (int i = 0; i < (int)q.size(); ++i)
        ret.push_back(isLL(q[i], q[(i + 1) % q.size()]));
    return ret;
}
//半平面交
P inCenter(P A, P B, P C)
{
    double a = (B - C).abs(), b = (C - A).abs(), c = (A - B).abs();
    return (A * a + B * b + C * c) / (a + b + c);
}
//内心，角平分线的交点
P circumCenter(P a, P b, P c)
{
    P bb = b - a, cc = c - a;
    double db = bb.abs2(), dc = cc.abs2(), d = 2 * bb.det(cc);
    return a - P(bb.y * dc - cc.y * db, cc.x * db - bb.x * dc) / d;
}
//外心，垂直平分线的交点
P orthoCenter(P a, P b, P c)
{
    P ba = b - a, ca = c - a, bc = b - c;
    double Y = ba.y * ca.y * bc.y,
           A = ca.x * ba.y - ba.x * ca.y,
           x0 = (Y + ca.x * ba.y * b.x - ba.x * ca.y * c.x) / A,
           y0 = -ba.x * (x0 - c.x) / ba.y + ca.y;
    return {x0, y0};
}
//垂心，垂线的交点

\end{lstlisting}
\subsection{平面最近点对\_分治}
\createlinenumber{6350}{302f}
\createlinenumber{6351}{0dfa}
\createlinenumber{6352}{3eb4}
\createlinenumber{6353}{a8cb}
\createlinenumber{6354}{41bd}
\createlinenumber{6355}{1937}
\createlinenumber{6356}{421c}
\createlinenumber{6357}{c115}
\createlinenumber{6358}{427e}
\createlinenumber{6359}{1132}
\createlinenumber{6360}{e6d9}
\createlinenumber{6361}{6f80}
\createlinenumber{6362}{f52b}
\createlinenumber{6363}{63e5}
\createlinenumber{6364}{da75}
\createlinenumber{6365}{3d71}
\createlinenumber{6366}{28ec}
\createlinenumber{6367}{0ab4}
\createlinenumber{6368}{f579}
\createlinenumber{6369}{b23c}
\createlinenumber{6370}{a7c7}
\createlinenumber{6371}{f2e2}
\createlinenumber{6372}{ab7b}
\createlinenumber{6373}{fd78}
\createlinenumber{6374}{5c83}
\createlinenumber{6375}{f1a7}
\createlinenumber{6376}{ba04}
\createlinenumber{6377}{8d53}
\createlinenumber{6378}{9712}
\createlinenumber{6379}{95cf}
\createlinenumber{6380}{07b0}
\createlinenumber{6381}{7b64}
\createlinenumber{6382}{caaa}
\createlinenumber{6383}{a935}
\createlinenumber{6384}{95cf}
\createlinenumber{6385}{876f}
\createlinenumber{6386}{65bd}
\createlinenumber{6387}{433b}
\createlinenumber{6388}{8abb}
\createlinenumber{6389}{bfe3}
\createlinenumber{6390}{1ea7}
\createlinenumber{6391}{3dd2}
\createlinenumber{6392}{947b}
\createlinenumber{6393}{ddca}
\createlinenumber{6394}{ae65}
\createlinenumber{6395}{95cf}
\createlinenumber{6396}{95cf}
\createlinenumber{6397}{30d0}
\createlinenumber{6398}{7b35}
\createlinenumber{6399}{649c}
\createlinenumber{6400}{4d1d}
\createlinenumber{6401}{95cf}
\createlinenumber{6402}{95cf}
\createlinenumber{6403}{5d89}
\createlinenumber{6404}{95cf}
\createlinenumber{6405}{9627}
\createlinenumber{6406}{e1b6}
\createlinenumber{6407}{ec42}
\createlinenumber{6408}{75af}
\createlinenumber{6409}{444f}
\createlinenumber{6410}{5b60}
\createlinenumber{6411}{95cf}
\createlinenumber{6412}{427e}
\createlinenumber{6413}{3b32}
\createlinenumber{6414}{212b}
\createlinenumber{6415}{7618}
\createlinenumber{6416}{0dfa}
\createlinenumber{6417}{f049}
\createlinenumber{6418}{427e}
\createlinenumber{6419}{427e}
\createlinenumber{6420}{1937}
\createlinenumber{6421}{8b6f}
\createlinenumber{6422}{427e}
\createlinenumber{6423}{205d}
\createlinenumber{6424}{0dfa}
\createlinenumber{6425}{4208}
\createlinenumber{6426}{0369}
\createlinenumber{6427}{1937}
\createlinenumber{6428}{7021}
\createlinenumber{6429}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
#ifdef LOCAL
#include "debug.h"
#else
#define deb(...)
#endif
using namespace std;
#define ll long long
// #define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define db long double
#define baoliu(x, y) cout << fixed << setprecision(y) << x
#define endl "\n"
#define alls(x) (x).begin(), (x).end()
#define fs first
#define sec second
#define bug(x) cerr << #x << " = " << x << endl
const int N = 2e6 + 10;
const int M = 1e6 + 10;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
const double eps = 1e-8;
const double PI = acos(-1.0);
int n;
struct node {
    db x, y;
    bool operator<(const node &A) const {
        return x < A.x;
    }
} a[N], c[N];
db dis(node c, node d) {
    db c1 = c.x - d.x, c2 = c.y - d.y;
    return sqrt(c1 * c1 + c2 * c2);
}
db cal(int l, int r) {
    if (l == r)
        return 1e12;
    int cnt = 0;
    int mid = (l + r) >> 1;
    db d = min(cal(l, mid), cal(mid + 1, r));
    for (int i = l; i <= r; i++) {
        if (fabs(a[i].x - a[mid].x) < d) {
            c[++cnt].y = a[i].x;
            c[cnt].x = a[i].y;
        }
    }
    sort(c + 1, c + 1 + cnt);
    for (int i = 1; i <= cnt; i++) {
        for (int j = i + 1; j <= cnt && fabs(c[j].y - c[i].y) < d; j++) {
            d = min(d, dis(c[i], c[j]));
        }
    }
    return d;
}
void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y;
    sort(a + 1, a + 1 + n);
    db ans = cal(1, n);
    baoliu(ans, 12);
}

signed main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
#ifdef LOCAL
    double starttime = clock();
    // freopen("in.txt", "r", stdin);
    // freopen("out.txt", "w", stdout);
#endif
    int t = 1;
    // cin >> t;
    while (t--) solve();
#ifdef LOCAL
    double endtime = clock();
    cerr << "Time Used: " << (double)(endtime - starttime) / CLOCKS_PER_SEC * 1000 << " ms" << endl;
#endif
    return 0;
}
\end{lstlisting}
\section{other}
\subsection{Compile\_cmd}
\createlinenumber{6430}{ff04}
\createlinenumber{6431}{ffa5}
\createlinenumber{6432}{1d1c}
\createlinenumber{6433}{a655}
\createlinenumber{6434}{869f}
\begin{lstlisting}[language=C++]
"cpp": "cd $dir 
&& g++ $fileName  -Wall -Wextra 
-fsanitize=undefined -DLOCAL -D_GLIBCXX_DEBUG 
-std=c++17 -g -O2 -o $fileNameWithoutExt 
&& $dir/$fileNameWithoutExt",
\end{lstlisting}
\subsection{debug}
\createlinenumber{6435}{302f}
\createlinenumber{6436}{427e}
\createlinenumber{6437}{421c}
\createlinenumber{6438}{427e}
\createlinenumber{6439}{f81d}
\createlinenumber{6440}{bc97}
\createlinenumber{6441}{2b39}
\createlinenumber{6442}{6070}
\createlinenumber{6443}{4ae4}
\createlinenumber{6444}{fd3b}
\createlinenumber{6445}{7e78}
\createlinenumber{6446}{5967}
\createlinenumber{6447}{3c00}
\createlinenumber{6448}{869e}
\createlinenumber{6449}{0564}
\createlinenumber{6450}{0551}
\createlinenumber{6451}{1f4a}
\createlinenumber{6452}{427e}
\createlinenumber{6453}{b933}
\createlinenumber{6454}{6cc1}
\createlinenumber{6455}{4506}
\createlinenumber{6456}{f4a2}
\createlinenumber{6457}{6b62}
\createlinenumber{6458}{4010}
\createlinenumber{6459}{9906}
\createlinenumber{6460}{ba23}
\createlinenumber{6461}{95cf}
\createlinenumber{6462}{b7ec}
\createlinenumber{6463}{b2a6}
\createlinenumber{6464}{4506}
\createlinenumber{6465}{a949}
\createlinenumber{6466}{f4a2}
\createlinenumber{6467}{85ca}
\createlinenumber{6468}{ce0f}
\createlinenumber{6469}{718e}
\createlinenumber{6470}{95cf}
\createlinenumber{6471}{57b6}
\createlinenumber{6472}{d48e}
\createlinenumber{6473}{0588}
\createlinenumber{6474}{4506}
\createlinenumber{6475}{19c1}
\createlinenumber{6476}{d1b2}
\createlinenumber{6477}{3419}
\createlinenumber{6478}{b652}
\createlinenumber{6479}{95cf}
\createlinenumber{6480}{022e}
\createlinenumber{6481}{aaf3}
\createlinenumber{6482}{2cea}
\createlinenumber{6483}{0832}
\createlinenumber{6484}{a8cb}
\createlinenumber{6485}{3919}
\createlinenumber{6486}{1937}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>

using namespace std;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char *x) { cerr << '\"' << x << '\"'; }
void __print(const string &x) { cerr << '\"' << x << '\"'; }
void __print(bool x) { cerr << (x ? "true" : "false"); }

template <typename T, typename V>
void __print(const pair<T, V> &x)
{
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T>
void __print(const T &x)
{
    int f = 0;
    cerr << '{';
    for (auto &i : x)
        cerr << (f++ ? "," : ""), __print(i);
    cerr << "}";
}
void _print() { cerr << "]\n"; }//没有剩余参数时递归调用
template <typename T, typename... V>
void _print(T t, V... v)
{
    __print(t);
    if (sizeof...(v))
        cerr << ", ";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define deb(x...)                 \
    cerr << "[" << #x << "] = ["; \
    _print(x)
#else
#define deb(x...)
#endif
\end{lstlisting}
\subsection{duipai\_linux}
\createlinenumber{6487}{ea68}
\createlinenumber{6488}{427e}
\createlinenumber{6489}{9d63}
\createlinenumber{6490}{317b}
\createlinenumber{6491}{57ee}
\begin{lstlisting}[language=C++]
#!/bin/bash

while ./data > in.txt && ./a < in.txt > out.txt && ./std < in.txt > std.txt && diff out.txt std.txt; do
    echo "no problem meow!"
done
\end{lstlisting}
\subsection{duipai\_win}
\createlinenumber{6492}{302f}
\createlinenumber{6493}{421c}
\createlinenumber{6494}{5ee8}
\createlinenumber{6495}{d513}
\createlinenumber{6496}{3eb5}
\createlinenumber{6497}{7f5f}
\createlinenumber{6498}{0aaa}
\createlinenumber{6499}{427e}
\createlinenumber{6500}{c125}
\createlinenumber{6501}{95cf}
\createlinenumber{6502}{3117}
\createlinenumber{6503}{191e}
\createlinenumber{6504}{3333}
\createlinenumber{6505}{73a9}
\createlinenumber{6506}{32b8}
\createlinenumber{6507}{e8be}
\createlinenumber{6508}{113a}
\createlinenumber{6509}{b2d9}
\createlinenumber{6510}{bcb5}
\createlinenumber{6511}{8413}
\createlinenumber{6512}{7ab0}
\createlinenumber{6513}{75d0}
\createlinenumber{6514}{427e}
\createlinenumber{6515}{df2e}
\createlinenumber{6516}{c003}
\createlinenumber{6517}{6173}
\createlinenumber{6518}{f16a}
\createlinenumber{6519}{d541}
\createlinenumber{6520}{6173}
\createlinenumber{6521}{8e2e}
\createlinenumber{6522}{65ae}
\createlinenumber{6523}{95cf}
\createlinenumber{6524}{95cf}
\createlinenumber{6525}{7021}
\createlinenumber{6526}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
mt19937_64 rnd_64(chrono::system_clock::now().time_since_epoch().count());
void gen() {
    ofstream fout("in.txt");
    /// 添加对应的输入——gen文件寻找
    fout.close();
}
int main() {
    system("g++ std.cpp  -std=c++20 -o std");
    system("g++ test.cpp -std=c++20 -o test");
    double TL = 5000.0;
    for (int i = 1; i <= 100; i++) {
        printf("iteration: %d\n", i);
        gen();
        system("std.exe < in.txt > ans.txt");
        double begin = clock();
        system("test.exe < in.txt > out.txt");
        double end = clock();
        double t = (double)(begin - end) / CLOCKS_PER_SEC * 1000;
        // cout << "Time Used: " << t << " ms" << endl;
        if (system("fc ans.txt out.txt")) {
            printf("test#%d WA\n", i);
            break;
        } else if (t > TL) {
            printf("test#%d TLE timeused  %.0lfms\n", i, t);
            break;
        } else {
            printf("test#%d AC  timeused  %.0lfms\n", i, t);
        }
    }
    return 0;
}
\end{lstlisting}
\subsection{gdbcmd}
\createlinenumber{6527}{7ea2}
\createlinenumber{6528}{54d1}
\createlinenumber{6529}{c1cd}
\createlinenumber{6530}{2d2c}
\createlinenumber{6531}{54c9}
\createlinenumber{6532}{f3d7}
\createlinenumber{6533}{454b}
\createlinenumber{6534}{09bd}
\createlinenumber{6535}{2139}
\createlinenumber{6536}{2181}
\createlinenumber{6537}{6356}
\createlinenumber{6538}{10ba}
\createlinenumber{6539}{0337}
\createlinenumber{6540}{5ef1}
\createlinenumber{6541}{21fd}
\createlinenumber{6542}{1c0b}
\createlinenumber{6543}{e385}
\createlinenumber{6544}{efaa}
\createlinenumber{6545}{6194}
\createlinenumber{6546}{c473}
\createlinenumber{6547}{e936}
\createlinenumber{6548}{a1eb}
\createlinenumber{6549}{c2a7}
\createlinenumber{6550}{3952}
\createlinenumber{6551}{2766}
\createlinenumber{6552}{0816}
\createlinenumber{6553}{2358}
\createlinenumber{6554}{1727}
\createlinenumber{6555}{444b}
\createlinenumber{6556}{6c88}
\begin{lstlisting}[language=C++]
-g
-Wall -Wextra
-Wshadow #防止局部变量不小心遮盖其他变量
-Wformat=2 #防止printf/scanf 写错
-Wconversion #防止意外的类型转换
-Wstack-usage=1 #看栈空间使用情况
-fsanitize=undefined #查找未定义行为
-fsanitize=address #查数组越界
-D_GLIBCXX_DEBUG : STL debug mode
-Wl,--stack=1073741824
-fsanitize=undefined fsanitize-undefined-trap-on-error
# Windows
#define deb(x) (void)(cerr << "L" << __LINE__ << ": "<< #x << " = " << (x) << endl)
建议直接使用GDB 的命令行，-g,建议禁用优化。GDB 的常用命令有：
> b (breakpoint) 行号/函数名
> r (run) [< 输入文件名]
> n (next)
> s (step)
> c (continue)
> p (print) 表达式
> d (disp) 表达式
> cond (condition) 断点编号表达式
> bt (backtrace)
> fr (frame) 栈帧编号
> gcov/-ftest-coverage -fprofile-arcs:代码覆盖率检测
可以看代码中每一行被执行的次数
> gprof/-pg:代码剖析,可以看函数执行时间占总时间的百分
比
> gprof 输出的是时间，但只能精确到函数
> gcov 精确到行，但只能输出调用次数
\end{lstlisting}
\subsection{gen\_data}
\createlinenumber{6557}{d513}
\createlinenumber{6558}{3eb5}
\createlinenumber{6559}{cdb7}
\createlinenumber{6560}{5d4d}
\createlinenumber{6561}{fc58}
\createlinenumber{6562}{8a81}
\createlinenumber{6563}{a788}
\createlinenumber{6564}{0f88}
\createlinenumber{6565}{5378}
\createlinenumber{6566}{b332}
\createlinenumber{6567}{e687}
\createlinenumber{6568}{a198}
\createlinenumber{6569}{ecf7}
\createlinenumber{6570}{95cf}
\createlinenumber{6571}{63e5}
\createlinenumber{6572}{0083}
\createlinenumber{6573}{f644}
\createlinenumber{6574}{eeb1}
\createlinenumber{6575}{98dd}
\createlinenumber{6576}{33cb}
\createlinenumber{6577}{0d80}
\createlinenumber{6578}{95cf}
\createlinenumber{6579}{b7ec}
\createlinenumber{6580}{15b4}
\createlinenumber{6581}{0f3c}
\createlinenumber{6582}{8f68}
\createlinenumber{6583}{16c3}
\createlinenumber{6584}{95cf}
\createlinenumber{6585}{427e}
\createlinenumber{6586}{ac1c}
\createlinenumber{6587}{4fe7}
\createlinenumber{6588}{95cf}
\createlinenumber{6589}{427e}
\createlinenumber{6590}{a694}
\createlinenumber{6591}{2a68}
\createlinenumber{6592}{95cf}
\createlinenumber{6593}{427e}
\createlinenumber{6594}{2def}
\createlinenumber{6595}{b301}
\createlinenumber{6596}{2271}
\createlinenumber{6597}{fe09}
\createlinenumber{6598}{95cf}
\createlinenumber{6599}{427e}
\createlinenumber{6600}{427e}
\begin{lstlisting}[language=C++]
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
mt19937_64 rnd_64(chrono::system_clock::now().time_since_epoch().count());
int rndi(int r) { return rnd() % r; }                        // 随机生成0-(r-1)
int rndi(int l, int r) { return rnd() % (r - l + 1) + l; }   // 随机生成l-r
LL rndll(LL l, LL r) { return rnd_64() % (r - l + 1) + l; }  // 随机生成0-(r-1)
char rndc() { return rndi(-128, 127); }                      // 生成 ASCII 码在 [-128, 127] 范围内的随机字符
char rndc(const string &s) { return s[rndi(s.length())]; }   // 从给定字符串 s 中随机选择一个字符
char rnd_lower() { return rndi(26) + 'a'; }                  // 随机小写字母
char rnd_upper() { return rndi(26) + 'A'; }                  // 大写
char rnd_digit() { return rndi(10) + '0'; }                  // 数字
char rnd_alpha() { // 大小写
    int r = rndi(52);
    return r < 26 ? (r + 'a') : (r - 26 + 'A');
}                        
char rnd_alphadigit() {  // 大小写+数字
    int r = rndi(62);
    if (r < 10)
        return r + '0';
    if (r < 36)
        return r - 10 + 'a';
    return r - 36 + 'A';
}
template <typename T>  // n 个随机值的 vector
vector<T> rnd_vec(int n, const function<T(void)> &f) {
    vector<T> vec;
    while (n--) vec.push_back(f());
    return vec;
}
// n个[l, r] 范围内的随机int
vector<int> rnd_vii(int n, int l, int r) {
    return rnd_vec<int>(n, [=]() { return rndi(l, r); });
}
// n 个在 [l, r] 范围内的随机 long long
vector<LL> rnd_vll(int n, LL l, LL r) {
    return rnd_vec<LL>(n, [=]() { return rndll(l, r); });
}
// 一个长度为 n 的随机字符串。每个字符由函数 f 生成。
string rnds(int n, const function<char(void)> &f) {
    string s;
    while (n--) s += f();
    return s;
}
// cout << rnds(10, []() { return rndc("abc"); }) << endl;
// 生成并输出一个由 10 个从字符串 "abc" 中随机选择的字符组成的字符串。
\end{lstlisting}
\subsection{random\_real\_prime}
\createlinenumber{6601}{427e}
\createlinenumber{6602}{77ab}
\createlinenumber{6603}{09e9}
\createlinenumber{6604}{39b9}
\createlinenumber{6605}{d236}
\createlinenumber{6606}{d1b6}
\createlinenumber{6607}{2202}
\createlinenumber{6608}{b51c}
\createlinenumber{6609}{e7a7}
\createlinenumber{6610}{427e}
\createlinenumber{6611}{f235}
\createlinenumber{6612}{6d32}
\createlinenumber{6613}{c93c}
\createlinenumber{6614}{1026}
\createlinenumber{6615}{34be}
\createlinenumber{6616}{ce56}
\createlinenumber{6617}{1270}
\createlinenumber{6618}{563d}
\createlinenumber{6619}{f563}
\createlinenumber{6620}{6173}
\createlinenumber{6621}{95cf}
\createlinenumber{6622}{95cf}
\createlinenumber{6623}{28cf}
\createlinenumber{6624}{c757}
\createlinenumber{6625}{95cf}
\createlinenumber{6626}{95cf}
\createlinenumber{6627}{427e}
\createlinenumber{6628}{427e}
\createlinenumber{6629}{5f0d}
\createlinenumber{6630}{a30e}
\createlinenumber{6631}{2de4}
\createlinenumber{6632}{2fba}
\createlinenumber{6633}{427e}
\createlinenumber{6634}{d33c}
\createlinenumber{6635}{d8e1}
\createlinenumber{6636}{d513}
\createlinenumber{6637}{3eb5}
\begin{lstlisting}[language=C++]
//随机素数
979345007 986854057502126921
935359631 949054338673679153
931936021 989518940305146613
984974633 972090414870546877
984858209 956380060632801307
static int findprime() {//随机生成质数
    random_device rd;
    mt19937 gen(rd());

    int n = gen() % 900000000 + 100000000;
    if (n % 2 == 0)
        n++;
    while (true) {
        bool ok = 1;
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                ok = 0;
                n += 2;
                break;
            }
        }
        if (ok)
            return n;
    }
}
//---------------------------------------------------------//
//伪随机数生成
#define u64 unsigned long long
#define u32 unsigned int
u64 xorshift(u64 x) { x ^= x << 13; x ^= x >> 7; x ^= x << 17; return x; }
u32 xorshift(u32 x) { x ^= x << 13; x ^= x >> 17; x ^= x << 5; return x; }
//真随机
#include <random>
#include <chrono>
mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());
mt19937_64 rnd_64(chrono::system_clock::now().time_since_epoch().count());
\end{lstlisting}
\subsection{template}
\createlinenumber{6638}{302f}
\createlinenumber{6639}{0dfa}
\createlinenumber{6640}{3eb4}
\createlinenumber{6641}{a8cb}
\createlinenumber{6642}{41bd}
\createlinenumber{6643}{1937}
\createlinenumber{6644}{421c}
\createlinenumber{6645}{c115}
\createlinenumber{6646}{427e}
\createlinenumber{6647}{1132}
\createlinenumber{6648}{e6d9}
\createlinenumber{6649}{81fe}
\createlinenumber{6650}{f52b}
\createlinenumber{6651}{63e5}
\createlinenumber{6652}{da75}
\createlinenumber{6653}{3d71}
\createlinenumber{6654}{28ec}
\createlinenumber{6655}{0ab4}
\createlinenumber{6656}{8334}
\createlinenumber{6657}{b23c}
\createlinenumber{6658}{a7c7}
\createlinenumber{6659}{f2e2}
\createlinenumber{6660}{ab7b}
\createlinenumber{6661}{fd78}
\createlinenumber{6662}{9627}
\createlinenumber{6663}{427e}
\createlinenumber{6664}{95cf}
\createlinenumber{6665}{3b32}
\createlinenumber{6666}{212b}
\createlinenumber{6667}{7618}
\createlinenumber{6668}{0dfa}
\createlinenumber{6669}{f049}
\createlinenumber{6670}{427e}
\createlinenumber{6671}{427e}
\createlinenumber{6672}{1937}
\createlinenumber{6673}{8b6f}
\createlinenumber{6674}{427e}
\createlinenumber{6675}{205d}
\createlinenumber{6676}{0dfa}
\createlinenumber{6677}{4208}
\createlinenumber{6678}{0369}
\createlinenumber{6679}{1937}
\createlinenumber{6680}{7021}
\createlinenumber{6681}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
#ifdef LOCAL
#include "debug.h"
#else
#define deb(...) 
#endif
using namespace std;
#define ll long long
//#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define db double
#define baoliu(x, y) cout << fixed << setprecision(y) << x
#define endl "\n"
#define alls(x) (x).begin(), (x).end()
#define fs first
#define sec second
#define bug(x) cerr << #x << " = " << x << endl
const int N = 2e5 + 10;
const int M = 1e6 + 10;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
const double eps = 1e-8;
const double PI = acos(-1.0);
void solve() {
    
}
signed main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
#ifdef LOCAL
    double starttime = clock();
    // freopen("in.txt", "r", stdin);
    // freopen("out.txt", "w", stdout);
#endif
    int t = 1;
    //cin >> t;
    while (t--) solve();
#ifdef LOCAL
    double endtime=clock();
    cerr << "Time Used: " << (double)(endtime - starttime) / CLOCKS_PER_SEC * 1000 << " ms" << endl;
#endif
    return 0;
}
\end{lstlisting}
\subsection{template\_region}
\createlinenumber{6682}{302f}
\createlinenumber{6683}{421c}
\createlinenumber{6684}{0dfa}
\createlinenumber{6685}{0337}
\createlinenumber{6686}{a8cb}
\createlinenumber{6687}{ac79}
\createlinenumber{6688}{1937}
\createlinenumber{6689}{c115}
\createlinenumber{6690}{427e}
\createlinenumber{6691}{f52b}
\createlinenumber{6692}{63e5}
\createlinenumber{6693}{f2e2}
\createlinenumber{6694}{ab7b}
\createlinenumber{6695}{fd78}
\createlinenumber{6696}{9627}
\createlinenumber{6697}{5c83}
\createlinenumber{6698}{e1b6}
\createlinenumber{6699}{c5d6}
\createlinenumber{6700}{95cf}
\createlinenumber{6701}{3b32}
\createlinenumber{6702}{212b}
\createlinenumber{6703}{7618}
\createlinenumber{6704}{0dfa}
\createlinenumber{6705}{f049}
\createlinenumber{6706}{1736}
\createlinenumber{6707}{8062}
\createlinenumber{6708}{1784}
\createlinenumber{6709}{79bf}
\createlinenumber{6710}{1937}
\createlinenumber{6711}{8b6f}
\createlinenumber{6712}{427e}
\createlinenumber{6713}{205d}
\createlinenumber{6714}{0dfa}
\createlinenumber{6715}{4208}
\createlinenumber{6716}{0369}
\createlinenumber{6717}{1937}
\createlinenumber{6718}{7021}
\createlinenumber{6719}{95cf}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#define deb(x) (void)(cerr << "L" << __LINE__ << ": " << #x << " = " << (x) << endl)
#else
#define deb(x)
#endif
#define ll long long
// #define int long long
#define baoliu(x, y) cout << fixed << setprecision(y) << x
#define endl "\n"
const int mod = 998244353;
const double eps = 1e-8;
const double PI = acos(-1.0);
void solve() {
    int n;
    cin >> n;
    cout << n << endl;
}
signed main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
#ifdef LOCAL
    double starttime = clock();
    auto t1 = freopen("in.txt", "r", stdin);
    auto t2 = freopen("out.txt", "w", stdout);
    assert(t1 != nullptr);
    assert(t2 != nullptr);
#endif
    int t = 1;
    // cin >> t;
    while (t--) solve();
#ifdef LOCAL
    double endtime = clock();
    cerr << "Time Used: " << (double)(endtime - starttime) / CLOCKS_PER_SEC * 1000 << " ms" << endl;
#endif
    return 0;
}
\end{lstlisting}
\subsection{test\_g++}
\createlinenumber{6720}{302f}
\createlinenumber{6721}{421c}
\createlinenumber{6722}{3117}
\createlinenumber{6723}{427e}
\createlinenumber{6724}{be72}
\createlinenumber{6725}{5fab}
\createlinenumber{6726}{d069}
\createlinenumber{6727}{95cf}
\createlinenumber{6728}{3251}
\createlinenumber{6729}{427e}
\createlinenumber{6730}{295f}
\createlinenumber{6731}{e502}
\createlinenumber{6732}{4f2d}
\createlinenumber{6733}{df05}
\createlinenumber{6734}{fd09}
\createlinenumber{6735}{329b}
\createlinenumber{6736}{d2ce}
\createlinenumber{6737}{427e}
\createlinenumber{6738}{236e}
\createlinenumber{6739}{6da0}
\createlinenumber{6740}{787d}
\createlinenumber{6741}{8557}
\createlinenumber{6742}{95cf}
\createlinenumber{6743}{3251}
\createlinenumber{6744}{95cf}
\createlinenumber{6745}{427e}
\createlinenumber{6746}{427e}
\createlinenumber{6747}{e5e8}
\createlinenumber{6748}{5bc3}
\createlinenumber{6749}{9229}
\createlinenumber{6750}{95cf}
\createlinenumber{6751}{3251}
\createlinenumber{6752}{427e}
\createlinenumber{6753}{b89a}
\createlinenumber{6754}{1181}
\createlinenumber{6755}{8e2e}
\createlinenumber{6756}{a7a0}
\createlinenumber{6757}{95cf}
\createlinenumber{6758}{427e}
\createlinenumber{6759}{7021}
\createlinenumber{6760}{95cf}
\createlinenumber{6761}{427e}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
int main() {
    // GNU C++11: Array
    array<int, 3> C = {1, 2, 3};
    for (int i : C) {
        cout << i << " ";
    }
    cout << endl;
    // GNU C++14: Recursive lambda with auto
    auto dfs = [&](auto self, int x) -> void {
        if (x > 10)
            return;
        cout << "DFS at x = " << x << endl;
        self(self, x + 1);
    };
    dfs(dfs, 1);
    // GNU C++17: Template argument deduction for vector
    vector in(2, vector<int>(2, 1));
    for (auto x : in) {
        for (auto y : x) {
            cout << y << " ";
        }
        cout << endl;
    }

    // GNU C++17: Structured bindings
    map<int, int> dic = {{1, 2}, {3, 4}};
    for (auto [u, v] : dic) {
        cout << "{" << u << ", " << v << "} ";
    }
    cout << endl;
    // GNU C++20: contains method for map
    if (dic.contains(1)) {
        cout << "contains" << endl;
    } else {
        cout << "not contain" << endl;
    }

    return 0;
}

\end{lstlisting}
\subsection{test\_speed}
\createlinenumber{6762}{427e}
\createlinenumber{6763}{302f}
\createlinenumber{6764}{421c}
\createlinenumber{6765}{3b32}
\createlinenumber{6766}{23d2}
\createlinenumber{6767}{6eaf}
\createlinenumber{6768}{6dbf}
\createlinenumber{6769}{e6e4}
\createlinenumber{6770}{705e}
\createlinenumber{6771}{ee78}
\createlinenumber{6772}{95cf}
\createlinenumber{6773}{95cf}
\createlinenumber{6774}{95cf}
\createlinenumber{6775}{4bd9}
\createlinenumber{6776}{95cf}
\begin{lstlisting}[language=C++]
// #pragma GCC optimize("Ofast", "unroll-loops")
#include <bits/stdc++.h>
using namespace std;
signed main() {
    int n = 4E3;
    bitset<30> ans;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j += 2) {
            for (int k = 1; k <= n; k += 4) {
                ans |= i | j | k;
            }
        }
    }
    cout << ans.to_ullong() << "\n";
}
\end{lstlisting}
\subsection{teststack}
\createlinenumber{6777}{302f}
\createlinenumber{6778}{421c}
\createlinenumber{6779}{1d43}
\createlinenumber{6780}{427e}
\createlinenumber{6781}{3626}
\createlinenumber{6782}{1e44}
\createlinenumber{6783}{eac7}
\createlinenumber{6784}{427e}
\createlinenumber{6785}{427e}
\createlinenumber{6786}{427e}
\createlinenumber{6787}{4d6a}
\createlinenumber{6788}{acaf}
\createlinenumber{6789}{c4f6}
\createlinenumber{6790}{95cf}
\createlinenumber{6791}{3117}
\createlinenumber{6792}{c4f6}
\createlinenumber{6793}{0f58}
\createlinenumber{6794}{1e44}
\createlinenumber{6795}{7021}
\createlinenumber{6796}{95cf}
\createlinenumber{6797}{427e}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
int cur = 1;
// 需要关闭O2测试
void func() {
    cout << cur << "MB" << endl;
    char arr[1024 * 1024];  // 1MB
    // 使用数组以防止优化
    // if (cur > 1024 )
    //     return;
    int sum = 0;
    cur++;
    func();
}
int main() {
    func();
    cout << "Yes" << endl;
    cout << cur << "MB" << endl;
    return 0;
}

\end{lstlisting}
